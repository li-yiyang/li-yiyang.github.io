<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Untitled(1) | My Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Untitled(1)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="To Learn a Bigger Picture 开始学习CTF, 看的书是Hacking The Art of Exploitation by John Erickson. 发现自己以前玩的电脑竟然还有这么多讲究, 虽然也不是很熟, 总之, 先练着玩玩. 照着书学而已." />
<meta property="og:description" content="To Learn a Bigger Picture 开始学习CTF, 看的书是Hacking The Art of Exploitation by John Erickson. 发现自己以前玩的电脑竟然还有这么多讲究, 虽然也不是很熟, 总之, 先练着玩玩. 照着书学而已." />
<link rel="canonical" href="/ctf/untitled(1)/" />
<meta property="og:url" content="/ctf/untitled(1)/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-29T03:14:16+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Untitled(1)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-29T03:14:16+00:00","datePublished":"2021-10-29T03:14:16+00:00","description":"To Learn a Bigger Picture 开始学习CTF, 看的书是Hacking The Art of Exploitation by John Erickson. 发现自己以前玩的电脑竟然还有这么多讲究, 虽然也不是很熟, 总之, 先练着玩玩. 照着书学而已.","headline":"Untitled(1)","mainEntityOfPage":{"@type":"WebPage","@id":"/ctf/untitled(1)/"},"url":"/ctf/untitled(1)/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">

  <style type="text/css">
    img {
      margin-left: auto; 
      margin-right:auto; 
      display:block;
    }
  </style><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="My Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Untitled(1)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-10-29T03:14:16+00:00" itemprop="datePublished">Oct 29, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="to-learn-a-bigger-picture">To Learn a Bigger Picture</h1>
<p>开始学习CTF, 看的书是Hacking The Art of Exploitation by John Erickson. 
发现自己以前玩的电脑竟然还有这么多讲究, 虽然也不是很熟, 总之, 
先练着玩玩. 照着书学而已.</p>

<p>(因为不知道该给这个取什么名字, 所以就Untitled先吧. )</p>

<p>(从后面来的一句话: 感觉我的这个文字完全就和人类学与现代性老师讲课一样, 
堪称想到那里写那里, 遇到什么问题就去学什么, 肯定会很乱. 堪称杂学. 
但是我不会随便改动的, 因为很麻烦. 看来我是一个学习上的杂食系么. )</p>

<h2 id="偷窥狂">偷窥狂</h2>
<p>在 <a href="https://en.wikipedia.org/wiki/Ghost_in_the_Shell:_Stand_Alone_Complex">攻壳机动队 SAC</a> 
里面, 我记得那个特A级黑客说自己就是一个偷窥狂. 虽然, 但是, 真是十分贴切了. 
想要看到计算机的内部, 而不是只是停留在表面. 我觉得这和物理很像啦, 
都是通过自己的各种方式来得到”谜语”的答案. (虽然我不喜欢猜谜, 但是我很喜欢拆解. )</p>

<p>总之, 先了解一些用来查看的工具:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">file &lt;file&gt;</code> 指出 <code class="language-plaintext highlighter-rouge">&lt;file&gt;</code> 是什么东西</li>
  <li><code class="language-plaintext highlighter-rouge">hexdump &lt;file&gt;</code> 用十六进制来查看文件</li>
  <li><code class="language-plaintext highlighter-rouge">objdump &lt;option(s)&gt; &lt;file(s)&gt;</code> 显示对象<code class="language-plaintext highlighter-rouge">&lt;file(s)&gt;</code>的信息 
目前用(见)到的<code class="language-plaintext highlighter-rouge">&lt;option(s)&gt;</code>有:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">objdump -D &lt;file&gt;</code> 把文件用反编译的方式来看,
说白了就是把十六进制的那种混乱的符号变成
“好懂的”汇编语言(组语, 好像台湾那里这么叫. )</li>
      <li><code class="language-plaintext highlighter-rouge">objdump -M intel -D &lt;file&gt;</code> 书上写的是可以用<code class="language-plaintext highlighter-rouge">intel</code>的语法
类似的语法结构还有<code class="language-plaintext highlighter-rouge">AT&amp;T</code>的<code class="language-plaintext highlighter-rouge">syntax</code>但是我有点懵, 虽然书上写着如此, 
但是我实际操作中并没有得到像书上所说的很好看的结果, 甚至还得到了嘲讽: 
<code class="language-plaintext highlighter-rouge">objdump: unrecognised disassembler option: intel</code>. 罢了. 
我先放着.<br />
据说<code class="language-plaintext highlighter-rouge">AT&amp;T</code>语法结构的特点是在变量(地址)和值前面放上<code class="language-plaintext highlighter-rouge">%</code>和<code class="language-plaintext highlighter-rouge">$</code>符号, 
并且还是所有<code class="language-plaintext highlighter-rouge">linux</code>反编译工具默认的输出形式. 
(但是, 我甚至连这个也看不到. 哭. )</li>
      <li>一般建议是配合<code class="language-plaintext highlighter-rouge">grep</code>一起使用, 如
<code class="language-plaintext highlighter-rouge">objdump -D &lt;file&gt; | grep -A10 main.:</code>
查看<code class="language-plaintext highlighter-rouge">main</code>函数的前十行的反编译的结果.</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">gdb &lt;file&gt;</code> debugger, 调试器, 用来检查已经编译了的程序, 
可以设置断点, 可以检查程序的内存使用(感觉翻译的不到位), 
还可以查看处理器的寄存器(registers), 总之很强大.</p>

    <blockquote>
      <p>A debugger can view the execution from all angles, 
pause it and change anything along the way.</p>
    </blockquote>

    <p>感觉强大到需要专门学习, 我们老师也这么说, 虽然已经鸽了好久了.<br />
我现在有怀疑我是不是做错什么了, 因为我的输出和书上以及网上的都不同. 
咳, 这是什么玄学.</p>
  </li>
</ul>

<h2 id="gdb前的插曲--完全就跑偏了的arm学习">GDB前的插曲 = 完全就跑偏了的ARM学习</h2>
<p>我不管, 教练, 我先学着先.</p>

<p>现在的想法是先掌握一些gdb的用法, 至于为什么会出现bug, 暂时不想它. 
(才怪!!)</p>

<p>我在这里描述一下我遇到的问题: 本来应该<code class="language-plaintext highlighter-rouge">eax</code>, <code class="language-plaintext highlighter-rouge">ebx</code>的东西, 
现在却是<code class="language-plaintext highlighter-rouge">x20</code>, <code class="language-plaintext highlighter-rouge">sp</code>, <code class="language-plaintext highlighter-rouge">w0</code>之类的东西, 这简直完全看不懂么. 
所以我有点怀疑人生, 但是经过了一番搜索, 找到了一篇
<a href="https://tenloy.github.io/2021/04/16/Arm64-Introduce.html">博客</a>
感觉好像这应该是解决问题的一个可行的方向.</p>

<p>(虽然这篇文章注重的是iOS开发的, 不过有什么关系呢? 笑. 
肝就完事了. )</p>

<p>(因为apple的m1是ARM架构, 所以会用ARM的寄存器好像也无可厚非. )</p>

<p>所以我应该看的是ARM syntax的玩意. 咳, intel毁灭吧. 
我看的书和做的CTF问题都是intel么? 看来只好都学了.</p>

<p>那么先记录一下一些基本的知识点, 以后在去学习详细的东西:</p>
<ul>
  <li>x86 &amp; arm asm
    <ul>
      <li><a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86</a></li>
      <li><a href="http://www.cs.uni.edu//~fienup/cs1410s13/lectures/lec13_ARM_Guide.pdf">arm</a></li>
    </ul>
  </li>
</ul>

<h3 id="arm">ARM</h3>
<ul>
  <li>arm registers
    <ul>
      <li><code class="language-plaintext highlighter-rouge">x0 - x30</code>通用寄存器, 32位的形式是<code class="language-plaintext highlighter-rouge">w0 - w30</code></li>
      <li><code class="language-plaintext highlighter-rouge">v0 - v31</code>浮点数寄存器(虽然不知道在那里看到的英文是vector)
用<code class="language-plaintext highlighter-rouge">Bn Hn Sn Dn Qn</code>来表示byte, half word, single word, 
double word, quad word</li>
      <li><code class="language-plaintext highlighter-rouge">wzr</code>, <code class="language-plaintext highlighter-rouge">xzr</code>, <code class="language-plaintext highlighter-rouge">wsp</code>, <code class="language-plaintext highlighter-rouge">sp</code>, <code class="language-plaintext highlighter-rouge">pc</code> 特殊的几个
分别是zero register, current stack pointer, 
program counter 看名字可以区分. (目前不是很清楚)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">zr</code> 用于丢弃结果, 类似于永久回收站? 扔进去就没了, 
因为再去访问就是0.</li>
          <li><code class="language-plaintext highlighter-rouge">sp</code> 和栈有关</li>
          <li><code class="language-plaintext highlighter-rouge">pc</code> 指向下一条要执行的命令, arm64里不可以改写.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">cpsr</code>, <code class="language-plaintext highlighter-rouge">spsr</code> 不是很懂的样子</li>
    </ul>
  </li>
  <li>instructions
    <ul>
      <li>Memory Access (读档? )
        <ul>
          <li><code class="language-plaintext highlighter-rouge">ldr r4, mem</code> : <code class="language-plaintext highlighter-rouge">[r4] &lt;- [mem]</code> 
(<code class="language-plaintext highlighter-rouge">mem</code> is a global varible label)</li>
          <li><code class="language-plaintext highlighter-rouge">str r4, mem</code> : <code class="language-plaintext highlighter-rouge">[r4] -&gt; [mem]</code></li>
          <li><code class="language-plaintext highlighter-rouge">[r3]</code> : indirect access</li>
          <li><code class="language-plaintext highlighter-rouge">[r3, #4]</code> : offset</li>
        </ul>
      </li>
      <li>Move (赋值? )
        <ul>
          <li><code class="language-plaintext highlighter-rouge">mov r4, r2</code> : <code class="language-plaintext highlighter-rouge">[r4] &lt;- [r2]</code></li>
          <li><code class="language-plaintext highlighter-rouge">mov r4, #10</code> : <code class="language-plaintext highlighter-rouge">[r4] &lt;- 10</code></li>
        </ul>
      </li>
      <li>Load Address (取地址算符? )
        <ul>
          <li><code class="language-plaintext highlighter-rouge">adr r4, mem</code> : <code class="language-plaintext highlighter-rouge">[r4] &lt;- load address of mem</code></li>
        </ul>
      </li>
      <li>Compare (<code class="language-plaintext highlighter-rouge">cmp</code>)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">cmp r4, r2</code> : set condition codes by <code class="language-plaintext highlighter-rouge">r4 - r2</code></li>
        </ul>
      </li>
      <li>Branch (<code class="language-plaintext highlighter-rouge">jmp</code>)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">bgt LABEL</code> : condition code greater than 0</li>
          <li><code class="language-plaintext highlighter-rouge">b LABEL</code> : just jump</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>(虽然我觉得一时半会儿我是用不到这个东西的, 
但是我可以很自觉地说: 我知道为什么我的结果和书上不一样了. )</p>

<h3 id="x86-assembly">x86 Assembly</h3>
<ul>
  <li>x86 registers
    <ul>
      <li><code class="language-plaintext highlighter-rouge">eax</code>, <code class="language-plaintext highlighter-rouge">ecx</code>, <code class="language-plaintext highlighter-rouge">edx</code>, <code class="language-plaintext highlighter-rouge">ebx</code> 分别代表
Accumulator, Counter, Data, Base register</li>
      <li><code class="language-plaintext highlighter-rouge">esp</code>, <code class="language-plaintext highlighter-rouge">ebp</code>, <code class="language-plaintext highlighter-rouge">esi</code>, <code class="language-plaintext highlighter-rouge">edi</code> 分别代表
Stack Pointer, Base Pointer, 
Source Index, Destination Index 
(看名字就知道了, 前面两个在程序运行和内存管理上有大用处, 
后面两个在拷贝数据的时候有大用处. )</li>
      <li><code class="language-plaintext highlighter-rouge">eip</code> Instruction Pointer 指向当前处理器执行读取的指令, 
在debug的时候比较有用. (<code class="language-plaintext highlighter-rouge">cp</code>)</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">eflags</code> 由几个比特的flags组成, 用于比较和分割
(used for comparisions and memory segmentations. )</p>

        <blockquote>
          <p>Like a child pointing his finger at each word 
as he reads, the processor reads each instruction
using the EIP register as its finger.</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>x86 instructions
    <ul>
      <li>Address Access:
        <ul>
          <li>registers 直接就是地址, 类似于变量</li>
          <li>offsets <code class="language-plaintext highlighter-rouge">[eax + 8]</code> 通过和标准的位置的差别来得到新的地址</li>
          <li><code class="language-plaintext highlighter-rouge">BYTE PTR [ebx]</code>这样的表示拿一个比特, 
同样的有<code class="language-plaintext highlighter-rouge">WORD</code>, <code class="language-plaintext highlighter-rouge">DWORD</code>等</li>
        </ul>
      </li>
      <li>Move <code class="language-plaintext highlighter-rouge">mov a, b</code> : <code class="language-plaintext highlighter-rouge">a = b</code></li>
      <li>Push, Pop: <code class="language-plaintext highlighter-rouge">push a</code>, <code class="language-plaintext highlighter-rouge">pop a</code></li>
      <li>Condition
        <ul>
          <li><code class="language-plaintext highlighter-rouge">jmp LABEL</code> 直接就是跳转</li>
          <li><code class="language-plaintext highlighter-rouge">cmp a, b</code> 比较一本后面跟着条件跳转</li>
          <li><code class="language-plaintext highlighter-rouge">je</code>, <code class="language-plaintext highlighter-rouge">jne</code>, <code class="language-plaintext highlighter-rouge">jz</code>, <code class="language-plaintext highlighter-rouge">jg</code>, <code class="language-plaintext highlighter-rouge">jge</code>, <code class="language-plaintext highlighter-rouge">jl</code>, <code class="language-plaintext highlighter-rouge">jle</code>
就是跳转的条件: equal, not equal… 看名字. 
(这里的坑就是这个比较是怎么比较的? 
感觉可以把这个指令用农民的方法来记: <code class="language-plaintext highlighter-rouge">if a je b then j</code>)</li>
        </ul>
      </li>
      <li>Call, Return <code class="language-plaintext highlighter-rouge">call &lt;LABEL&gt;</code> 
(和<code class="language-plaintext highlighter-rouge">jmp</code>区别是会记下出发的位置, 结束完调用call之后会回来)
<code class="language-plaintext highlighter-rouge">ret</code>就只是一个单独的命令, 把<code class="language-plaintext highlighter-rouge">eax</code>给返回</li>
    </ul>
  </li>
</ul>

<p>现在也不需要知道太多, 总之这么点应该够用了. 
(快点回归正轨. )</p>

<h2 id="gdb-的基本使用">GDB 的基本使用</h2>
<p>启动<code class="language-plaintext highlighter-rouge">gdb</code>, 很简单在终端里面输入<code class="language-plaintext highlighter-rouge">gdb</code>就好. 
不过, 如果说弹出来的一大堆文字让你觉得好像是报错信息而心烦意乱的话, 
试一试加上<code class="language-plaintext highlighter-rouge">-q</code>修饰符, 这样可以减少很多的介绍文字.</p>

<p>(<code class="language-plaintext highlighter-rouge">q</code> = quiet, 好的, 老外. )</p>

<p>举个例子(其中<code class="language-plaintext highlighter-rouge">t</code>是我用<code class="language-plaintext highlighter-rouge">gcc</code>编译的一段类似于<code class="language-plaintext highlighter-rouge">hello world</code>的代码)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>❰**|learn❱ gdb -q t  
Reading symbols from t...
(No debugging symbols found in t)
(gdb)
</code></pre></div></div>

<p>然后可以设置断点<code class="language-plaintext highlighter-rouge">break &lt;func&gt;</code>, 运行程序<code class="language-plaintext highlighter-rouge">run</code>, 
查看寄存器<code class="language-plaintext highlighter-rouge">info registers</code>, <code class="language-plaintext highlighter-rouge">info register &lt;name&gt;</code>, 
反汇编<code class="language-plaintext highlighter-rouge">disassemble &lt;func&gt;</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) break main
Breakpoint 1 at 0x77c
(gdb) run
Starting program: /**/**/**/learn/t

Breakpoint 1, 0x0000aaaaaaaaa77c in main ()
(gdb) info registers
x0             0xaaaaaaaaa830      187649984473136
x1             0xfffffffff608      281474976708104
x2             0xfffffffff618      281474976708120
x3             0xaaaaaaaaa76c      187649984472940
x4             0x0                 0
x5             0x7c51e727f47b8b78  8958195292608105336
x6             0xfffff7fc8608      281474842265096
x7             0x4004004100400000  4612812197511299072
x8             0xffffffffffffffff  -1
x9             0xf                 15
x10            0x80008             524296
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--
(gdb) info register pc
pc             0xaaaaaaaaa77c      0xaaaaaaaaa77c &lt;main+16&gt;
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000aaaaaaaaa76c &lt;+0&gt;:     stp     x29, x30, [sp, #-16]!
   0x0000aaaaaaaaa770 &lt;+4&gt;:     mov     x29, sp
   0x0000aaaaaaaaa774 &lt;+8&gt;:     adrp    x0, 0xaaaaaaaaa000
   0x0000aaaaaaaaa778 &lt;+12&gt;:    add     x0, x0, #0x830
=&gt; 0x0000aaaaaaaaa77c &lt;+16&gt;:    bl      0xaaaaaaaaa650 &lt;puts@plt&gt;
   0x0000aaaaaaaaa780 &lt;+20&gt;:    mov     w0, #0x0                        // #0
   0x0000aaaaaaaaa784 &lt;+24&gt;:    ldp     x29, x30, [sp], #16
   0x0000aaaaaaaaa788 &lt;+28&gt;:    ret
End of assembler dump.
</code></pre></div></div>

<p>(退出就是<code class="language-plaintext highlighter-rouge">quit</code>, 这个想必一定是有很多人英语比我好的. )</p>

<h3 id="利用gcc的--g-修饰符-让编译器保留额外的调试信息">利用GCC的 <code class="language-plaintext highlighter-rouge">-g</code> 修饰符, 让编译器保留额外的调试信息</h3>
<p>假如文件是这样的:</p>
<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I'm Groot.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>
<p>然后在编译的时候加上 <code class="language-plaintext highlighter-rouge">-g</code> 修饰符</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -g t.c -o t
</code></pre></div></div>

<p>(哎呀, 要考试了, 先鸽一下. 那就下次继续. :p)</p>

  </div><a class="u-url" href="/ctf/untitled(1)/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
