<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2026-01-29T08:28:25+00:00</updated><id>/feed.xml</id><title type="html">My Blog</title><subtitle>某不知名的很硬的双非学校的物理系学生的无聊博客</subtitle><entry><title type="html">并行处理</title><link href="/notes/parallel-programming/" rel="alternate" type="text/html" title="并行处理" /><published>2026-01-28T00:00:00+00:00</published><updated>2026-01-28T00:00:00+00:00</updated><id>/notes/parallel-programming</id><content type="html" xml:base="/notes/parallel-programming/"><![CDATA[<h1>About</h1>
<h1>复习用</h1>
<ol>
  <li>从上层应用出发的并行程序的两种通用模型是什么? 请列出并分别解释这两种模型.
    <ul>
      <li>数据并行 (Data Parallelism)
        <p>对不同数据子集执行相同操作, 强调任务的规整性</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">lparallel:pmapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;do-something</span><span class="w"> </span><span class="nv">data</span><span class="p">)</span>
</pre></div>
      </li>
      <li>任务并行 (Task Parallelism)
        <p>将不同的任务 (函数/逻辑) 分布在不同的核上执行</p>
<div class="highlight"><pre><span></span><span class="c1">;; gen-task -&gt; run-task</span>
<span class="p">(</span><span class="nf">flet</span><span class="w"> </span><span class="p">((</span><span class="nf">gen-task</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">dotimes</span><span class="w"> </span><span class="p">(</span><span class="nf">i</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">push-task</span><span class="w"> </span><span class="p">(</span><span class="o">...</span><span class="p">))))</span>
<span class="w">       </span><span class="p">(</span><span class="nf">run-task</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">task</span><span class="w"> </span><span class="nv">:=</span><span class="w"> </span><span class="p">(</span><span class="nf">pop-task</span><span class="p">)</span>
<span class="w">               </span><span class="nv">:while</span><span class="w"> </span><span class="nv">task</span><span class="w"> </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nf">funcall</span><span class="w"> </span><span class="nv">task</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">bt:make-thread</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;gen-task</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">bt:make-thread</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;run-task</span><span class="p">))</span>
</pre></div>
      </li>
    </ul>
  </li>
  <li>列出现代处理器并行执行的主要形式, 并分别解释.
    <ul>
      <li>指令级并行 (ILP): 流水线, 乱序执行, 多发射</li>
      <li>线程级并行 (TLP): 多核, 超线程同时执行多个线程</li>
      <li>数据级并行 (DLP): 向量寄存器和 SIMD 处理数据向量</li>
    </ul>
  </li>
  <li>分析多线程的收益和代价, 并举例吞吐导向的多线程代表架构.
    <ul>
      <li>收益: 隐藏长延迟 (访存), 提高吞吐量, 提升 CPU 利用率</li>
      <li>代价: 上下文切换开销, 同步与锁竞争, 缓存污染</li>
      <li>吞吐导向: GPU</li>
    </ul>
  </li>
  <li>Flynn 分类法是如何对并行分类的?
    <ul>
      <li>SISD (Single Instruction Single Data): 单指令单数据</li>
      <li>SIMD (Single Instruction Multiple Data): 单指令多数据</li>
      <li>MISD (Multiple Instruction Signle Data): 多指令单数据</li>
      <li>MIMD (Multiple Instruction Multiple Data): 多指令多数据</li>
    </ul>
  </li>
  <li>多核有哪几种通信方式?
    <ul>
      <li>共享储存 (Shared Memory):
        读写同一块内存进行隐式通信
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">counter</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1">;; &lt;- 共享内存 counter, 通过 lock 进行管理</span>
<span class="w">       </span><span class="p">(</span><span class="nf">lock</span><span class="w">    </span><span class="p">(</span><span class="nf">bt:make-lock</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">flet</span><span class="w"> </span><span class="p">((</span><span class="nf">count100</span><span class="w"> </span><span class="p">()</span>
<span class="w">           </span><span class="p">(</span><span class="nf">dotimes</span><span class="w"> </span><span class="p">(</span><span class="nf">i</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">bt:with-lock-held</span><span class="w"> </span><span class="p">(</span><span class="nf">lock</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">counter</span><span class="p">)))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">thread1</span><span class="w"> </span><span class="p">(</span><span class="nf">bt:make-thread</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;count100</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">thread2</span><span class="w"> </span><span class="p">(</span><span class="nf">bt:make-thread</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;count100</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">bt:join-thread</span><span class="w"> </span><span class="nv">thread1</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">bt:join-thread</span><span class="w"> </span><span class="nv">thread2</span><span class="p">)))</span>
<span class="w">  </span><span class="nv">counter</span><span class="p">)</span>
</pre></div>
        <pre class="example">
200
        </pre>
      </li>
      <li>消息传递 (Message passing):
        通过显式的 <code>send</code> 和 <code>receive</code> 操作在不同节点传输数据</li>
    </ul>
  </li>
  <li>列举减少访存延迟和隐藏访存延迟的方法.
    <ul>
      <li>减少访存延时: 提高 cache 命中率, 数据重用 (tiling), 非阻塞 cache</li>
      <li>隐藏访存延时: 硬件/软件预提取, 多线程上下文切换, 乱序执行</li>
    </ul>
  </li>
  <li>分析 SMP 和 NUMA 架构各自的特点.
    <ul>
      <li>SMP (Synmmetric Multi-Processing) 对称多处理
        <ul>
          <li>所有处理器地位平等, 共享同一个物理内存空间</li>
          <li>任何一个核访问内存中的任何一个地址的延迟和带宽相同</li>
          <li>总线连接: 所有的核通过共享总线连接到内存控制器</li>
          <li>核心数量增加的时候, 共享总线容易争抢</li>
        </ul>
      </li>
      <li>NUMA (Non-Uniform Memory Access) 非一致内存访问
        <ul>
          <li>物理内存被分散给不同节点, 每个节点通过几个 CPU 和部分本地内存组成</li>
          <li>本地访问快</li>
          <li>远端访问: 节点间通过互联网络访问其他节点的内存</li>
          <li>拓展性强, 但是需要避免远端访问</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>并行编程模型分别是哪三种, 并分别阐述三种模型各自的特点.
    <ul>
      <li>共享地址空间 (Shared Address Space)</li>
      <li>消息传递 (Message Passing)</li>
      <li>数据并行 (Data Parallelism)</li>
    </ul>
  </li>
  <li>请举一个常用的混合编程模型的例子? 其好处是什么?
    <p>混合编程: 节点间, 节点内, 计算单元内</p>
    <ul>
      <li>MPI 节点间拓展性, 分布式</li>
      <li>OpenMP 节点内多核内存共享</li>
      <li>CUDA 节点内部 GPU 核心</li>
    </ul>
  </li>
  <li>基于共享地址空间的通用同步原语有哪些? 具体进行解释.
    <ul>
      <li>互斥锁 (Locks/Mutex): 确保同一时间只有一个线程进入临界区</li>
      <li>屏障 (Barries): 强制所有线程在继续执行下一步前到达同一个点</li>
      <li>条件变量 (Condition Variables): 允许线程在满足特定条件前处于睡眠状态,
        由其他线程进行唤醒</li>
      <li>原子操作 (Atomics): 利用硬件支持 (Compare-and-Swap) 实现无锁小数据更新</li>
    </ul>
  </li>
  <li>在讨论局部性时会从哪两个维度上进行讨论, 两种局部性分别指的是什么,
    处理器的层次化存储利用了哪种局部性原理?
    <ul>
      <li>时间局部性: 最近访问过的数据很快会被再次访问</li>
      <li>空间局部性: 访问某个地址后, 相邻的地址很快会被访问</li>
      <li>Cache Block 主要利用了空间局限性</li>
    </ul>
  </li>
  <li>导致 cache miss 的原因是什么? 并分析如何避免/减少每种 cache miss?
    <table>
      <tr><th>原因</th><th>解释</th><th>对策</th></tr>
      <tr><td>强制缺失 (Compulsory)</td><td>首次访问</td><td>预取</td></tr>
      <tr><td>容量缺失 (Capacity)</td><td>cache 太小</td><td>增加容量, 循环展开</td></tr>
      <tr><td>冲突缺失 (Conflict)</td><td>映射位置冲突</td><td>组相关联程度, 调整数据排布</td></tr>
    </table>
  </li>
  <li>请列举出降低通信开销的几种方法.
    <ul>
      <li>减少通信频率</li>
      <li>重叠通信和计算 (非阻塞通信)</li>
      <li>提高局部性</li>
      <li>利用多播/广播</li>
    </ul>
  </li>
  <li>并行编程中, 造成竞争的原因有哪些, 如何减小竞争?
    <ul>
      <li>竞争: 同时访问共享资源 (Data Race, Lock Contention)</li>
      <li>减小方法:
        <ul>
          <li>细粒度锁: 将大锁拆分成多个保护小块数据的锁</li>
          <li>无锁编程: 原子指令或者读写锁</li>
          <li>数据私有化: 每个线程维护本地副本, 最后规约 (Reduction) (MapReduce)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>为了使工作负载更均衡, 在任务调度时可以采取哪些机制, 以及可能的困难.
    <ul>
      <li>机制
        <ul>
          <li>静态调度:
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">make-splited-task-thread</span><span class="w"> </span><span class="p">(</span><span class="nf">tasks</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">flet</span><span class="w"> </span><span class="p">((</span><span class="nf">make-thread</span><span class="w"> </span><span class="p">(</span><span class="nf">tasks</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">bt:make-thread</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">task</span><span class="w"> </span><span class="nv">tasks</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">funcall</span><span class="w"> </span><span class="nv">task</span><span class="p">))))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">threads</span><span class="w"> </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;make-thread</span><span class="w"> </span><span class="p">(</span><span class="nf">split-list</span><span class="w"> </span><span class="nv">tasks</span><span class="w"> </span><span class="nv">n</span><span class="p">))))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">barrier</span><span class="w"> </span><span class="nv">threads</span><span class="p">))))</span>
</pre></div>
          </li>
          <li>动态调度: 运行时按需取任务
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">make-fetch-and-eval-thread</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="nf">bt:make-thread</span>
<span class="w">   </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">fn</span><span class="w"> </span><span class="nv">:=</span><span class="w"> </span><span class="p">(</span><span class="nf">pop-task-pool</span><span class="p">)</span>
<span class="w">                    </span><span class="nv">:while</span><span class="w"> </span><span class="nv">fn</span><span class="w"> </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nf">funcall</span><span class="w"> </span><span class="nv">fn</span><span class="p">)))))</span>
</pre></div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>导致应用可扩展性差的因素有哪些? 并从中选出两个因素分析如何发现这种因素
    以及如何解决?
    <table>
      <tr><th>因素</th><th>表现</th><th>解决</th></tr>
      <tr><td>串行部分占比</td><td>增加核数但是加速比迅速饱和</td><td>算法重构</td></tr>
      <tr><td>通信开销</td><td>性能分析工具显示 CPU 在等待 I/O</td><td>增加计算密度, 异步通信</td></tr>
      <tr><td>负载不均衡</td><td>一核有难, 八核围观</td><td>动态任务调度, 细化任务粒度</td></tr>
      <tr><td>同步等待</td><td>线程阻塞在 Barrier 和 Lock 上, CPU 利用率波动大</td><td>减少全局同步点, 使用无锁数据结构, 缩小锁的粒度</td></tr>
      <tr><td>资源竞争</td><td>核数增加, 但是内存带宽和共享缓存达到饱和</td><td>优化数据局部性, 减少内存访问频率, 采用 NUMA 亲和性分配</td></tr>
    </table>
    <ul>
      <li>可拓展性</li>
      <li>Amdahl 定律: 整个系统的理论最大加速比受限于无法被并行化的串行部分
        <p>\[S = \frac{1}{(1 - s) + \frac{s}{n}}\]</p>
        <ul>
          <li>\(s\) 可以并行化的部分占比</li>
          <li>\(n\) 处理器的数量</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>请解释程序并行分析领域中的强可扩展性和弱可扩展性.
    <ul>
      <li>强课拓展性:
        总问题规模不变的情况下, 增加处理器数量可以等比缩短运行时间 (解决问题的速度)</li>
      <li>弱可拓展性:
        每个处理器承担的工作量不变, 增加处理器数量,
        观察运行事件是否保持恒定 (解决大问题的能力)</li>
    </ul>
  </li>
  <li>导致并行计算无法达到理想加速比的并行性能开销有哪些?
    <ul>
      <li>同步开销</li>
      <li>通信开销</li>
      <li>冗余计算</li>
      <li>调度开销</li>
    </ul>
  </li>
  <li>请画出 VGG 和 MobileNet 两个神经网络模型推理对应的 roofline 模型,
    并标出 VGG 和 MobileNet 在图中的位置.
    <p>Roofline 模型: 评估程序在特定硬件平台上性能瓶颈的可视化模型</p>
    <ul>
      <li>计算方法
        <p>\[\mathrm{Performance} = \mathrm{min} \left\{ \begin{matrix} \mathrm{Peak\ Floating\ Point\ Performance} &#92;&#92; \mathrm{Peak\ Memory\ Bandwidth} &times; \mathrm{Operation\ Intensity} \right.\]</p>
      </li>
      <li>绘制方法
        <p><b>Algorithm</b></p>
        <ol>
          <li>获得硬件性能:
            <ul>
              <li>峰值计算性能 \(P_{\mathrm{peak}}\)</li>
              <li>峰值内存带宽 \(B_{\mathrm{peak}}\)</li>
            </ul>
          </li>
          <li>绘制线
            <ul>
              <li>水平线 \(Y = P_{\mathrm{peak}}\)</li>
              <li>斜线: 过原点, 斜率为 \(B_{\mathrm{peak}}\) 的直线 (坐标轴通常为 log-log)</li>
              <li>水平线和斜线交点为拐点</li>
            </ul>
          </li>
          <li>绘制点
            <ul>
              <li>计算密度 \(I = \frac{\mathrm{FLOPs}}{\mathrm{Bytes}} =\) 浮点运算总数 / 内存交换总数</li>
              <li>实际性能 \(P = \frac{\mathrm{FLOPs}}{\mathrm{Seconds}} =\) 浮点计算总数 / 运行时间</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>特征及其意义
        <ul>
          <li>拐点 \(I_{\mathrm{crit}} = \frac{P_{\mathrm{peak}}}{B_{\mathrm{peak}}}\): 数值越大说明对算法计算密度要求越高</li>
          <li>点在斜线上: 访存受限</li>
          <li>点在水平线下: 计算受限</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>请简述并行程序 Benchmark 的选取原则是什么.
    <ul>
      <li>代表性: 覆盖典型应用场景</li>
      <li>多样性: 包含不同计算访存比 (Arithmetic Intensity) 任务</li>
      <li>可拓展性: 能支持单核到多核的测试</li>
      <li>可重复性: 结果稳定, 环境配置透明</li>
    </ul>
  </li>
  <li>SIMD 和 SIMT 架构分别有什么特点?
    <ul>
      <li>SIMD (Single Instruction Multiple Data)
        <ul>
          <li>硬件显示暴露向量寄存器</li>
          <li>显式打包数据</li>
        </ul>
      </li>
      <li>抽象层更高, 多个标量线程 Wrap 执行</li>
      <li>支持分支发散, 硬件处理掩码逻辑</li>
    </ul>
  </li>
  <li>简述线程分组的两种方式, 并分析动态线程分组的缺点.
    <ul>
      <li>静态分组</li>
      <li>动态分组</li>
    </ul>
  </li>
  <li>介绍一下 CUDA 编程中并发线程的层次结构以及 CUDA 对并行提供的支撑.
    <ul>
      <li>层次: Thread \(&rarr;\) Block \(&rarr;\) Grid</li>
      <li>硬件: 通过 Streaming Multiprocessors (SM) 执行</li>
      <li>存储: 提供 Shared Memory (Block 内共享)</li>
      <li>同步: 提供 <code>__syncthreads</code> 实现 Block 线程同步</li>
    </ul>
  </li>
  <li>请列举至少三种提高 CUDA 代码效率的方法.
    <ul>
      <li>合并访存 (Memory Coalescing): 保证 Warp 内线程访问连续全局内存地址</li>
      <li>共享内存 (Shared Memory): 减少对高延迟全局内存的访问</li>
      <li>减少分支发散 (Warp Divergence): 保证一个 Warp 内线程走相同的分支路径</li>
    </ul>
  </li>
  <li>列举 4 种常见的共享存储多处理器架构, 并分别解释.
    <ul>
      <li>UMA (Uniform Memory Access) 集中式共享内存</li>
      <li>NUMA (Non-Uniform Memory Access): 分布式共享内存</li>
      <li>COMA (Cache-Only Memory Architecture): 内存全部由 Cache 构成, 数据动态迁移</li>
      <li>ccNUMA (Cache-Coherent NUMA): 硬件缓存一致性协议的 NUMA</li>
    </ul>
  </li>
  <li>解释存储一致性模型、顺序一致性模型, 并各自给出一个实际的例子.
    <ul>
      <li>存储一致性: 规定了多个处理器对不同内存地址访问的合法顺序</li>
      <li>顺序一致性: 所有执行结果就像所有处理器的操作按某种顺序排成一个序列,
        且每个处理器的操作在序列中保持程序顺序</li>
    </ul>
  </li>
  <li>举例几种常见的互联拓扑结构, 并给出其网络直径, 对分带宽,
    饱和吞吐和平均跳步分析.
    <table>
      <tr><th>互联拓扑结构</th><th>网络直径</th><th>对分带宽</th><th>饱和吞吐</th><th>平均跳步</th></tr>
      <tr><td>Bus</td><td>\(1\)</td><td>\(1\)</td><td>\(1 / N\)</td><td>\(1\)</td></tr>
      <tr><td>Ring</td><td>\(N/2\)</td><td>\(2\)</td><td>\(8/N\) (双向)</td><td>\(N/4\)</td></tr>
      <tr><td>2D-Mesh</td><td>\(2 \sqrt{N}\)</td><td>\(\sqrt{N}\)</td><td>\(O(1 / \sqrt{N}\)</td><td>\(\frac{2}{3} \sqrt{N}\)</td></tr>
      <tr><td>Hypercube</td><td>\(\mathrm{log} N\)</td><td>\(N / 2\)</td><td>\(1/2\)</td><td>\(\frac{1}\mathrm{2} \mathrm{log}_{2} N\)</td></tr>
      <tr><td>Crossbar</td><td>\(1\)</td><td>\(N/2\)</td><td>\(1\)</td><td>\(1\)</td></tr>
    </table>
    <ul>
      <li>网络直径 (Network Diameter): 网络中连接两节点间最短路径的最大值
        (最坏情况下的消息延迟)</li>
      <li>对分带宽 (Bisection Bandwidth): 将网络分成两半时, 切断的最小链路数量
        (全模式通信时的瓶颈)</li>
      <li>饱和吞吐 (Saturated Throughput): 网络达到稳定状态时能处理的最大负载</li>
      <li>平均跳步 (Average Distance): 所有节点对之间最短路径的平均值
        (平均通信延迟)</li>
    </ul>
  </li>
  <li>论述互连网络中, 死锁出现的原因和避免的方法, 给出一种避免方法的示例.
    <ul>
      <li>原因: 环路等待</li>
      <li>避免方法
        <ul>
          <li>维序路由 (Dimension Order Routing):
            规定数据包必须先沿 X 轴走, 再沿 Y 轴走, 打破环路</li>
          <li>虚通道 (Virtual Channels): 通过逻辑上的缓冲区拆分来消除循环依赖</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>片上网络的流控按粒度划分可以分为哪几类, 并分别介绍一种对应的流控技术.
    <ul>
      <li>消息级 (Message): 整个消息作为单位</li>
      <li>包级 (Packet): 存储转发 (Store-and-Forward)</li>
      <li>切片级 (Flit): 虫蚀流控 (Wormhole Routing)
        小切片头带路，后续紧跟，减少延迟且节省缓冲区</li>
    </ul>
  </li>
  <li>列举常用的利用空间局部性的方法.
    <ul>
      <li>更大的 Cache Block: 一次性存取相邻数据</li>
      <li>数据对齐: 确保结构体对齐, 减少跨行访问</li>
      <li>数据合并: 根据访问模式选择储存布局</li>
      <li>数据预取: 提前将相邻数据加载进缓存</li>
    </ul>
  </li>
  <li>列举事务性内存的优势.
    <ul>
      <li>编程建但</li>
      <li>避免死锁</li>
      <li>组合</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="notes" /><summary type="html"><![CDATA[About 复习用 从上层应用出发的并行程序的两种通用模型是什么? 请列出并分别解释这两种模型. 数据并行 (Data Parallelism) 对不同数据子集执行相同操作, 强调任务的规整性 (lparallel:pmapcar #&#39;do-something data) 任务并行 (Task Parallelism) 将不同的任务 (函数/逻辑) 分布在不同的核上执行 ;; gen-task -&gt; run-task (flet ((gen-task (n) (dotimes (i n) (push-task (...)))) (run-task (n) (loop :for task := (pop-task) :while task :do (funcall task)))) (bt:make-thread #&#39;gen-task) (bt:make-thread #&#39;run-task)) 列出现代处理器并行执行的主要形式, 并分别解释. 指令级并行 (ILP): 流水线, 乱序执行, 多发射 线程级并行 (TLP): 多核, 超线程同时执行多个线程 数据级并行 (DLP): 向量寄存器和 SIMD 处理数据向量 分析多线程的收益和代价, 并举例吞吐导向的多线程代表架构. 收益: 隐藏长延迟 (访存), 提高吞吐量, 提升 CPU 利用率 代价: 上下文切换开销, 同步与锁竞争, 缓存污染 吞吐导向: GPU Flynn 分类法是如何对并行分类的? SISD (Single Instruction Single Data): 单指令单数据 SIMD (Single Instruction Multiple Data): 单指令多数据 MISD (Multiple Instruction Signle Data): 多指令单数据 MIMD (Multiple Instruction Multiple Data): 多指令多数据 多核有哪几种通信方式? 共享储存 (Shared Memory): 读写同一块内存进行隐式通信 (let* ((counter 0) ;; &lt;- 共享内存 counter, 通过 lock 进行管理 (lock (bt:make-lock))) (flet ((count100 () (dotimes (i 100) (bt:with-lock-held (lock) (incf counter))))) (let ((thread1 (bt:make-thread #&#39;count100)) (thread2 (bt:make-thread #&#39;count100))) (bt:join-thread thread1) (bt:join-thread thread2))) counter) 200 消息传递 (Message passing): 通过显式的 send 和 receive 操作在不同节点传输数据 列举减少访存延迟和隐藏访存延迟的方法. 减少访存延时: 提高 cache 命中率, 数据重用 (tiling), 非阻塞 cache 隐藏访存延时: 硬件/软件预提取, 多线程上下文切换, 乱序执行 分析 SMP 和 NUMA 架构各自的特点. SMP (Synmmetric Multi-Processing) 对称多处理 所有处理器地位平等, 共享同一个物理内存空间 任何一个核访问内存中的任何一个地址的延迟和带宽相同 总线连接: 所有的核通过共享总线连接到内存控制器 核心数量增加的时候, 共享总线容易争抢 NUMA (Non-Uniform Memory Access) 非一致内存访问 物理内存被分散给不同节点, 每个节点通过几个 CPU 和部分本地内存组成 本地访问快 远端访问: 节点间通过互联网络访问其他节点的内存 拓展性强, 但是需要避免远端访问 并行编程模型分别是哪三种, 并分别阐述三种模型各自的特点. 共享地址空间 (Shared Address Space) 消息传递 (Message Passing) 数据并行 (Data Parallelism) 请举一个常用的混合编程模型的例子? 其好处是什么? 混合编程: 节点间, 节点内, 计算单元内 MPI 节点间拓展性, 分布式 OpenMP 节点内多核内存共享 CUDA 节点内部 GPU 核心 基于共享地址空间的通用同步原语有哪些? 具体进行解释. 互斥锁 (Locks/Mutex): 确保同一时间只有一个线程进入临界区 屏障 (Barries): 强制所有线程在继续执行下一步前到达同一个点 条件变量 (Condition Variables): 允许线程在满足特定条件前处于睡眠状态, 由其他线程进行唤醒 原子操作 (Atomics): 利用硬件支持 (Compare-and-Swap) 实现无锁小数据更新 在讨论局部性时会从哪两个维度上进行讨论, 两种局部性分别指的是什么, 处理器的层次化存储利用了哪种局部性原理? 时间局部性: 最近访问过的数据很快会被再次访问 空间局部性: 访问某个地址后, 相邻的地址很快会被访问 Cache Block 主要利用了空间局限性 导致 cache miss 的原因是什么? 并分析如何避免/减少每种 cache miss? 原因解释对策 强制缺失 (Compulsory)首次访问预取 容量缺失 (Capacity)cache 太小增加容量, 循环展开 冲突缺失 (Conflict)映射位置冲突组相关联程度, 调整数据排布 请列举出降低通信开销的几种方法. 减少通信频率 重叠通信和计算 (非阻塞通信) 提高局部性 利用多播/广播 并行编程中, 造成竞争的原因有哪些, 如何减小竞争? 竞争: 同时访问共享资源 (Data Race, Lock Contention) 减小方法: 细粒度锁: 将大锁拆分成多个保护小块数据的锁 无锁编程: 原子指令或者读写锁 数据私有化: 每个线程维护本地副本, 最后规约 (Reduction) (MapReduce) 为了使工作负载更均衡, 在任务调度时可以采取哪些机制, 以及可能的困难. 机制 静态调度: (defun make-splited-task-thread (tasks &amp;optional (n 3)) (flet ((make-thread (tasks) (bt:make-thread (lambda () (dolist (task tasks) (funcall task)))))) (let ((threads (mapcar #&#39;make-thread (split-list tasks n)))) (barrier threads)))) 动态调度: 运行时按需取任务 (defun make-fetch-and-eval-thread () (bt:make-thread (lambda () (loop :for fn := (pop-task-pool) :while fn :do (funcall fn))))) 导致应用可扩展性差的因素有哪些? 并从中选出两个因素分析如何发现这种因素 以及如何解决? 因素表现解决 串行部分占比增加核数但是加速比迅速饱和算法重构 通信开销性能分析工具显示 CPU 在等待 I/O增加计算密度, 异步通信 负载不均衡一核有难, 八核围观动态任务调度, 细化任务粒度 同步等待线程阻塞在 Barrier 和 Lock 上, CPU 利用率波动大减少全局同步点, 使用无锁数据结构, 缩小锁的粒度 资源竞争核数增加, 但是内存带宽和共享缓存达到饱和优化数据局部性, 减少内存访问频率, 采用 NUMA 亲和性分配 可拓展性 Amdahl 定律: 整个系统的理论最大加速比受限于无法被并行化的串行部分 \[S = \frac{1}{(1 - s) + \frac{s}{n}}\] \(s\) 可以并行化的部分占比 \(n\) 处理器的数量 请解释程序并行分析领域中的强可扩展性和弱可扩展性. 强课拓展性: 总问题规模不变的情况下, 增加处理器数量可以等比缩短运行时间 (解决问题的速度) 弱可拓展性: 每个处理器承担的工作量不变, 增加处理器数量, 观察运行事件是否保持恒定 (解决大问题的能力) 导致并行计算无法达到理想加速比的并行性能开销有哪些? 同步开销 通信开销 冗余计算 调度开销 请画出 VGG 和 MobileNet 两个神经网络模型推理对应的 roofline 模型, 并标出 VGG 和 MobileNet 在图中的位置. Roofline 模型: 评估程序在特定硬件平台上性能瓶颈的可视化模型 计算方法 \[\mathrm{Performance} = \mathrm{min} \left\{ \begin{matrix} \mathrm{Peak\ Floating\ Point\ Performance} &#92;&#92; \mathrm{Peak\ Memory\ Bandwidth} &times; \mathrm{Operation\ Intensity} \right.\] 绘制方法 Algorithm 获得硬件性能: 峰值计算性能 \(P_{\mathrm{peak}}\) 峰值内存带宽 \(B_{\mathrm{peak}}\) 绘制线 水平线 \(Y = P_{\mathrm{peak}}\) 斜线: 过原点, 斜率为 \(B_{\mathrm{peak}}\) 的直线 (坐标轴通常为 log-log) 水平线和斜线交点为拐点 绘制点 计算密度 \(I = \frac{\mathrm{FLOPs}}{\mathrm{Bytes}} =\) 浮点运算总数 / 内存交换总数 实际性能 \(P = \frac{\mathrm{FLOPs}}{\mathrm{Seconds}} =\) 浮点计算总数 / 运行时间 特征及其意义 拐点 \(I_{\mathrm{crit}} = \frac{P_{\mathrm{peak}}}{B_{\mathrm{peak}}}\): 数值越大说明对算法计算密度要求越高 点在斜线上: 访存受限 点在水平线下: 计算受限 请简述并行程序 Benchmark 的选取原则是什么. 代表性: 覆盖典型应用场景 多样性: 包含不同计算访存比 (Arithmetic Intensity) 任务 可拓展性: 能支持单核到多核的测试 可重复性: 结果稳定, 环境配置透明 SIMD 和 SIMT 架构分别有什么特点? SIMD (Single Instruction Multiple Data) 硬件显示暴露向量寄存器 显式打包数据 抽象层更高, 多个标量线程 Wrap 执行 支持分支发散, 硬件处理掩码逻辑 简述线程分组的两种方式, 并分析动态线程分组的缺点. 静态分组 动态分组 介绍一下 CUDA 编程中并发线程的层次结构以及 CUDA 对并行提供的支撑. 层次: Thread \(&rarr;\) Block \(&rarr;\) Grid 硬件: 通过 Streaming Multiprocessors (SM) 执行 存储: 提供 Shared Memory (Block 内共享) 同步: 提供 __syncthreads 实现 Block 线程同步 请列举至少三种提高 CUDA 代码效率的方法. 合并访存 (Memory Coalescing): 保证 Warp 内线程访问连续全局内存地址 共享内存 (Shared Memory): 减少对高延迟全局内存的访问 减少分支发散 (Warp Divergence): 保证一个 Warp 内线程走相同的分支路径 列举 4 种常见的共享存储多处理器架构, 并分别解释. UMA (Uniform Memory Access) 集中式共享内存 NUMA (Non-Uniform Memory Access): 分布式共享内存 COMA (Cache-Only Memory Architecture): 内存全部由 Cache 构成, 数据动态迁移 ccNUMA (Cache-Coherent NUMA): 硬件缓存一致性协议的 NUMA 解释存储一致性模型、顺序一致性模型, 并各自给出一个实际的例子. 存储一致性: 规定了多个处理器对不同内存地址访问的合法顺序 顺序一致性: 所有执行结果就像所有处理器的操作按某种顺序排成一个序列, 且每个处理器的操作在序列中保持程序顺序 举例几种常见的互联拓扑结构, 并给出其网络直径, 对分带宽, 饱和吞吐和平均跳步分析. 互联拓扑结构网络直径对分带宽饱和吞吐平均跳步 Bus\(1\)\(1\)\(1 / N\)\(1\) Ring\(N/2\)\(2\)\(8/N\) (双向)\(N/4\) 2D-Mesh\(2 \sqrt{N}\)\(\sqrt{N}\)\(O(1 / \sqrt{N}\)\(\frac{2}{3} \sqrt{N}\) Hypercube\(\mathrm{log} N\)\(N / 2\)\(1/2\)\(\frac{1}\mathrm{2} \mathrm{log}_{2} N\) Crossbar\(1\)\(N/2\)\(1\)\(1\) 网络直径 (Network Diameter): 网络中连接两节点间最短路径的最大值 (最坏情况下的消息延迟) 对分带宽 (Bisection Bandwidth): 将网络分成两半时, 切断的最小链路数量 (全模式通信时的瓶颈) 饱和吞吐 (Saturated Throughput): 网络达到稳定状态时能处理的最大负载 平均跳步 (Average Distance): 所有节点对之间最短路径的平均值 (平均通信延迟) 论述互连网络中, 死锁出现的原因和避免的方法, 给出一种避免方法的示例. 原因: 环路等待 避免方法 维序路由 (Dimension Order Routing): 规定数据包必须先沿 X 轴走, 再沿 Y 轴走, 打破环路 虚通道 (Virtual Channels): 通过逻辑上的缓冲区拆分来消除循环依赖 片上网络的流控按粒度划分可以分为哪几类, 并分别介绍一种对应的流控技术. 消息级 (Message): 整个消息作为单位 包级 (Packet): 存储转发 (Store-and-Forward) 切片级 (Flit): 虫蚀流控 (Wormhole Routing) 小切片头带路，后续紧跟，减少延迟且节省缓冲区 列举常用的利用空间局部性的方法. 更大的 Cache Block: 一次性存取相邻数据 数据对齐: 确保结构体对齐, 减少跨行访问 数据合并: 根据访问模式选择储存布局 数据预取: 提前将相邻数据加载进缓存 列举事务性内存的优势. 编程建但 避免死锁 组合]]></summary></entry><entry><title type="html">粒子物理</title><link href="/notes/particles/" rel="alternate" type="text/html" title="粒子物理" /><published>2026-01-25T00:00:00+00:00</published><updated>2026-01-25T00:00:00+00:00</updated><id>/notes/particles</id><content type="html" xml:base="/notes/particles/"><![CDATA[<h1>About</h1>
<p>完全没学明白的课&#8230; 和我做的重叠有点少&#8230; 也听不懂.
  所以我觉得 AI 真是好用呢.</p>
<h1>自然单位制</h1>
<table>
  <tr><th>物理量</th><th>说明</th></tr>
  <tr><td>光速 \(c = 1\)</td><td></td></tr>
  <tr><td>\(\hbar = 1\)</td><td></td></tr>
  <tr><td>\(k = 1\)</td><td></td></tr>
</table>
<p>目标是只剩下 eV (电子伏特) 一个单位</p>
<ul>
  <li>\(\hbar c = 197 \mathrm{MeV}\ \mathrm{fm}\)</li>
  <li>\(1 \mathrm{MeV}^{-1} = 6.582 &times; 10^{-22}\ \mathrm{s}\)</li>
</ul>
<h1>粒子基本性质</h1>
<ul>
  <li>质量 \(E^{2} - p^{2} = m_{0}^{2}, E &gt; 0\) (洛伦兹不变量)</li>
  <li>宽度寿命
    <ul>
      <li>衰变宽度 \(&Gamma;\) 为平均寿命 \(&tau;\) 的倒数, 即 \(&tau; = \frac{1}{&Gamma;}\)</li>
      <li>\(N(t) = N_{0} \mathrm{e}^{-t/&tau;}\)</li>
      <li>不稳定粒子衰变到某几个衰变道的概率 \(P(A &rarr; f_{i}) = &Gamma;_{i} / &Gamma;\)</li>
    </ul>
  <details><summary>Application</summary>
    <ul>
      <li>通过衰变宽度计算平均寿命
        <blockquote>
          <p>顶夸克的衰变宽度是 \(1.42\ \mathrm{GeV}\), 试计算其静止坐标系的平均寿命.</p>
        </blockquote>
        <p>\[&tau; = \frac{1}{&Gamma;} = \frac{1}{1.42} \mathrm{GeV}^{-1}\]</p>
      </li>
      <li>利用径迹长度测寿命 \(L = &tau; v / \sqrt{1 - v^{2}}\)
        <blockquote>
          <p>\(1\ \mathrm{GeV}\) \(&mu;\) 在衰变前的平均径迹长度</p>
        </blockquote>
        <p>\[L = \frac{p}{m} &tau;\]</p>
      </li>
    </ul>
  </details>
  </li>
  <li>电荷</li>
  <li>自旋 \(S\)
    <ul>
      <li>费米子 (自旋为半整数的粒子 \(1/2, 3/2, \cdots\))</li>
      <li>玻色子 (自旋为整数的粒子 \(0, 1, 2, \cdots\))</li>
    </ul>
  </li>
  <li>角动量</li>
  <li>螺旋度: 自旋角动量在运动方向上的投影</li>
  <li>相互作用媒介子
    <ul>
      <li>规范玻色子
        <ul>
          <li>传递相互作用的媒介粒子: 光子, \(W^{&plusmn;}, Z\) 玻色子和 8 种胶子,</li>
          <li>自旋为 1</li>
          <li>一共有 1+3+8=12 个规范玻色子</li>
        </ul>
      </li>
      <li>费米子
        <ul>
          <li>轻子和夸克</li>
          <li>自旋为 1/2</li>
        </ul>
      </li>
      <li>希格斯粒子
        <ul>
          <li>自旋为 0 的标量粒子</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>同位旋 (Isospin)
    <ul>
      <li>强相互作用下的守恒量, 所有强子都具有确定的同位旋</li>
      <li>电磁相互作用中, 同位旋对称性破坏, \(&#124;\Delta I&#124; = 0, 1\)</li>
    </ul>
  </li>
  <li>奇异数 (Strangeness Number)
    <ul>
      <li>强相互作用和电磁相互作用中都守恒</li>
      <li>强子的盖尔曼-西岛关系
        <p>\[Q = I_{3} + \frac{Y}{2},\ Y = b + S\]</p>
      </li>
    </ul>
  </li>
  <li>重子数 (Baryon Number)</li>
  <li>轻子数 (Lepton Number)</li>
  <li>\(J^{PC}\)
    <table>
      <tr><th>粒子</th><th>\(J^{PC}\)</th><th>性质分类</th></tr>
      <tr><td>\(&pi;, K, &eta;\)</td><td>\(0^{-+}\)</td><td>赝标量介子</td></tr>
      <tr><td>\(&rho;, &omega;, &phi;, J/&psi;, &Gamma;\)</td><td>\(1^{&#8211;}\)</td><td>矢量介子</td></tr>
      <tr><td>\(p, n\)</td><td>\(1/2^{+}\)</td><td>重子</td></tr>
      <tr><td>\(&Delta;\)</td><td>\(3/2^{+}\)</td><td>重子激发态</td></tr>
    </table>
  </li>
</ul>
<details><summary>Application</summary>
<ul>
  <li>反应截面
    <ul>
      <li>反应截面 \(1\ \mathrm{GeV}^{-2} = 0.389\ \mathrm{mb}\)</li>
    </ul>
  </li>
  <li>反应是否能够发生
    <ul>
      <li>\(&pi;^{0} &rarr; e^{+} e^{-}\)</li>
    </ul>
  </li>
</ul>
</details>
<details><summary>常见粒子属性</summary>
<table>
  <tr><th>粒子</th><th>电荷</th><th>质量</th><th>自旋</th><th>同位旋</th><th>奇异数</th><th>重子数</th><th>轻子数</th><th>宇称 \(J^{PC}\)</th></tr>
  <tr><td>光子</td><td>0</td><td>\(&lt; 1 &times; 10^{-18} \mathrm{eV}\)</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>\(1^{&#8211;}\)</td></tr>
  <tr><td>电子</td><td>-1</td><td>\(0.511 \mathrm{MeV}\)</td><td>1/2</td><td>0</td><td>0</td><td>0</td><td>1</td><td></td></tr>
  <tr><td>\(&mu;\) 子</td><td>-1</td><td>\(105.7 \mathrm{MeV}\)</td><td>1/2</td><td>0</td><td>0</td><td>0</td><td>1</td><td></td></tr>
  <tr><td>\(&pi;\) 介子</td><td></td><td>\(140 \mathrm{MeV}\)</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>\(0^{-+}\)</td></tr>
  <tr><td>质子 (\(n\))</td><td></td><td>\(938 \mathrm{MeV}\)</td><td>1/2</td><td>1/2</td><td>0</td><td>1</td><td>0</td><td></td></tr>
  <tr><td>顶夸克 (\(t\))</td><td></td><td>\(173 \mathrm{GeV}\)</td><td>1/2</td><td>0</td><td>0</td><td>1/3</td><td>0</td><td></td></tr>
  <tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<p><b>Memonic</b></p>
<ul>
  <li>轻子</li>
  <li>重子</li>
</ul>
</details>
<h1>运动学变换</h1>
<h2>洛伦兹变换</h2>
<ul>
  <li>洛伦兹不变量
    <p>\[\left(\begin{matrix}E' &#92;&#92; p_{x}' &#92;&#92; p_{y}' &#92;&#92; p_{z}' \end{matrix}\right) = \left(\begin{matrix}&gamma; &amp; - v &gamma; &amp; 0 &amp; 0 &#92;&#92; - v &gamma; &amp; &gamma; &amp; 0 &amp; 0 &#92;&#92; 0 &amp; 0 &amp; 1 &amp; 0 &#92;&#92; 0 &amp; 0 &amp; 0 &amp; 1 \end{matrix}\right) \left(\begin{matrix} E &#92;&#92; p_{x} &#92;&#92; p_{y} &#92;&#92; p_{z} \end{matrix}\right)\]</p>
  </li>
  <li>速度关系
    <p>\[v = p / E = \frac{\sqrt{E^{2} - m_{0}^{2}}}{E}\]</p>
  </li>
  <li>多粒子系统不变量
    <p>\[\left( &sum;_{i} E_{i} \right)^{2} - \left( &sum;_{i} p_{i} \right)^{2} = \mathrm{constant}\]</p>
  <details><summary>Application</summary>
    <ul>
      <li>两粒子碰撞质心坐标系
        <ul>
          <li>对撞质心系能量 \(E_{\mathrm{cm}}^{2} = 4 E_{1} E_{2}\)</li>
          <li>固定靶质心系能量 \(E_{1}' = \frac{2 E_{1}^{2}}{m_{2}}\)</li>
        </ul>
      </li>
      <li>两粒子碎裂
        <blockquote>
          <p>\(&pi;^{0} &rarr; 2 &gamma;\), 两个末态光子的能量 \(E_{1}\) 和 \(E_{2}\):</p>
        </blockquote>
        <ul>
          <li>飞行夹角为 \(cos &theta; = 1 - \frac{m_{&pi;^{0}}^{2}}{2 E_{1} E_{2}}\)</li>
          <li>最大张角和最小张角</li>
        </ul>
      </li>
      <li>散射和微分截面
        <ul>
          <li>\(D(&theta;) = \frac{\mathrm{d}&sigma;}{\mathrm{d}&Omega;} = \left( \frac{Z e}{4 E sin^{2} (&theta;/2)} \right)^{2}\)</li>
          <li>总截面为分截面的和 \(&sigma;_{\mathrm{tot}} = &sum;_{i} &sigma;_{i}\)</li>
          <li>反应黄金规则 \(W = 2 &pi; \left| M_{if} \right|^{2} &rho;_{f}\)</li>
        </ul>
      </li>
      <li>微分截面洛伦兹变换
        <p>\[D(&theta;) = \frac{\mathrm{d}&sigma;}{\mathrm{d}&Omega;} = \frac{\left| \boldsymbol{p} \right|^{3}}{&gamma;_{c} \left| \boldsymbol{p}' \right|^{3} \left( 1 + \frac{v_{c}}{v'} cos &theta;' \right) } \left( \frac{\mathrm{d}&sigma;}{\mathrm{d}&Omega;} \right)'\]</p>
      </li>
      <li>末态相空间</li>
      <li>散射能量计算
        <p><b>Algorithm</b></p>
        <ol>
          <li>计算质心系洛伦兹不变量 \(s^{2}\) (往往质心系中 \(p = 0\) 容易计算)</li>
          <li>末态能量 \(E_{1} = \frac{s^{2} + M_{1}^{2} - M_{2}^{2}}{2 s}\)</li>
        </ol>
      </li>
    </ul>
  </details>
  </li>
</ul>
<h2>反应阈能</h2>
<h1>Feynman 图</h1>
<h2>费曼规则</h2>
<ol>
  <li>时间轴从左到右</li>
  <li>外线 (初态和末态)
    <ul>
      <li>初态 \(\left\{ \mathrm{PARTICLE}_{\mathrm{i}} \right\} &rarr; \left\{ \mathrm{PARTICLE}_{\mathrm{f}} \right\}\) 末态</li>
      <li>初态和末态的粒子作为外线</li>
      <li>实线表示夸克和轻子</li>
      <li>波浪线表示入射矢量玻色子</li>
      <li>带箭头的实线表示费米子场</li>
      <li>虚线 Higgs 粒子</li>
    </ul>
  </li>
  <li>内线 (传播子)
    <ul>
      <li>连线: 相互作用
        <ul>
          <li>电磁相互作用: \(&gamma;\) (波浪线)</li>
          <li>s-通道: 初态粒子合并成一个中介, 再分裂</li>
          <li>t-通道: 初态粒子交换一个中介, 各自飞走</li>
          <li>强相互作用: 螺旋线 (胶子 \(g\))</li>
          <li>弱相互作用: 波浪线 \(W^{&plusmn;}\) 标注电荷流向</li>
        </ul>
      </li>
      <li>顶点: 守恒律
        <ul>
          <li>电荷守恒 (进=出)</li>
          <li>味守恒 (强力和电磁力不改变粒子的味道)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>费米子线沿箭头方向连续不间断</li>
</ol>
<h1>基本相互作用</h1>
<table>
  <tr><th>相互作用</th><th>强度</th><th>力程</th><th>媒介子</th><th>参与作用粒子</th><th>束缚态例子</th></tr>
  <tr><td>强相互作用</td><td>\(&alpha;_{s} &sim; 1\)</td><td>\(10^{-15}\ \mathrm{m}\)</td><td>胶子</td><td>夸克, 胶子</td><td>强子</td></tr>
  <tr><td>电磁作用</td><td>\(&alpha; = 1/137\)</td><td>\(F \propto 1/r^{2}\)</td><td>光子</td><td>带电粒子</td><td>原子, 分子</td></tr>
  <tr><td>弱相互作用</td><td>\(10^{-5}\)</td><td>\(&lt; 10^{-17}\ \mathrm{m}\)</td><td>\(W^{&plusmn;}, Z^{0}\)</td><td>夸克, 轻子</td><td>无</td></tr>
  <tr><td>引力</td><td>\(10^{-39}\)</td><td>\(F \propto 1/r^{2}\)</td><td>引力子</td><td>所有粒子</td><td></td></tr>
</table>
<h1>对称性和守恒量</h1>
<h2>守恒量计算</h2>
<h2>守恒律</h2>
<h1>强子与量子电动力学</h1>
<h2>强子</h2>
<ul>
  <li>介子: \(&pi;, K, &eta;, &eta;', &rho;, K^{*}, &omega;, &phi;, D, J/&psi;, \cdots\)</li>
  <li>重子: \(p, n, &Lambda;, &Sigma;, &Xi;, &Delta;, &Omega;, \cdots\)</li>
  <li>不能通过强相互作用衰变的粒子称为稳定粒子</li>
  <li>可以通过强相互作用衰变的粒子称为共振态</li>
  <li>汤川耦合与 \(&pi;\) 介子</li>
</ul>
<h2>轻子</h2>
<ul>
  <li>轻子: \(e^{-}, &nu;_{e}, &mu;^{-}, &nu;_{&mu;}, &tau;^{-}, &nu;_{&tau;}\)</li>
</ul>
<h2>OZI 规则</h2>
<ul>
  <li>描述: 在强子反应过程中, 如果价夸克的的费曼图被断成互不相连的两部分,
    则该过程的反应几率被大大压低</li>
  <li>解释: 胶子带颜色, 介子不带, 故单个胶子不能连接湮灭图,
    故衰变至少需要三个胶子参与, 所以是高阶图, 量级小</li>
</ul>
<h1>电弱统一理论与标准模型</h1>
<h2>标准模型</h2>
<ul>
  <li>标准模型: 电弱统一理论+量子色动力学
    <ul>
      <li>粒子对应场 (场是物质存在的基本形式)</li>
      <li>场用复数量描述</li>
      <li>场的基态是能量最低的状态</li>
      <li>粒子的衰变</li>
      <li>相互作用通过场 (粒子) 来传递</li>
    </ul>
  </li>
</ul>
<h2>中微子振荡</h2>
<ul>
  <li>t 时刻出现缪子中微子和电子中微子的概率
    <p>\[P_{e&mu;} = sin^{2} (2 &theta;) sin^{2} \left( \frac{&Delta; m^{2} t}{4 E} \right)\]</p>
    <p>\[P_{ee} = 1 - P_{e&mu;}\]</p>
    <p>故可以通过 \(&Delta; m^{2} = \frac{4 E}{L} \mathrm{arcsin} \sqrt{1 - P_{ee}}\) 估算.</p>
  </li>
</ul>
<h2>电弱统一与 Higgs</h2>
<ul>
  <li>Higgs 机制的作用
    <ul>
      <li>赋予 W, Z 玻色子质量, 保持光子无质量</li>
      <li>赋予费米子质量, 联系 Yukawa 耦合</li>
    </ul>
  </li>
  <li>Higgs 玻色子产生机制:
    <ul>
      <li>强子对撞机上单个 Higgs: 胶子聚变</li>
      <li>正负电子对撞机: Higgs 韧致辐射</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="notes" /><summary type="html"><![CDATA[About 完全没学明白的课&#8230; 和我做的重叠有点少&#8230; 也听不懂. 所以我觉得 AI 真是好用呢. 自然单位制 物理量说明 光速 \(c = 1\) \(\hbar = 1\) \(k = 1\) 目标是只剩下 eV (电子伏特) 一个单位 \(\hbar c = 197 \mathrm{MeV}\ \mathrm{fm}\) \(1 \mathrm{MeV}^{-1} = 6.582 &times; 10^{-22}\ \mathrm{s}\) 粒子基本性质 质量 \(E^{2} - p^{2} = m_{0}^{2}, E &gt; 0\) (洛伦兹不变量) 宽度寿命 衰变宽度 \(&Gamma;\) 为平均寿命 \(&tau;\) 的倒数, 即 \(&tau; = \frac{1}{&Gamma;}\) \(N(t) = N_{0} \mathrm{e}^{-t/&tau;}\) 不稳定粒子衰变到某几个衰变道的概率 \(P(A &rarr; f_{i}) = &Gamma;_{i} / &Gamma;\) Application 通过衰变宽度计算平均寿命 顶夸克的衰变宽度是 \(1.42\ \mathrm{GeV}\), 试计算其静止坐标系的平均寿命. \[&tau; = \frac{1}{&Gamma;} = \frac{1}{1.42} \mathrm{GeV}^{-1}\] 利用径迹长度测寿命 \(L = &tau; v / \sqrt{1 - v^{2}}\) \(1\ \mathrm{GeV}\) \(&mu;\) 在衰变前的平均径迹长度 \[L = \frac{p}{m} &tau;\] 电荷 自旋 \(S\) 费米子 (自旋为半整数的粒子 \(1/2, 3/2, \cdots\)) 玻色子 (自旋为整数的粒子 \(0, 1, 2, \cdots\)) 角动量 螺旋度: 自旋角动量在运动方向上的投影 相互作用媒介子 规范玻色子 传递相互作用的媒介粒子: 光子, \(W^{&plusmn;}, Z\) 玻色子和 8 种胶子, 自旋为 1 一共有 1+3+8=12 个规范玻色子 费米子 轻子和夸克 自旋为 1/2 希格斯粒子 自旋为 0 的标量粒子 同位旋 (Isospin) 强相互作用下的守恒量, 所有强子都具有确定的同位旋 电磁相互作用中, 同位旋对称性破坏, \(&#124;\Delta I&#124; = 0, 1\) 奇异数 (Strangeness Number) 强相互作用和电磁相互作用中都守恒 强子的盖尔曼-西岛关系 \[Q = I_{3} + \frac{Y}{2},\ Y = b + S\] 重子数 (Baryon Number) 轻子数 (Lepton Number) \(J^{PC}\) 粒子\(J^{PC}\)性质分类 \(&pi;, K, &eta;\)\(0^{-+}\)赝标量介子 \(&rho;, &omega;, &phi;, J/&psi;, &Gamma;\)\(1^{&#8211;}\)矢量介子 \(p, n\)\(1/2^{+}\)重子 \(&Delta;\)\(3/2^{+}\)重子激发态 Application 反应截面 反应截面 \(1\ \mathrm{GeV}^{-2} = 0.389\ \mathrm{mb}\) 反应是否能够发生 \(&pi;^{0} &rarr; e^{+} e^{-}\) 常见粒子属性 粒子电荷质量自旋同位旋奇异数重子数轻子数宇称 \(J^{PC}\) 光子0\(&lt; 1 &times; 10^{-18} \mathrm{eV}\)10000\(1^{&#8211;}\) 电子-1\(0.511 \mathrm{MeV}\)1/20001 \(&mu;\) 子-1\(105.7 \mathrm{MeV}\)1/20001 \(&pi;\) 介子\(140 \mathrm{MeV}\)01000\(0^{-+}\) 质子 (\(n\))\(938 \mathrm{MeV}\)1/21/2010 顶夸克 (\(t\))\(173 \mathrm{GeV}\)1/2001/30 Memonic 轻子 重子 运动学变换 洛伦兹变换 洛伦兹不变量 \[\left(\begin{matrix}E' &#92;&#92; p_{x}' &#92;&#92; p_{y}' &#92;&#92; p_{z}' \end{matrix}\right) = \left(\begin{matrix}&gamma; &amp; - v &gamma; &amp; 0 &amp; 0 &#92;&#92; - v &gamma; &amp; &gamma; &amp; 0 &amp; 0 &#92;&#92; 0 &amp; 0 &amp; 1 &amp; 0 &#92;&#92; 0 &amp; 0 &amp; 0 &amp; 1 \end{matrix}\right) \left(\begin{matrix} E &#92;&#92; p_{x} &#92;&#92; p_{y} &#92;&#92; p_{z} \end{matrix}\right)\] 速度关系 \[v = p / E = \frac{\sqrt{E^{2} - m_{0}^{2}}}{E}\] 多粒子系统不变量 \[\left( &sum;_{i} E_{i} \right)^{2} - \left( &sum;_{i} p_{i} \right)^{2} = \mathrm{constant}\] Application 两粒子碰撞质心坐标系 对撞质心系能量 \(E_{\mathrm{cm}}^{2} = 4 E_{1} E_{2}\) 固定靶质心系能量 \(E_{1}' = \frac{2 E_{1}^{2}}{m_{2}}\) 两粒子碎裂 \(&pi;^{0} &rarr; 2 &gamma;\), 两个末态光子的能量 \(E_{1}\) 和 \(E_{2}\): 飞行夹角为 \(cos &theta; = 1 - \frac{m_{&pi;^{0}}^{2}}{2 E_{1} E_{2}}\) 最大张角和最小张角 散射和微分截面 \(D(&theta;) = \frac{\mathrm{d}&sigma;}{\mathrm{d}&Omega;} = \left( \frac{Z e}{4 E sin^{2} (&theta;/2)} \right)^{2}\) 总截面为分截面的和 \(&sigma;_{\mathrm{tot}} = &sum;_{i} &sigma;_{i}\) 反应黄金规则 \(W = 2 &pi; \left| M_{if} \right|^{2} &rho;_{f}\) 微分截面洛伦兹变换 \[D(&theta;) = \frac{\mathrm{d}&sigma;}{\mathrm{d}&Omega;} = \frac{\left| \boldsymbol{p} \right|^{3}}{&gamma;_{c} \left| \boldsymbol{p}' \right|^{3} \left( 1 + \frac{v_{c}}{v'} cos &theta;' \right) } \left( \frac{\mathrm{d}&sigma;}{\mathrm{d}&Omega;} \right)'\] 末态相空间 散射能量计算 Algorithm 计算质心系洛伦兹不变量 \(s^{2}\) (往往质心系中 \(p = 0\) 容易计算) 末态能量 \(E_{1} = \frac{s^{2} + M_{1}^{2} - M_{2}^{2}}{2 s}\) 反应阈能 Feynman 图 费曼规则 时间轴从左到右 外线 (初态和末态) 初态 \(\left\{ \mathrm{PARTICLE}_{\mathrm{i}} \right\} &rarr; \left\{ \mathrm{PARTICLE}_{\mathrm{f}} \right\}\) 末态 初态和末态的粒子作为外线 实线表示夸克和轻子 波浪线表示入射矢量玻色子 带箭头的实线表示费米子场 虚线 Higgs 粒子 内线 (传播子) 连线: 相互作用 电磁相互作用: \(&gamma;\) (波浪线) s-通道: 初态粒子合并成一个中介, 再分裂 t-通道: 初态粒子交换一个中介, 各自飞走 强相互作用: 螺旋线 (胶子 \(g\)) 弱相互作用: 波浪线 \(W^{&plusmn;}\) 标注电荷流向 顶点: 守恒律 电荷守恒 (进=出) 味守恒 (强力和电磁力不改变粒子的味道) 费米子线沿箭头方向连续不间断 基本相互作用 相互作用强度力程媒介子参与作用粒子束缚态例子 强相互作用\(&alpha;_{s} &sim; 1\)\(10^{-15}\ \mathrm{m}\)胶子夸克, 胶子强子 电磁作用\(&alpha; = 1/137\)\(F \propto 1/r^{2}\)光子带电粒子原子, 分子 弱相互作用\(10^{-5}\)\(&lt; 10^{-17}\ \mathrm{m}\)\(W^{&plusmn;}, Z^{0}\)夸克, 轻子无 引力\(10^{-39}\)\(F \propto 1/r^{2}\)引力子所有粒子 对称性和守恒量 守恒量计算 守恒律 强子与量子电动力学 强子 介子: \(&pi;, K, &eta;, &eta;', &rho;, K^{*}, &omega;, &phi;, D, J/&psi;, \cdots\) 重子: \(p, n, &Lambda;, &Sigma;, &Xi;, &Delta;, &Omega;, \cdots\) 不能通过强相互作用衰变的粒子称为稳定粒子 可以通过强相互作用衰变的粒子称为共振态 汤川耦合与 \(&pi;\) 介子 轻子 轻子: \(e^{-}, &nu;_{e}, &mu;^{-}, &nu;_{&mu;}, &tau;^{-}, &nu;_{&tau;}\) OZI 规则 描述: 在强子反应过程中, 如果价夸克的的费曼图被断成互不相连的两部分, 则该过程的反应几率被大大压低 解释: 胶子带颜色, 介子不带, 故单个胶子不能连接湮灭图, 故衰变至少需要三个胶子参与, 所以是高阶图, 量级小 电弱统一理论与标准模型 标准模型 标准模型: 电弱统一理论+量子色动力学 粒子对应场 (场是物质存在的基本形式) 场用复数量描述 场的基态是能量最低的状态 粒子的衰变 相互作用通过场 (粒子) 来传递 中微子振荡 t 时刻出现缪子中微子和电子中微子的概率 \[P_{e&mu;} = sin^{2} (2 &theta;) sin^{2} \left( \frac{&Delta; m^{2} t}{4 E} \right)\] \[P_{ee} = 1 - P_{e&mu;}\] 故可以通过 \(&Delta; m^{2} = \frac{4 E}{L} \mathrm{arcsin} \sqrt{1 - P_{ee}}\) 估算. 电弱统一与 Higgs Higgs 机制的作用 赋予 W, Z 玻色子质量, 保持光子无质量 赋予费米子质量, 联系 Yukawa 耦合 Higgs 玻色子产生机制: 强子对撞机上单个 Higgs: 胶子聚变 正负电子对撞机: Higgs 韧致辐射]]></summary></entry><entry><title type="html">概统</title><link href="/notes/stastics/" rel="alternate" type="text/html" title="概统" /><published>2026-01-19T00:00:00+00:00</published><updated>2026-01-19T00:00:00+00:00</updated><id>/notes/stastics</id><content type="html" xml:base="/notes/stastics/"><![CDATA[<h1>About</h1>
<details><summary>挺一般的研究生课程</summary>
<p>评价是纯纯的 PPT 朗诵.</p>
</details>
<h1>Memonic</h1>
<ul>
  <li>贝叶斯公式 \(P(B_{i} | A) = \frac{P(A|B_{i})P(B_{i})}{&sum;_{j=1}^{n} P(A|B_{j}) P(B_{j})}\)</li>
  <li>随机变量映射 \(F_{Y}(Y) = P(g(X) \leq Y)\)</li>
  <li>统计量数字特征计算
    <table>
      <tr><th>特征</th><th>随机变量</th><th>子样</th></tr>
      <tr><td>平均</td><td>\(\frac{1}{n} &sum; x_i\)</td><td>\(\frac{1}{n} &sum; x_{i}\)</td></tr>
      <tr><td>方差</td><td>\(&sigma;^{2} = &sum; (X - \bar{X})^{2} = &sum; X^{2} - (&sum; X)^{2}\)</td><td>\(S^{2} = \frac{1}{n-1} &sum; (x_{i} - \bar{x}_{i})^{2} = \frac{1}{n-1} ((&sum; x_{i}^{2}) - n \bar{x}^{2})\)</td></tr>
      <tr><td>多元方差</td><td>\(V(&sum; a_{i} X_{i}) = &sum; a_{i}^{2} V(X_{i}) + &sum; a_{i} a_{j} \mathrm{cov}(X_{i}, X_{j})\)</td><td>-</td></tr>
      <tr><td>协方差</td><td>\(\mathrm{cov}(X, Y) = E((X - E(X))(Y - E(Y))) = \mathrm{cov}(X, Y) = E(XY) - E(X)E(Y)\)</td><td>\(S_{XY} = \frac{1}{n-1} &sum; (x_{i} - \bar{x})(y_{i} - \bar{y})\)</td></tr>
      <tr><td>相关系数</td><td>\(&rho;_{XY} = \mathrm{cov}(X, Y) / (&sigma;_{X} &sigma;_{Y})\)</td><td>\(r = \frac{&sum; (x_{i} - \bar{x})(y_{i} - \bar{y})}{\sqrt{(x_{i} - \bar{x})} \sqrt{(y_{i} - \bar{y})}}\)</td></tr>
    </table>
  </li>
  <li>实验数据合并
    <p>\[&mu; = \frac{&sum; \frac{&mu;_{i}}{&sigma;_{i}^{2}}}{ &sum; \frac{1}{ &sigma;_{i}^{2 }} },\ V = \frac{1}{&sum; \frac{1}{&sigma;_{i}^{2} }}\]</p>
  </li>
  <li>极大似然法
    <p>\[L = &prod; f(x_{i}|&theta;),\ &part;_{&theta;} ln L = 0 &and; &part;_{&theta;}^{2} ln L &lt; 0\]</p>
  </li>
  <li>最小二乘法
    <p>\[\mathrm{err}(&theta;) = &sum; (y_{i} - f(x_{i}|&theta;))^{2},\ &part;_{&theta;} \mathrm{err} = 0 &and; &part;_{&theta;}^{2} \mathrm{err} &gt; 0\]</p>
  </li>
  <li>假设检验
    <table>
      <tr><th>条件</th><th>检验对象</th><th>统计量观测值</th><th>拒绝域</th></tr>
      <tr><td>\(&sigma;^{2}\) 已知</td><td>均值 \(&mu;\)</td><td>\(Z = \frac{\bar{X} - &mu;_{0}}{&sigma; / \sqrt{n}}\)</td><td>\(\left\vert Z \right\vert &gt; Z_{&alpha;/2}(n-1)\)</td></tr>
      <tr><td>\(&sigma;^{2}\) 未知</td><td>均质 \(&mu;\)</td><td>\(t = \frac{\bar{X} - &mu;_{0}}{S / \sqrt{n}}\)</td><td>\(\left\vert t \right\vert &gt; t_{&alpha;/2}(n-1)\)</td></tr>
      <tr><td></td><td>方差 \(&sigma;^{2}\)</td><td>\(&chi;^{2} = \frac{(n-1) S^{2}}{&sigma;_{0}^{2}}\)</td><td>\(&chi;^{2} &lt; &chi;_{1-&alpha;/2}^{2}(n-1) &or; &chi;^{2} &gt; &chi;_{&alpha;/2}^{2}(n-1)\)</td></tr>
    </table>
  </li>
  <li>几个分布
    <table>
      <tr><th>分布</th><th>PDF</th><th>E(X)</th><th>V(X)</th><th>Notes</th></tr>
      <tr><td>二项分布 \(B(n, p)\)</td><td>\(\left(\begin{matrix} n &#92;&#92; k\end{matrix}\right) p^{k} (1-p)^{n-k}\)</td><td>\(np\)</td><td>\(np(1-p)\)</td><td>(多项式分布)</td></tr>
      <tr><td>泊松分布 \(P(&lambda;)\)</td><td>\(\frac{&lambda;^{k} \mathrm{e}^{-&lambda;}}{k!}\)</td><td>\(&lambda;\)</td><td>\(&lambda;\)</td><td>粒子计数标准差 \(\sqrt{N}\)</td></tr>
      <tr><td>正态分布 \(N(&mu;,&sigma;^{2})\)</td><td>\(\frac{1}{\sqrt{2 &pi;} &sigma;} \mathrm{exp}\left( - \frac{(x-&mu;)^{2}}{2&sigma;^{2}} \right)\)</td><td>\(&mu;\)</td><td>\(&sigma;\)</td><td></td></tr>
    </table>
  </li>
</ul>
<h1>概率论初步</h1>
<h2>随机试验, 随机事件, 样本空间</h2>
<details><summary>GPT: 用一句话解释名词概念</summary>
<ul>
  <li>必然现象: 在特定条件下必定发生的现象, 任何情况下都会发生</li>
  <li>随机现象: 其结果不可预知, 受随机因素影响的现象</li>
  <li>随机试验: 可以重复进行且结果不确定的实验或过程</li>
  <li>互相独立: 两个或多个事件的发生与否互不影响</li>
  <li>随机事件: 随机试验中可能发生的结果或现象</li>
  <li>基本事件: 在随机试验中不再可以分解的最基本的事件</li>
  <li>样本空间: 随机试验中所有可能基本事件的集合</li>
  <li>元素: 样本空间中的每一个基本事件</li>
  <li>必然事件: 一定会发生的事件, 其概率为 1</li>
  <li>不可能事件: 一定不会发生的事件, 其概率为 0</li>
</ul>
</details>
<ul>
  <li>事件关系</li>
  <li>事件运算 \(A &and; B\), \(A &or; B\), \(&not; A\)</li>
</ul>
<h2>概率</h2>
<p><b>Application</b></p>
<ul>
  <li>多项式分布
    <blockquote>
      <p>盒子里有 5 个红球, 4 个白球和 3 个蓝球,
        从盒子里随机选一球, 记下颜色, 然后返回盒子里.
        求挑选 6 次后出现 3 红, 2 白, 1 蓝的概率.</p>
    </blockquote>
    <ul>
      <li>有放回取样 (多项式分布):
        <p>\[P(\left\{ p_{i}, n_{i} \right\}) = \frac{(&sum; n_{i})!}{&prod; n_{i}!} &prod; p_{i}^{n_{i}}\]</p>
      </li>
      <li>无放回取样 (超几何分布):
        <p>\[P(\left\{ p_{i}, n_{i} \right\}) = \frac{&prod; \left(\begin{matrix} N_{i} &#92;&#92; n_{i} \end{matrix}\right)}{\left(\begin{matrix} &sum; N_{i} &#92;&#92; &sum; n_{i} \end{matrix}\right)}\]</p>
        <p><b>Definition</b>: \(\left(\begin{matrix} N &#92;&#92; n \end{matrix}\right) = \frac{N &times; (N - 1) &times; \cdots &times; (n+1)}{n &times; \cdots &times; 1}\)</p>
      </li>
    </ul>
  </li>
</ul>
<h2>条件概率</h2>
<ul>
  <li>\(P(B|A) = \frac{P(A &and; B)}{P(A)}\)</li>
  <li>事件独立性
    <p><b>Definition</b>:
      \(P(A B) = P(A) P(B) &hArr; P(B|A) = P(B) &hArr;\) A, B 独立</p>
    <p><b>Application</b></p>
    <ul>
      <li>判断随机变量的独立性
        <blockquote>
          <p>设随机变量 \(X, Y\) 的 PDF 为
            \(f(x, y) = A \mathrm{e}^{- a x^2 + b x y - c y^2}, - &infin; &lt; x &lt; &infin;, - &infin; &lt; y &lt; &infin;\),
            问在什么条件下 \(X\) 与 \(Y\) 相互独立?</p>
        </blockquote>
        <ul>
          <li>证明需要证明 \(f(x, y) = f_{X}(x) f_{Y}(y)\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2>概率计算</h2>
<h2>边沿概率, 全概率公式, 贝叶斯公式</h2>
<ul>
  <li>边沿概率
    <p><b>Application</b>:</p>
    <ul>
      <li>已知联合分布, 计算边缘分布</li>
      <li>补全联合分布</li>
    </ul>
  </li>
  <li>全概率公式 \(P(A) = &sum; P(A | B_{i}) P(B_{i})\),
    其中 \(\left\{ B_{i} \right\}\) 为样本空间的划分</li>
  <li>贝叶斯公式 \(P(B_{i} | A) = \frac{P(A|B_{i})P(B_{i})}{&sum;_{j=1}^{n} P(A|B_{j}) P(B_{j})}\)
    <p><b>Memonic</b>:
      \(P(B_{i} | A) P(A) = P(B_{i} &and; A) = P(A | B_{i}) P(B_{i})\)</p>
    <p><b>Application</b>:</p>
    <ul>
      <li>误判概率计算 (逆概率计算)
        <blockquote>
          <p>已知某放射源产生的射线中包含 A, B, C 三种粒子,
            占比分别 1/2, 1/6, 1/3. 在实验的粒子鉴别过程中,
            A 粒子被误判为其他粒子的概率为 10%,
            B, C 粒子被误判为 A 粒子的概率分别为 12% 和 21%.
            请计算出被鉴别为 A 粒子的事例来自真实的 A 粒子的概率.</p>
        </blockquote>
        <ul>
          <li>已知 \(P(S_{A})\) (\(S_{*}\) 对样本空间的划分) 以及 \(P(D_{A} | S_{ *})\)
            <p>求 \(P(S_{A} | D_{A}) = \frac{P(D_{A} | S_{A}) P(S_{A})}{&sum; P(D_{A}|S_{<b>})P(S_{</b>})\)</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h1>随机变量及其分布</h1>
<h2>随机变量</h2>
<ul>
  <li>为了和之后的子样 (\(x_{i}\)) 作区分, 这里用 \(X\) 表示随机变量
  <details><summary>数学符号一坨乱麻</summary>
    <p>不知道是不是 PPT 里面的数学公式和文本是东拼西凑的,
      里面的数学公式符号非常的不一致&#8230; 学起来很混乱.</p>
  </details>
  </li>
  <li>概率密度函数 (PDF): \(f(X)\)</li>
  <li>累计分布函数 (CDF): \(F(X) = &int; f(X) \mathrm{d}x\)</li>
  <li>随机变量的映射:
    <p><b>Algorithm I</b>: \(F_{y}(y) = P(g(x) \leq y)\)</p>
    <p><b>Algorithm II</b>:
      \(g\) 为映射作用在随机变量 \(X\) 上, 则 \(f_{Y}(Y) = f_{X}(g^{-1}(Y)) \left| \frac{\mathrm{d}}{\mathrm{d} Y} g^{-1}(Y) \right|\).</p>
    <p><b>Memonic</b>:
      \(F_{Y}(Y) = &int; f_{Y}(Y) \mathrm{d} Y = &int; f_{X}(X) \mathrm{d} X \frac{\mathrm{d} X}{\mathrm{d} Y} &rArr; f_{Y} = f_{X}(g^{-1}(Y)) \frac{\mathrm{d} X}{\mathrm{d} Y}\)</p>
    <p><b>Application</b>:</p>
    <ul>
      <li>计算概率密度函数映射
        <blockquote>
          <p>随机变量 \(X\) 的概率密度函数为:</p>
          <p>\[f(x) = \left\{ \begin{matrix} x^2 / 18 &amp; -3 &lt; x &lt; 3 &#92;&#92; 0 &amp; \mathrm{other} \end{matrix} \right.\]</p>
          <p>求 \(Y = (X + 1)^2\) 的概率密度函数.</p>
        </blockquote>
        <ul>
          <li>非单调映射 \(F_{Y}(y) = P(g(X) \leq y)\)</li>
        </ul>
      </li>
      <li>计算变换关系
        <blockquote>
          <p>已知 \(X, Y\) 为 \((0, 1)\) 区间上均匀分布的随机变量且相互独立,
            二维随机变量 \(U, V\) 和 \(X, Y\) 之间存在变换关系:
            \(U = cos (2 &pi; x) \sqrt{- 2 ln y}, V = sin (2 &pi; x) \sqrt{- 2 ln y}\),
            证明 \(U, V\) 服从 \(N(0, 1)\).</p>
        </blockquote>
      </li>
      <li>映射的数字特征
        <blockquote>
          <p>随机变量 \(X, Y\) 都服从 \(N(&mu;, &sigma;^2)\) 且相互独立, 令 \(U = a X + b Y, W = a X b Y\),
            求 \(U\) 与 \(W\) 的相关系数 \(&rho;_{UW}\).</p>
        </blockquote>
        <ul>
          <li>\(E(a X + b Y) = a E(X) + b E(Y)\)</li>
          <li>\(E(X Y) = E(X) E(Y)\)</li>
          <li>\(\mathrm{cov}(a X + b Y, Z) = a \mathrm{cov}(X, Z) + b \mathrm{cov}(Y, Z)\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2>随机变量的数字特征</h2>
<ul>
  <li>期望值 \(E(g(X)) = &int; g(X) f(X) \mathrm{d} X\)
    <p><b>Linear Property</b>: \(E(&sum; a_{i} X_{i}) = a_{i} E(X_{i})\)</p>
  </li>
  <li>中位数 (\(p\) 分位数)</li>
  <li>最可几值 (\(x |_{P(x) &rarr; \mathrm{maximum}}\))</li>
  <li>矩 \(&alpha;_{l} = E((X - C)^{l})\)
    <ul>
      <li>一阶原点矩 \(&mu; = E(X)\)</li>
      <li>二阶中心矩 \(&sigma;^{2} = E(X - &mu;)^{2} = V(X)\)</li>
    </ul>
    <p><b>Quick Calc</b>:</p>
    <ul>
      <li>\(V(&sum; a_{i} X_{i}) = &sum; a_{i}^{2} V(X_{i}) + 2 &sum; a_{i} a_{j} \mathrm{cov}(X_{i}, X_{j})\)</li>
    </ul>
  </li>
  <li>偏度 \(&gamma;_{1} = \frac{&mu;_{3}}{&mu;_{2}^{3/2}} = \frac{E((X - &mu;)^{3})}{&sigma;^{3}}\)
    <p>随机变量对其均值的不对称程度, 偏斜程度</p>
  </li>
  <li>峰度 \(&gamma;_{2} = \frac{&mu;_{4}}{&mu;_{2}^{2}} - 3 = \frac{E((X - &mu;)^{4})}{&sigma;^{4}} - 3\)
    <p>概率密度的尖锐程度于正态分布概率曲线尖锐程度的对比</p>
  </li>
  <li>切比雪夫不等式 \(P(\left| X - &mu; \right| \geq &epsilon;) \leq \frac{&sigma;^{2} }{&epsilon;^{2} }\)
    <p><b>GPT</b>: 不关心随机变量服从什么具体的分布, 只要知道期望 (均值) 和方差,
      就能给概率划定一个界限.</p>
    <p>令 \(&epsilon; = k &sigma;\), 即 \(P(|X - &mu;| \geq k &sigma;) \leq \frac{1}{k^{2}}\),
      限定了和均值偏差大于 \(k &sigma;\) 的概率的上界.</p>
  <details><summary>GPT</summary>
    <p>感觉课件里面一堆乱七八糟的东西, 有点像是只言片语的梦话连不成线;
      或者是有用的信息在长长的文字和定义证明中失去了信息的传递能力.</p>
    <p>低情商发言就是: 不如 AI.</p>
    <p>以后老师不如就给大纲和要点, 让学生问 AI 算了.</p>
  </details>
  </li>
</ul>
<h2>随机变量的特征函数</h2>
<ul>
  <li>\(\varphi_{X}(t) = E(e^{i t X})\)
    <p><b>GPT</b>: 等价于傅里叶变换为频域.</p>
  </li>
  <li>\(&lambda;_{n} = E(X^{n}) = i^{-n} \left[ \frac{\mathrm{d}^{n} \varphi_{X}(t)}{\mathrm{d} t^{n}} \right]\)</li>
</ul>
<h2>随机变量的分布</h2>
<ul>
  <li>多项式分布</li>
  <li>泊松分布</li>
  <li>均匀分布</li>
  <li>正态分布</li>
</ul>
<h1>多维随机变量及其分布</h1>
<h2>二维随机变量的分布, 独立性</h2>
<ul>
  <li>\(F(x, y) = P(X \leq x &and; Y \leq y)\)</li>
  <li>独立性
    <p><b>Definition</b>: \(f(x, y) = f_{X}(x) f_{Y}(y)\)</p>
  </li>
</ul>
<h2>条件概率分布</h2>
<h2>二维随机变量的数字特征</h2>
<ul>
  <li>协方差 \(\mathrm{cov}(X, Y) = E((X - &mu;_{X})(Y - &mu;_{Y})) = E(XY) - E(X) E(Y)\)</li>
  <li>相关系数 \(&rho;_{XY} = \frac{\mathrm{cov}(X, Y)}{&sigma;_{X} &sigma;_{Y}}\)
    <p><b>Memonic</b>: \(\mathrm{cov}(X, X) = &sigma;_{X}^{2}\)</p>
  </li>
  <li>协方差矩阵 \(V_{ij} = \mathrm{cov}(X_{i}, X_{j})\)</li>
</ul>
<h2>两个随机变量的函数的分布</h2>
<h2>多维随机变量, 向量和矩阵记号</h2>
<h1>随机变量分布</h1>
<h1>中心极限定理</h1>
<p><b>GPT</b>: 样本量 \(n\) 足够大, 均值分布趋向于正态分布.</p>
<p><b>Application</b>:</p>
<ul>
  <li>二项分布的正态近似
    <p>&#8230;</p>
  </li>
</ul>
<h1>子样及分布</h1>
<h2>随机子样, 子样分布函数</h2>
<ul>
  <li>子样</li>
  <li>子样空间</li>
  <li>子样分布函数</li>
</ul>
<h2>统计量及其数字特征</h2>
<ul>
  <li>子样中位数</li>
  <li>子样平均: \(\bar{x} = \frac{1}{n} &sum; x_{i}\)</li>
  <li>子样方差: \(S^{2} = \frac{1}{n-1} &sum; (x_{i} - \bar{x})^{2} = \frac{1}{n - 1} \left( (&sum; x_{i}^{2})- n \bar{x}^{2} \right)\)</li>
  <li>子样标准值: \(S\)</li>
  <li>子样协方差: \(S_{xy} = \frac{1}{n-1} &sum; (x_{i} - x) (y_{i} - y) = \frac{1}{n-1} \left( &sum; x_{i} y_{i} - n \bar{x} \bar{y} \right)\)</li>
  <li>子样相关系数: \(&rho;_{xy} = \frac{S_{XY}}{S_{X} S_{Y}} = \frac{&sum; (x_{i} - \bar{x})(y_{i} - \bar{y})}{(&sum; x_{i}^{2} - n \bar{x}^{2} )^{1/2} (&sum; y_{i}^{2} - n \bar{y}^{2})^{1/2}}\)</li>
</ul>
<p><b>Memonic</b>: 和随机变量一样, 但是平均的项变为 \(1/(n-1)\).</p>
<p><b>Application</b></p>
<ul>
  <li>根据子样数据计算数字特征</li>
</ul>
<h2>抽样分布</h2>
<ul>
  <li>\(&chi;^{2}\) 分布: 总体服从正态分布时, 样本方差与总体方差的比值服从卡方分布</li>
  <li>\(t\) 分布: 样本均值于标准误差的比值服从 t 分布</li>
  <li>\(F\) 分布: 两个样本方差的比值</li>
</ul>
<p><b>Application</b></p>
<ul>
  <li>已知子样总体, 计算统计量的概率分布</li>
</ul>
<h2>抽样数据的图形表示, 概率分布</h2>
<h1>参数估计的一般概念</h1>
<h2>估计量, 似然函数</h2>
<h2>区间估计</h2>
<p><b>Algorithm</b>:</p>
<p><b>Application</b>:</p>
<ul>
  <li>单正态总体的均值</li>
  <li>单正态总体的方差</li>
  <li>双正态总体的均值差</li>
</ul>
<h2>正态总体方差的置信区间</h2>
<p><b>Algorithm</b></p>
<p><b>Application</b></p>
<ul>
  <li>已知样本总体, 给定置信水平, 计算置信区间
    <table>
      <tr><th>估计对象</th><th>已知条件</th><th>置信区间公式</th></tr>
      <tr><td>均值 \(&mu;\)</td><td>\(&sigma;^{2}\) 已知</td><td>\(\left[ \bar{x} \mp Z_{&alpha;/2} \frac{&sigma;}{\sqrt{n}} \right]\)</td></tr>
      <tr><td>均值 \(&mu;\)</td><td>\(&sigma;^{2}\) 未知</td><td>\(\left[ \bar{x} \mp t_{&alpha;/2}(n-1) \frac{S}{\sqrt{n}} \right]\)</td></tr>
      <tr><td>方差 \(&sigma;^{2}\)</td><td>\(&mu;\) 未知</td><td>\(\left[ \frac{(n-1) S^2}{&chi;_{&alpha;/2}^{2}(n-1)}, \frac{(n-1) S^{2}}{&chi;_{1-&alpha;/2}^{2} (n-1)} \right]\)</td></tr>
    </table>
    <p><b>Calculation</b>:</p>
    <ul>
      <li>\(Z_{&alpha;/2} = &Phi;^{-1}(1 - &alpha;/2)\), where \(&Phi;\) 为 \(N(0, 1)\) 正态分布</li>
      <li>\(t_{&alpha;/2}(n)\) 为自由度为 \(n-1\) 的 Student 分布</li>
      <li>\(&chi;_{&alpha;/2}^{2}(n)\), where \(&chi;^{2}(n)\) 为自由度为 \(n-1\) 的卡方分布</li>
    </ul>
    <p>明明是查表才能知道的东西&#8230;</p>
  </li>
</ul>
<h1>极大似然法</h1>
<h2>极大似然原理</h2>
<p><b>Algorithm</b>:</p>
<ol>
  <li>构造函数: \(L(\left\{ x_{i} \right\} | &theta;) = &prod; f(x_{i}|&theta;)\)</li>
  <li>极大似然条件约束下求解 \(&theta;\): \(&part;_{&theta;} ln L = 0 &and; &part;_{&theta;}^{2} ln L &lt; 0\)</li>
</ol>
<p><b>Application</b>:</p>
<ul>
  <li>参数区间估计 (似然区间)
    <p><b>Algorithm</b>:</p>
    <ol>
      <li>\(&gamma; = \frac{&int;_{&theta;_{a}}^{&theta;_{b}} L(X|&theta;) \mathrm{d}&theta;}{&int;_{-&infin;}^{&infin;} L(X|&theta;) \mathrm{d}&theta;}\)</li>
      <li>同上, 在 \(&part;_{&theta;} &gamma; = 0 &and; &part;_{&theta;}^{2} &gamma; &lt; 0\) 条件下求解</li>
    </ol>
  </li>
  <li>子样观测值
    <ul>
      <li>几何分布
        <blockquote>
          <p>设 \(x_{1}, \cdots, x_{n}\) 是几何分布总体的子样观测值,
            其分布律为 \(P(X = x) = p (1 - p)^{x-1}, x = 1, 2, \cdots, &infin;\).
            求参数 \(p\) 的极大似然估计.</p>
        </blockquote>
        <ul>
          <li>\(L(\left\{ x_{i} \right\} | p) = &prod; p(1-p)^{x-1}\)</li>
          <li>\(&part;_{p} ln L = &part;_{p} ln \left( p^{n} (1-p)^{&sum; x_{i} - n} \right) = \frac{n - p &sum; x_{i}}{p(1-p)}\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2>极大似然法应用于多个实验结果的合并</h2>
<ul>
  <li>\(&mu; = \frac{&sum; \frac{&mu;_{i}}{&sigma;_{i}^{2}}}{ &sum; \frac{1}{ &sigma;_{i}^{2 }} } \)</li>
  <li>\(V = \frac{1}{&sum; \frac{1}{&sigma;_{i}^{2} }}\)</li>
</ul>
<h2>极大似然法用于直方图</h2>
<h1>最小二乘法</h1>
<h2>最小二乘拟合</h2>
<p><b>Algorithm</b>:</p>
<ol>
  <li>构造误差函数 \(\mathrm{err}(&theta;) = &sum; (y_{i} - f(x_{i} | &theta;))^{2}\)</li>
  <li>最小化误差 \(&part;_{&theta;} \mathrm{err} = 0 &and; &part;_{&theta;}^{2} \mathrm{err} &gt; 0\)</li>
</ol>
<h2>最小二乘用于直方图数据</h2>
<h1>假设检验</h1>
<h2>原假设和备择假设</h2>
<ul>
  <li>参数检验: 根据观测值检验参数是否等于某个给定值</li>
  <li>非参数检验: 根据观测值检验模型函数是否有某个特定函数形式</li>
  <li>原假设: 要验证的假设为原假设</li>
  <li>备择假设</li>
</ul>
<h2>假设检验的一般方法</h2>
<p><b>Algorithm</b></p>
<ol>
  <li>原假设和备择假设 (Input)</li>
  <li>原假设成立时的统计量</li>
  <li>计算统计量观测值</li>
  <li>计算拒绝域</li>
  <li>判断统计决策</li>
</ol>
<p><b>Application</b></p>
<ul>
  <li>已知正态分布 (子样分布) 和方差
    <blockquote>
      <p>某厂生产的一种电池, 其寿命长期以来服从方差 \(&sigma;^{2} = 5000\ \mathrm{h}^{2}\) 的正态分布.
        近期生产一批这种电池, 从生产的情况来看不能肯定寿命方差是否改变.
        现随机地取 26 个电池, 测得寿命的样本方差为 \(S^{2} = 9200\ \mathrm{h}^{2}\).
        问根据这一数据能否推断这批电池寿命方差较以往有显著变换 (取 \(&alpha; = 0.02\))?</p>
    </blockquote>
  </li>
</ul>
<h2>正态总体的参数检验</h2>
<h2>拟合优度检验</h2>
<ul>
  <li>\(&chi;^{2}\) 检验
    <p><b>Definition</b>:</p>
    <ul>
      <li>\(&chi;^{2} = &sum; \frac{(x_{i} - X)^{2}}{X}\)</li>
    </ul>
  </li>
  <li>似然比检验</li>
</ul>
<h2>信号的统计显著性</h2>
<h1>贝叶斯公式</h1>
<h1>Monte Carlo 方法</h1>
<p>实际使用过程中, Monte Carlo 方法需要很好地构造随机过程&#8230;</p>
<h1>模式识别系统</h1>
<p>乐, 只有大段文字, 仿佛在看本科生大学写作课程作业的综述论文.
  (而且都还很老, 并且不知道为啥, 物理系这边的 AI 课特别喜欢讲 Hopfield 网络,
  哪怕他们讲的 Hopfield 网络都不太能用, 或者说不知道该怎么用. )</p>
<details><summary>理论课的通病</summary>
<p>不知道为啥, 讲理论课的老师往往会把定理/算法/规律的严格证明视作是实现的正确性,
  好像是只要我证明了我的做法是对的, 那么做的结果就一定是对的.</p>
<p>然后对于如何评价实际结果的正确性的方法几乎不提.</p>
<p>搞清楚课程定位啊淦, 这课不是 <b>物理</b> 中的概率统计吗? 不是实验类的课程吗?
  别告诉我说你们实验组有祖传代码拟合分析误差自动生成论文配图,
  只需要知道自己的原理是对的是吧&#8230;</p>
<p>(当然, 假设检验确实是一个可用的方法, 但是什么叫做假设检验课在证明假设检验是对的? )</p>
<p>又, 还有的困难是引入的新理论和旧的理论接不上, 有种粘连的感觉.
  这有种讲分析力学讲了半天的拉格朗日方程, 结果最后发现用的是牛顿三定律一样的奇怪.
  应该就直接抛弃旧的知识, 用新的视角去讲整个 (要么就干脆承认, 说我们不讲新的).
  在本科赵爹的课上的那个做法就很不错, 用新的视角去引入 (上来就是对称性守恒律,
  相信基础教育的牛顿三定律的普及教育, 而不是重新教一遍牛顿三定律再开始讲能量视角),
  然后在打好了新的视角的基础之后, 再回过头去审视旧的理论如何迁移到新的视角里.</p>
<p>比如在概统的这边, 我觉得确实可以用测度空间的方法来解释很多东西,
  然后再回过头去讲其他东西, 就会很不错. 不过可能也要看具体的应用或者教学需求,
  用测度论来讲实验误差分析的话, 感觉不是很好理解 (也有可能只是我不会, 之后可以重新学),
  但是如果直接从实验误差为主线来重新讲课, 那估计就能够砍掉很多的垃圾学时,
  并且还能更有条理&#8230;</p>
</details>
<h2>特征提取和选择</h2>
<h2>效率, 误判率, 分辨能力</h2>
<ul>
  <li>效率: 正确选定一个信号事例的效率 \(&epsilon;_{SS} = &int; f_{S}(y) \mathrm{d}y\)</li>
  <li>误判率: 将本底错误选择为一个信号事例的误判率 \(&epsilon;_{SB} = &int; f_{B}(y) \mathrm{d}y\)</li>
  <li>误判率: 效率与误判率的比 \(r = &epsilon;_{SS} / &epsilon;_{SB}\)</li>
</ul>
<p><b>Memonic</b>: 引入误差矩阵</p>
<table>
  <tr><th>判断 \ 实际</th><th>真</th><th>假</th></tr>
  <tr><td>真</td><td>真真</td><td>真假</td></tr>
  <tr><td>假</td><td>假真</td><td>假假</td></tr>
</table>
<ul>
  <li>效率: 真真 / (真真 + 假真)</li>
  <li>误判率: 真假 / (真假 + 假假)</li>
  <li>方差:
    <ul>
      <li>\(V(&epsilon;_{SS}) = \frac{&epsilon;_{SS} (1 - &epsilon;_{SS})}{N_{S}}\)</li>
      <li>\(V(r)/r^{2} = V(&epsilon;_{SS}) / &epsilon;_{SS}^{2} + V(&epsilon;_{SB}) / &epsilon;_{SB}^{2}\)</li>
    </ul>
  </li>
</ul>
<h2>方法</h2>
<ul>
  <li>贝叶斯决策</li>
  <li>线性判别</li>
  <li>决策树方法</li>
  <li>人工神经网络</li>
  <li>近邻法</li>
  <li>概率密度估计量方法</li>
  <li>H 矩阵判别</li>
  <li>函数判别</li>
  <li>SVM</li>
</ul>
<h1>小信号测量的区间估计</h1>
<h1>测量误差及其分类</h1>
<details><summary>和子样误差放在一起</summary>
<p>课上把测量误差和子样误差分开来讲了, 实际上我觉得这两个东西应当放在一起讲,
  毕竟这两个才是真的相关的知识, 也是在实验里真的用的东西.</p>
<p>明明可以用一个实验数据的采集的全流程来讲随机子样, 子样分布函数这些知识,
  非要用概念朗诵, 鼠标扫扫公式 &#8211; 大家要记住哦, 很重要哦, 这种方式来教课&#8230;</p>
<p>不过也可以理解就是了 &#8211; who cares?</p>
</details>
<p><b>Application</b>:</p>
<ul>
  <li>误差传递公式</li>
  <li>探测器效率计算: 实际计数 / 源计数
    <p><b>Application</b>:</p>
    <ul>
      <li>多层符合探测效率
        <ul>
          <li>m 层中至少 k 触发: \(&epsilon;_{\mathrm{tol}} = &sum; \left(\begin{matrix}m &#92;&#92; k\end{matrix}\right) &epsilon;^{i} (1 - &epsilon;)^{m-i}\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="notes" /><summary type="html"><![CDATA[About 挺一般的研究生课程 评价是纯纯的 PPT 朗诵. Memonic 贝叶斯公式 \(P(B_{i} | A) = \frac{P(A|B_{i})P(B_{i})}{&sum;_{j=1}^{n} P(A|B_{j}) P(B_{j})}\) 随机变量映射 \(F_{Y}(Y) = P(g(X) \leq Y)\) 统计量数字特征计算 特征随机变量子样 平均\(\frac{1}{n} &sum; x_i\)\(\frac{1}{n} &sum; x_{i}\) 方差\(&sigma;^{2} = &sum; (X - \bar{X})^{2} = &sum; X^{2} - (&sum; X)^{2}\)\(S^{2} = \frac{1}{n-1} &sum; (x_{i} - \bar{x}_{i})^{2} = \frac{1}{n-1} ((&sum; x_{i}^{2}) - n \bar{x}^{2})\) 多元方差\(V(&sum; a_{i} X_{i}) = &sum; a_{i}^{2} V(X_{i}) + &sum; a_{i} a_{j} \mathrm{cov}(X_{i}, X_{j})\)- 协方差\(\mathrm{cov}(X, Y) = E((X - E(X))(Y - E(Y))) = \mathrm{cov}(X, Y) = E(XY) - E(X)E(Y)\)\(S_{XY} = \frac{1}{n-1} &sum; (x_{i} - \bar{x})(y_{i} - \bar{y})\) 相关系数\(&rho;_{XY} = \mathrm{cov}(X, Y) / (&sigma;_{X} &sigma;_{Y})\)\(r = \frac{&sum; (x_{i} - \bar{x})(y_{i} - \bar{y})}{\sqrt{(x_{i} - \bar{x})} \sqrt{(y_{i} - \bar{y})}}\) 实验数据合并 \[&mu; = \frac{&sum; \frac{&mu;_{i}}{&sigma;_{i}^{2}}}{ &sum; \frac{1}{ &sigma;_{i}^{2 }} },\ V = \frac{1}{&sum; \frac{1}{&sigma;_{i}^{2} }}\] 极大似然法 \[L = &prod; f(x_{i}|&theta;),\ &part;_{&theta;} ln L = 0 &and; &part;_{&theta;}^{2} ln L &lt; 0\] 最小二乘法 \[\mathrm{err}(&theta;) = &sum; (y_{i} - f(x_{i}|&theta;))^{2},\ &part;_{&theta;} \mathrm{err} = 0 &and; &part;_{&theta;}^{2} \mathrm{err} &gt; 0\] 假设检验 条件检验对象统计量观测值拒绝域 \(&sigma;^{2}\) 已知均值 \(&mu;\)\(Z = \frac{\bar{X} - &mu;_{0}}{&sigma; / \sqrt{n}}\)\(\left\vert Z \right\vert &gt; Z_{&alpha;/2}(n-1)\) \(&sigma;^{2}\) 未知均质 \(&mu;\)\(t = \frac{\bar{X} - &mu;_{0}}{S / \sqrt{n}}\)\(\left\vert t \right\vert &gt; t_{&alpha;/2}(n-1)\) 方差 \(&sigma;^{2}\)\(&chi;^{2} = \frac{(n-1) S^{2}}{&sigma;_{0}^{2}}\)\(&chi;^{2} &lt; &chi;_{1-&alpha;/2}^{2}(n-1) &or; &chi;^{2} &gt; &chi;_{&alpha;/2}^{2}(n-1)\) 几个分布 分布PDFE(X)V(X)Notes 二项分布 \(B(n, p)\)\(\left(\begin{matrix} n &#92;&#92; k\end{matrix}\right) p^{k} (1-p)^{n-k}\)\(np\)\(np(1-p)\)(多项式分布) 泊松分布 \(P(&lambda;)\)\(\frac{&lambda;^{k} \mathrm{e}^{-&lambda;}}{k!}\)\(&lambda;\)\(&lambda;\)粒子计数标准差 \(\sqrt{N}\) 正态分布 \(N(&mu;,&sigma;^{2})\)\(\frac{1}{\sqrt{2 &pi;} &sigma;} \mathrm{exp}\left( - \frac{(x-&mu;)^{2}}{2&sigma;^{2}} \right)\)\(&mu;\)\(&sigma;\) 概率论初步 随机试验, 随机事件, 样本空间 GPT: 用一句话解释名词概念 必然现象: 在特定条件下必定发生的现象, 任何情况下都会发生 随机现象: 其结果不可预知, 受随机因素影响的现象 随机试验: 可以重复进行且结果不确定的实验或过程 互相独立: 两个或多个事件的发生与否互不影响 随机事件: 随机试验中可能发生的结果或现象 基本事件: 在随机试验中不再可以分解的最基本的事件 样本空间: 随机试验中所有可能基本事件的集合 元素: 样本空间中的每一个基本事件 必然事件: 一定会发生的事件, 其概率为 1 不可能事件: 一定不会发生的事件, 其概率为 0 事件关系 事件运算 \(A &and; B\), \(A &or; B\), \(&not; A\) 概率 Application 多项式分布 盒子里有 5 个红球, 4 个白球和 3 个蓝球, 从盒子里随机选一球, 记下颜色, 然后返回盒子里. 求挑选 6 次后出现 3 红, 2 白, 1 蓝的概率. 有放回取样 (多项式分布): \[P(\left\{ p_{i}, n_{i} \right\}) = \frac{(&sum; n_{i})!}{&prod; n_{i}!} &prod; p_{i}^{n_{i}}\] 无放回取样 (超几何分布): \[P(\left\{ p_{i}, n_{i} \right\}) = \frac{&prod; \left(\begin{matrix} N_{i} &#92;&#92; n_{i} \end{matrix}\right)}{\left(\begin{matrix} &sum; N_{i} &#92;&#92; &sum; n_{i} \end{matrix}\right)}\] Definition: \(\left(\begin{matrix} N &#92;&#92; n \end{matrix}\right) = \frac{N &times; (N - 1) &times; \cdots &times; (n+1)}{n &times; \cdots &times; 1}\) 条件概率 \(P(B|A) = \frac{P(A &and; B)}{P(A)}\) 事件独立性 Definition: \(P(A B) = P(A) P(B) &hArr; P(B|A) = P(B) &hArr;\) A, B 独立 Application 判断随机变量的独立性 设随机变量 \(X, Y\) 的 PDF 为 \(f(x, y) = A \mathrm{e}^{- a x^2 + b x y - c y^2}, - &infin; &lt; x &lt; &infin;, - &infin; &lt; y &lt; &infin;\), 问在什么条件下 \(X\) 与 \(Y\) 相互独立? 证明需要证明 \(f(x, y) = f_{X}(x) f_{Y}(y)\) 概率计算 边沿概率, 全概率公式, 贝叶斯公式 边沿概率 Application: 已知联合分布, 计算边缘分布 补全联合分布 全概率公式 \(P(A) = &sum; P(A | B_{i}) P(B_{i})\), 其中 \(\left\{ B_{i} \right\}\) 为样本空间的划分 贝叶斯公式 \(P(B_{i} | A) = \frac{P(A|B_{i})P(B_{i})}{&sum;_{j=1}^{n} P(A|B_{j}) P(B_{j})}\) Memonic: \(P(B_{i} | A) P(A) = P(B_{i} &and; A) = P(A | B_{i}) P(B_{i})\) Application: 误判概率计算 (逆概率计算) 已知某放射源产生的射线中包含 A, B, C 三种粒子, 占比分别 1/2, 1/6, 1/3. 在实验的粒子鉴别过程中, A 粒子被误判为其他粒子的概率为 10%, B, C 粒子被误判为 A 粒子的概率分别为 12% 和 21%. 请计算出被鉴别为 A 粒子的事例来自真实的 A 粒子的概率. 已知 \(P(S_{A})\) (\(S_{*}\) 对样本空间的划分) 以及 \(P(D_{A} | S_{ *})\) 求 \(P(S_{A} | D_{A}) = \frac{P(D_{A} | S_{A}) P(S_{A})}{&sum; P(D_{A}|S_{})P(S_{})\) 随机变量及其分布 随机变量 为了和之后的子样 (\(x_{i}\)) 作区分, 这里用 \(X\) 表示随机变量 数学符号一坨乱麻 不知道是不是 PPT 里面的数学公式和文本是东拼西凑的, 里面的数学公式符号非常的不一致&#8230; 学起来很混乱. 概率密度函数 (PDF): \(f(X)\) 累计分布函数 (CDF): \(F(X) = &int; f(X) \mathrm{d}x\) 随机变量的映射: Algorithm I: \(F_{y}(y) = P(g(x) \leq y)\) Algorithm II: \(g\) 为映射作用在随机变量 \(X\) 上, 则 \(f_{Y}(Y) = f_{X}(g^{-1}(Y)) \left| \frac{\mathrm{d}}{\mathrm{d} Y} g^{-1}(Y) \right|\). Memonic: \(F_{Y}(Y) = &int; f_{Y}(Y) \mathrm{d} Y = &int; f_{X}(X) \mathrm{d} X \frac{\mathrm{d} X}{\mathrm{d} Y} &rArr; f_{Y} = f_{X}(g^{-1}(Y)) \frac{\mathrm{d} X}{\mathrm{d} Y}\) Application: 计算概率密度函数映射 随机变量 \(X\) 的概率密度函数为: \[f(x) = \left\{ \begin{matrix} x^2 / 18 &amp; -3 &lt; x &lt; 3 &#92;&#92; 0 &amp; \mathrm{other} \end{matrix} \right.\] 求 \(Y = (X + 1)^2\) 的概率密度函数. 非单调映射 \(F_{Y}(y) = P(g(X) \leq y)\) 计算变换关系 已知 \(X, Y\) 为 \((0, 1)\) 区间上均匀分布的随机变量且相互独立, 二维随机变量 \(U, V\) 和 \(X, Y\) 之间存在变换关系: \(U = cos (2 &pi; x) \sqrt{- 2 ln y}, V = sin (2 &pi; x) \sqrt{- 2 ln y}\), 证明 \(U, V\) 服从 \(N(0, 1)\). 映射的数字特征 随机变量 \(X, Y\) 都服从 \(N(&mu;, &sigma;^2)\) 且相互独立, 令 \(U = a X + b Y, W = a X b Y\), 求 \(U\) 与 \(W\) 的相关系数 \(&rho;_{UW}\). \(E(a X + b Y) = a E(X) + b E(Y)\) \(E(X Y) = E(X) E(Y)\) \(\mathrm{cov}(a X + b Y, Z) = a \mathrm{cov}(X, Z) + b \mathrm{cov}(Y, Z)\) 随机变量的数字特征 期望值 \(E(g(X)) = &int; g(X) f(X) \mathrm{d} X\) Linear Property: \(E(&sum; a_{i} X_{i}) = a_{i} E(X_{i})\) 中位数 (\(p\) 分位数) 最可几值 (\(x |_{P(x) &rarr; \mathrm{maximum}}\)) 矩 \(&alpha;_{l} = E((X - C)^{l})\) 一阶原点矩 \(&mu; = E(X)\) 二阶中心矩 \(&sigma;^{2} = E(X - &mu;)^{2} = V(X)\) Quick Calc: \(V(&sum; a_{i} X_{i}) = &sum; a_{i}^{2} V(X_{i}) + 2 &sum; a_{i} a_{j} \mathrm{cov}(X_{i}, X_{j})\) 偏度 \(&gamma;_{1} = \frac{&mu;_{3}}{&mu;_{2}^{3/2}} = \frac{E((X - &mu;)^{3})}{&sigma;^{3}}\) 随机变量对其均值的不对称程度, 偏斜程度 峰度 \(&gamma;_{2} = \frac{&mu;_{4}}{&mu;_{2}^{2}} - 3 = \frac{E((X - &mu;)^{4})}{&sigma;^{4}} - 3\) 概率密度的尖锐程度于正态分布概率曲线尖锐程度的对比 切比雪夫不等式 \(P(\left| X - &mu; \right| \geq &epsilon;) \leq \frac{&sigma;^{2} }{&epsilon;^{2} }\) GPT: 不关心随机变量服从什么具体的分布, 只要知道期望 (均值) 和方差, 就能给概率划定一个界限. 令 \(&epsilon; = k &sigma;\), 即 \(P(|X - &mu;| \geq k &sigma;) \leq \frac{1}{k^{2}}\), 限定了和均值偏差大于 \(k &sigma;\) 的概率的上界. GPT 感觉课件里面一堆乱七八糟的东西, 有点像是只言片语的梦话连不成线; 或者是有用的信息在长长的文字和定义证明中失去了信息的传递能力. 低情商发言就是: 不如 AI. 以后老师不如就给大纲和要点, 让学生问 AI 算了. 随机变量的特征函数 \(\varphi_{X}(t) = E(e^{i t X})\) GPT: 等价于傅里叶变换为频域. \(&lambda;_{n} = E(X^{n}) = i^{-n} \left[ \frac{\mathrm{d}^{n} \varphi_{X}(t)}{\mathrm{d} t^{n}} \right]\) 随机变量的分布 多项式分布 泊松分布 均匀分布 正态分布 多维随机变量及其分布 二维随机变量的分布, 独立性 \(F(x, y) = P(X \leq x &and; Y \leq y)\) 独立性 Definition: \(f(x, y) = f_{X}(x) f_{Y}(y)\) 条件概率分布 二维随机变量的数字特征 协方差 \(\mathrm{cov}(X, Y) = E((X - &mu;_{X})(Y - &mu;_{Y})) = E(XY) - E(X) E(Y)\) 相关系数 \(&rho;_{XY} = \frac{\mathrm{cov}(X, Y)}{&sigma;_{X} &sigma;_{Y}}\) Memonic: \(\mathrm{cov}(X, X) = &sigma;_{X}^{2}\) 协方差矩阵 \(V_{ij} = \mathrm{cov}(X_{i}, X_{j})\) 两个随机变量的函数的分布 多维随机变量, 向量和矩阵记号 随机变量分布 中心极限定理 GPT: 样本量 \(n\) 足够大, 均值分布趋向于正态分布. Application: 二项分布的正态近似 &#8230; 子样及分布 随机子样, 子样分布函数 子样 子样空间 子样分布函数 统计量及其数字特征 子样中位数 子样平均: \(\bar{x} = \frac{1}{n} &sum; x_{i}\) 子样方差: \(S^{2} = \frac{1}{n-1} &sum; (x_{i} - \bar{x})^{2} = \frac{1}{n - 1} \left( (&sum; x_{i}^{2})- n \bar{x}^{2} \right)\) 子样标准值: \(S\) 子样协方差: \(S_{xy} = \frac{1}{n-1} &sum; (x_{i} - x) (y_{i} - y) = \frac{1}{n-1} \left( &sum; x_{i} y_{i} - n \bar{x} \bar{y} \right)\) 子样相关系数: \(&rho;_{xy} = \frac{S_{XY}}{S_{X} S_{Y}} = \frac{&sum; (x_{i} - \bar{x})(y_{i} - \bar{y})}{(&sum; x_{i}^{2} - n \bar{x}^{2} )^{1/2} (&sum; y_{i}^{2} - n \bar{y}^{2})^{1/2}}\) Memonic: 和随机变量一样, 但是平均的项变为 \(1/(n-1)\). Application 根据子样数据计算数字特征 抽样分布 \(&chi;^{2}\) 分布: 总体服从正态分布时, 样本方差与总体方差的比值服从卡方分布 \(t\) 分布: 样本均值于标准误差的比值服从 t 分布 \(F\) 分布: 两个样本方差的比值 Application 已知子样总体, 计算统计量的概率分布 抽样数据的图形表示, 概率分布 参数估计的一般概念 估计量, 似然函数 区间估计 Algorithm: Application: 单正态总体的均值 单正态总体的方差 双正态总体的均值差 正态总体方差的置信区间 Algorithm Application 已知样本总体, 给定置信水平, 计算置信区间 估计对象已知条件置信区间公式 均值 \(&mu;\)\(&sigma;^{2}\) 已知\(\left[ \bar{x} \mp Z_{&alpha;/2} \frac{&sigma;}{\sqrt{n}} \right]\) 均值 \(&mu;\)\(&sigma;^{2}\) 未知\(\left[ \bar{x} \mp t_{&alpha;/2}(n-1) \frac{S}{\sqrt{n}} \right]\) 方差 \(&sigma;^{2}\)\(&mu;\) 未知\(\left[ \frac{(n-1) S^2}{&chi;_{&alpha;/2}^{2}(n-1)}, \frac{(n-1) S^{2}}{&chi;_{1-&alpha;/2}^{2} (n-1)} \right]\) Calculation: \(Z_{&alpha;/2} = &Phi;^{-1}(1 - &alpha;/2)\), where \(&Phi;\) 为 \(N(0, 1)\) 正态分布 \(t_{&alpha;/2}(n)\) 为自由度为 \(n-1\) 的 Student 分布 \(&chi;_{&alpha;/2}^{2}(n)\), where \(&chi;^{2}(n)\) 为自由度为 \(n-1\) 的卡方分布 明明是查表才能知道的东西&#8230; 极大似然法 极大似然原理 Algorithm: 构造函数: \(L(\left\{ x_{i} \right\} | &theta;) = &prod; f(x_{i}|&theta;)\) 极大似然条件约束下求解 \(&theta;\): \(&part;_{&theta;} ln L = 0 &and; &part;_{&theta;}^{2} ln L &lt; 0\) Application: 参数区间估计 (似然区间) Algorithm: \(&gamma; = \frac{&int;_{&theta;_{a}}^{&theta;_{b}} L(X|&theta;) \mathrm{d}&theta;}{&int;_{-&infin;}^{&infin;} L(X|&theta;) \mathrm{d}&theta;}\) 同上, 在 \(&part;_{&theta;} &gamma; = 0 &and; &part;_{&theta;}^{2} &gamma; &lt; 0\) 条件下求解 子样观测值 几何分布 设 \(x_{1}, \cdots, x_{n}\) 是几何分布总体的子样观测值, 其分布律为 \(P(X = x) = p (1 - p)^{x-1}, x = 1, 2, \cdots, &infin;\). 求参数 \(p\) 的极大似然估计. \(L(\left\{ x_{i} \right\} | p) = &prod; p(1-p)^{x-1}\) \(&part;_{p} ln L = &part;_{p} ln \left( p^{n} (1-p)^{&sum; x_{i} - n} \right) = \frac{n - p &sum; x_{i}}{p(1-p)}\) 极大似然法应用于多个实验结果的合并 \(&mu; = \frac{&sum; \frac{&mu;_{i}}{&sigma;_{i}^{2}}}{ &sum; \frac{1}{ &sigma;_{i}^{2 }} } \) \(V = \frac{1}{&sum; \frac{1}{&sigma;_{i}^{2} }}\) 极大似然法用于直方图 最小二乘法 最小二乘拟合 Algorithm: 构造误差函数 \(\mathrm{err}(&theta;) = &sum; (y_{i} - f(x_{i} | &theta;))^{2}\) 最小化误差 \(&part;_{&theta;} \mathrm{err} = 0 &and; &part;_{&theta;}^{2} \mathrm{err} &gt; 0\) 最小二乘用于直方图数据 假设检验 原假设和备择假设 参数检验: 根据观测值检验参数是否等于某个给定值 非参数检验: 根据观测值检验模型函数是否有某个特定函数形式 原假设: 要验证的假设为原假设 备择假设 假设检验的一般方法 Algorithm 原假设和备择假设 (Input) 原假设成立时的统计量 计算统计量观测值 计算拒绝域 判断统计决策 Application 已知正态分布 (子样分布) 和方差 某厂生产的一种电池, 其寿命长期以来服从方差 \(&sigma;^{2} = 5000\ \mathrm{h}^{2}\) 的正态分布. 近期生产一批这种电池, 从生产的情况来看不能肯定寿命方差是否改变. 现随机地取 26 个电池, 测得寿命的样本方差为 \(S^{2} = 9200\ \mathrm{h}^{2}\). 问根据这一数据能否推断这批电池寿命方差较以往有显著变换 (取 \(&alpha; = 0.02\))? 正态总体的参数检验 拟合优度检验 \(&chi;^{2}\) 检验 Definition: \(&chi;^{2} = &sum; \frac{(x_{i} - X)^{2}}{X}\) 似然比检验 信号的统计显著性 贝叶斯公式 Monte Carlo 方法 实际使用过程中, Monte Carlo 方法需要很好地构造随机过程&#8230; 模式识别系统 乐, 只有大段文字, 仿佛在看本科生大学写作课程作业的综述论文. (而且都还很老, 并且不知道为啥, 物理系这边的 AI 课特别喜欢讲 Hopfield 网络, 哪怕他们讲的 Hopfield 网络都不太能用, 或者说不知道该怎么用. ) 理论课的通病 不知道为啥, 讲理论课的老师往往会把定理/算法/规律的严格证明视作是实现的正确性, 好像是只要我证明了我的做法是对的, 那么做的结果就一定是对的. 然后对于如何评价实际结果的正确性的方法几乎不提. 搞清楚课程定位啊淦, 这课不是 物理 中的概率统计吗? 不是实验类的课程吗? 别告诉我说你们实验组有祖传代码拟合分析误差自动生成论文配图, 只需要知道自己的原理是对的是吧&#8230; (当然, 假设检验确实是一个可用的方法, 但是什么叫做假设检验课在证明假设检验是对的? ) 又, 还有的困难是引入的新理论和旧的理论接不上, 有种粘连的感觉. 这有种讲分析力学讲了半天的拉格朗日方程, 结果最后发现用的是牛顿三定律一样的奇怪. 应该就直接抛弃旧的知识, 用新的视角去讲整个 (要么就干脆承认, 说我们不讲新的). 在本科赵爹的课上的那个做法就很不错, 用新的视角去引入 (上来就是对称性守恒律, 相信基础教育的牛顿三定律的普及教育, 而不是重新教一遍牛顿三定律再开始讲能量视角), 然后在打好了新的视角的基础之后, 再回过头去审视旧的理论如何迁移到新的视角里. 比如在概统的这边, 我觉得确实可以用测度空间的方法来解释很多东西, 然后再回过头去讲其他东西, 就会很不错. 不过可能也要看具体的应用或者教学需求, 用测度论来讲实验误差分析的话, 感觉不是很好理解 (也有可能只是我不会, 之后可以重新学), 但是如果直接从实验误差为主线来重新讲课, 那估计就能够砍掉很多的垃圾学时, 并且还能更有条理&#8230; 特征提取和选择 效率, 误判率, 分辨能力 效率: 正确选定一个信号事例的效率 \(&epsilon;_{SS} = &int; f_{S}(y) \mathrm{d}y\) 误判率: 将本底错误选择为一个信号事例的误判率 \(&epsilon;_{SB} = &int; f_{B}(y) \mathrm{d}y\) 误判率: 效率与误判率的比 \(r = &epsilon;_{SS} / &epsilon;_{SB}\) Memonic: 引入误差矩阵 判断 \ 实际真假 真真真真假 假假真假假 效率: 真真 / (真真 + 假真) 误判率: 真假 / (真假 + 假假) 方差: \(V(&epsilon;_{SS}) = \frac{&epsilon;_{SS} (1 - &epsilon;_{SS})}{N_{S}}\) \(V(r)/r^{2} = V(&epsilon;_{SS}) / &epsilon;_{SS}^{2} + V(&epsilon;_{SB}) / &epsilon;_{SB}^{2}\) 方法 贝叶斯决策 线性判别 决策树方法 人工神经网络 近邻法 概率密度估计量方法 H 矩阵判别 函数判别 SVM 小信号测量的区间估计 测量误差及其分类 和子样误差放在一起 课上把测量误差和子样误差分开来讲了, 实际上我觉得这两个东西应当放在一起讲, 毕竟这两个才是真的相关的知识, 也是在实验里真的用的东西. 明明可以用一个实验数据的采集的全流程来讲随机子样, 子样分布函数这些知识, 非要用概念朗诵, 鼠标扫扫公式 &#8211; 大家要记住哦, 很重要哦, 这种方式来教课&#8230; 不过也可以理解就是了 &#8211; who cares? Application: 误差传递公式 探测器效率计算: 实际计数 / 源计数 Application: 多层符合探测效率 m 层中至少 k 触发: \(&epsilon;_{\mathrm{tol}} = &sum; \left(\begin{matrix}m &#92;&#92; k\end{matrix}\right) &epsilon;^{i} (1 - &epsilon;)^{m-i}\)]]></summary></entry><entry><title type="html">Image Processing</title><link href="/notes/image/" rel="alternate" type="text/html" title="Image Processing" /><published>2026-01-03T00:00:00+00:00</published><updated>2026-01-03T00:00:00+00:00</updated><id>/notes/image</id><content type="html" xml:base="/notes/image/"><![CDATA[<h1>About</h1>
<p>这是数字图像处理的笔记.</p>
<p>和作业一样, 这里采用 <a href="https://github.com/li-yiyang/mlx-cl">mlx-cl</a> 来实现一些简单的算法和说明.</p>
<details><summary>简单的准备工作</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defpackage</span><span class="w"> </span><span class="kd">#:blog</span><span class="o">.</span><span class="nv">notes</span><span class="o">.</span><span class="nv">image</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:use</span><span class="w"> </span><span class="nv">:mlx-cl</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:local-nicknames</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:fft</span><span class="w"> </span><span class="nv">:mlx-cl</span><span class="o">.</span><span class="nv">fft</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:la</span><span class="w">  </span><span class="nv">:mlx-cl</span><span class="o">.</span><span class="nv">linalg</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">in-package</span><span class="w"> </span><span class="nv">:blog</span><span class="o">.</span><span class="nv">notes</span><span class="o">.</span><span class="nv">image</span><span class="p">)</span>
</pre></div>
</details>
<h1>图像的基础</h1>
<h2>图像格式示例</h2>
<ul>
  <li>PBM/PGM/PPM
    <ul>
      <li>mlx-cl/io/ppm</li>
    </ul>
  </li>
  <li>TIFF (<a href="https://li-yiyang.github.io/mlx-cl/io/tiff/">mlx-cl/io/tiff</a>)
    <p>实际上作业里面大部分用的是这种格式, 虽然并不知道为啥&#8230;</p>
  </li>
  <li>JPEG (<a href="https://li-yiyang.github.io/mlx-cl/io/jpeg/">mlx-cl/io/jpeg</a>)</li>
  <li>PNG (<a href="https://li-yiyang.github.io/mlx-cl/io/png/">mlx-cl/io/png</a>)</li>
</ul>
<details><summary>一些不算遗憾的遗憾</summary>
<p>本来为了性能, 应该让针对 MLX 专门编写一些优化后的文件读取函数,
  但是因为没有很多的时间, 所以现在的做法是用已有的库把数据读到 Lisp 中,
  再读到 MLX 中, 有两道转换的过程, 存在一些性能的损失.</p>
</details>
<p>下文中的处理, 都是基于如下的假设:
  图像是形如 <code>(H W C)</code> 的张量 (宽 <code>W</code>, 高 <code>H</code>, 有 <code>C</code> 个色彩通道).</p>
<p>分辨率:</p>
<ul>
  <li>空间分辨率: <code>H</code>, <code>W</code></li>
  <li>灰度分辨率: <code>dtype</code></li>
</ul>
<h3>奇异值分解</h3>
<ul>
  <li>特征值分解 \(A = P D P^{-1}\)</li>
  <li>奇异值分解 \(A = U &Sigma; V^{\mathrm{T}}\)</li>
</ul>
<h2>图像色彩空间</h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">as-colorspace</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">convert</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nv">convert</span><span class="w"> </span><span class="p">(</span><span class="nf">channels-list</span><span class="w"> </span><span class="nv">image</span><span class="p">)))</span>
</pre></div>
<details><summary>一些函数的实现</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">channels</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">len</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">channels-list</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">split</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="p">(</span><span class="nf">channels</span><span class="w"> </span><span class="nv">image</span><span class="p">)</span><span class="w"> </span><span class="nv">:axis</span><span class="w"> </span><span class="mi">-1</span><span class="p">))</span>
</pre></div>
</details>
<ul>
  <li>RGB</li>
  <li>CMYK</li>
  <li>HSV</li>
</ul>
<h2>图像噪声模型</h2>
<ul>
  <li>加性噪声</li>
  <li>乘性噪声</li>
  <li>高斯噪声</li>
  <li>椒盐噪声</li>
  <li>泊松噪声</li>
</ul>
<h1>图像变换与滤波</h1>
<h2>傅里叶变换</h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">dft2d</span><span class="w"> </span><span class="p">(</span><span class="nf">img</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;2D FFT transform on IMG.</span>
<span class="s">Return a FFT grayscale spectrum image.</span>

<span class="s">Parameters:</span>
<span class="s">+ IMG is a grayscale image</span>

<span class="s">Algorithm:</span>
<span class="s">1. row 1-D FFT</span>
<span class="s">2. col 1-D FFT</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">-&gt;*</span><span class="w"> </span><span class="nv">img</span>
<span class="w">    </span><span class="p">(</span><span class="nf">fft:1dfft</span><span class="w"> </span><span class="nv">:axis</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">                 </span><span class="c1">; Row: axis=1</span>
<span class="w">    </span><span class="p">(</span><span class="nf">fft:1dfft</span><span class="w"> </span><span class="nv">:axis</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">               </span><span class="c1">; Col: axis=0</span>
</pre></div>
<p>没什么, 大家都爱 FFT. 相当于是提供了另一种视角: 空间域不好做就从频域去做.</p>
<p>频率域滤波:</p>
<ul>
  <li>给定图像 \(f(x, y)\) 计算 2D-DFT \(F(u, v)\)</li>
  <li>在频率域构建滤波器 \(H(u, v) &rArr; G(u, v) = H(u, v) F(u, v)\)</li>
  <li>通过逆变换得到 \(g(x, y)\)</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">image-freq-filter</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nb">filter</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">-&gt;*</span><span class="w"> </span><span class="p">(</span><span class="nf">dft2d</span><span class="w"> </span><span class="nv">image</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">gen-filter</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="nb">filter</span><span class="p">))</span>
<span class="w">    </span><span class="nv">dft2d</span>
<span class="w">    </span><span class="p">(</span><span class="nf">as-dtype</span><span class="w"> </span><span class="p">(</span><span class="nf">dtype</span><span class="w"> </span><span class="nv">image</span><span class="p">))))</span>
</pre></div>
<details><summary>一些辅助函数</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">uniformed-coord</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="nv">cornerp</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">cornerp</span>
<span class="w">      </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">h</span><span class="w"> </span><span class="nv">w</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">rest</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">shape</span><span class="w"> </span><span class="nv">image</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">rest</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">meshgrid</span><span class="w"> </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">w</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">h</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">h</span><span class="w"> </span><span class="nv">w</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">rest</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">shape</span><span class="w"> </span><span class="nv">image</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">rest</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">h/2</span><span class="w">  </span><span class="p">(</span><span class="nb">floor</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nf">w/2</span><span class="w">  </span><span class="p">(</span><span class="nb">floor</span><span class="w"> </span><span class="nv">w</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nf">xR</span><span class="w">   </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="nv">w/2</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nf">xL</span><span class="w">   </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">w</span><span class="w"> </span><span class="nv">w/2</span><span class="p">)))</span>
<span class="w">               </span><span class="p">(</span><span class="nf">yB</span><span class="w">   </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="nv">h/2</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nf">yT</span><span class="w">   </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="nv">h/2</span><span class="p">))))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">tl</span><span class="w"> </span><span class="nv">tr</span><span class="w"> </span><span class="nv">bl</span><span class="w"> </span><span class="nv">br</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">concat</span><span class="w"> </span><span class="p">(</span><span class="nf">concat</span><span class="w"> </span><span class="nv">tl</span><span class="w"> </span><span class="nv">tr</span><span class="w"> </span><span class="nv">:axis</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">                            </span><span class="p">(</span><span class="nf">concat</span><span class="w"> </span><span class="nv">bl</span><span class="w"> </span><span class="nv">br</span><span class="w"> </span><span class="nv">:axis</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">meshgrid</span><span class="w"> </span><span class="nv">xL</span><span class="w"> </span><span class="nv">yT</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">meshgrid</span><span class="w"> </span><span class="nv">xR</span><span class="w"> </span><span class="nv">yT</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">meshgrid</span><span class="w"> </span><span class="nv">xL</span><span class="w"> </span><span class="nv">yB</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">meshgrid</span><span class="w"> </span><span class="nv">xR</span><span class="w"> </span><span class="nv">yB</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">gen-filter</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">filter-function</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nv">filter-function</span><span class="w"> </span><span class="p">(</span><span class="nf">uniformed-coord</span><span class="w"> </span><span class="nv">image</span><span class="p">)))</span>
</pre></div>
</details>
<p>不过如果用另外一种视角来看:</p>
<p>用图像的正交空间, 即将图片看作是在正交基上的分解, 在傅里叶变换的时候,
  相当于是分解到三角函数基, 同时也可以换成别的基.</p>
<ul>
  <li>Walsh-Hadamard 变换</li>
  <li>Slant 斜变换</li>
  <li>Haar 变换</li>
</ul>
<h2>卷积</h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">2d-conv</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">weight</span><span class="w"> </span><span class="nv">&amp;key</span><span class="w"> </span><span class="p">(</span><span class="nf">padding</span><span class="w"> </span><span class="nv">:zero</span><span class="p">)</span>
<span class="w">                </span><span class="nv">&amp;aux</span><span class="w"> </span><span class="p">(</span><span class="nf">mode</span><span class="w"> </span><span class="p">(</span><span class="nf">ecase</span><span class="w"> </span><span class="nv">padding</span>
<span class="w">                             </span><span class="p">(</span><span class="nf">:zero</span><span class="w">      </span><span class="nv">:const</span><span class="p">)</span>
<span class="w">                             </span><span class="p">(</span><span class="nf">:replicate</span><span class="w"> </span><span class="nv">:edge</span><span class="p">))))</span>
<span class="w">  </span><span class="s">&quot;Conv kernel W on IMAGE.</span>

<span class="s">Parameters:</span>
<span class="s">+ IMAGE: input `image&#39;</span>
<span class="s">+ W: rectangle conv kernel</span>
<span class="s">+ PADDING: padding mode:</span>
<span class="s">  + `:zero&#39;: fill padding with zeros</span>
<span class="s">  + `:replicate&#39;: copy edge pixels</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">h</span><span class="w"> </span><span class="nv">w</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">shape</span><span class="w"> </span><span class="nv">weight</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">img</span><span class="w"> </span><span class="p">(</span><span class="nf">pad</span><span class="w"> </span><span class="nv">image</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:floor</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">cl:floor</span><span class="w"> </span><span class="nv">w</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span>
<span class="w">                    </span><span class="c1">;; :fill 0</span>
<span class="w">                    </span><span class="nv">:mode</span><span class="w"> </span><span class="nv">mode</span><span class="p">)))</span>
<span class="w">      </span><span class="c1">;; mlx:2dconv need input (N H W C) array input</span>
<span class="w">      </span><span class="c1">;; and weight as (C_out KH KW C_in)</span>
<span class="w">      </span><span class="c1">;; output is (C_out H W C), squeeze the first axis</span>
<span class="w">      </span><span class="p">(</span><span class="nf">-&gt;*</span><span class="w"> </span><span class="p">(</span><span class="nf">2dconv</span><span class="w"> </span><span class="p">(</span><span class="nf">as-dtype</span><span class="w"> </span><span class="p">(</span><span class="nf">expand-dims</span><span class="w"> </span><span class="nv">img</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">      </span><span class="nv">:float32</span><span class="p">)</span><span class="w"> </span><span class="c1">; N = 1</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">as-dtype</span><span class="w"> </span><span class="p">(</span><span class="nf">expand-dims</span><span class="w"> </span><span class="nv">weight</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="nv">:float32</span><span class="p">)</span><span class="w"> </span><span class="c1">; dim=2</span>
<span class="w">                   </span><span class="nv">:padding</span><span class="w"> </span><span class="mi">0</span>
<span class="w">                   </span><span class="nv">:stride</span><span class="w">  </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">squeeze</span><span class="w">  </span><span class="nv">:axis</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">as-dtype</span><span class="w"> </span><span class="p">(</span><span class="nf">dtype</span><span class="w"> </span><span class="nv">img</span><span class="p">))))))</span>
</pre></div>
<p>感觉卷积并没有什么很高大上的数学意义&#8230; 只是个乘法&#8230;</p>
<p>不过其实要看具体在什么情况下使用, 比如:
  把滤波系统看作是线性系统:</p>
<p>\[\mathrm{image} \xrightarrow{f(x, y)} \fbox{w(x, y)} \xrightarrow{g(x, y)} \mathrm{output}\]</p>
<p>即: \(g(x, y) = w(x, y) &otimes; f(x, y)\), 放到频率域上即 \(G(u, v) = W(u, v) &sdot; F(u, v)\).</p>
<p>不过这么讲也没啥意义, 纯纯数学概念 show-off 罢了.</p>
<p>如果结合具体例子来看:</p>
<ul>
  <li>对于均值滤波器
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">mean-filter-weight</span><span class="w"> </span><span class="p">(</span><span class="nf">size</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">unify</span><span class="w"> </span><span class="p">(</span><span class="nf">ones</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="nv">size</span><span class="p">))))</span>
</pre></div>
  <details><summary>一些辅助函数</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">unify</span><span class="w"> </span><span class="p">(</span><span class="nf">matrix</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">-&gt;*</span><span class="w"> </span><span class="p">(</span><span class="nf">as-dtype</span><span class="w"> </span><span class="nv">matrix</span><span class="w"> </span><span class="nv">:float32</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">sum</span><span class="w"> </span><span class="nb">*</span><span class="p">))))</span>
</pre></div>
  </details>
    <p>比如说 <code>(mean-filter-weight 3)</code> 是一个 \(3 &times; 3\) 的矩阵.
      或者也可以写作:</p>
    <p>\[\mathrm{pix}(x, y) = (\mathrm{pix}(x - 1, y) + \mathrm{pix}(x + 1, y) + \cdots ) / 9\]</p>
    <p>可以解释为对周围的 pixel 求和后平均 &#8211; 从空间域上的理解.</p>
  </li>
  <li>理想低通滤波器
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">make-circle-mask</span><span class="w"> </span><span class="p">(</span><span class="nf">thres</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">where</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">sqrt</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mf">0.5</span><span class="p">))</span>
<span class="w">                       </span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="mf">0.5</span><span class="p">))))</span>
<span class="w">              </span><span class="nv">thres</span><span class="p">)</span>
<span class="w">           </span><span class="nv">t</span>
<span class="w">           </span><span class="nv">nil</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">ideal-low-pass-filter</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">thres</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">image-freq-filter</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="p">(</span><span class="nf">make-circle-mask</span><span class="w"> </span><span class="nv">thres</span><span class="p">)))</span>
</pre></div>
    <p>矩形函数的 FFT 变换存在一堆小波, 所以在频率域上的矩形函数 (理想低通函数)
      会导致在空间域上的波纹状.</p>
  </li>
  <li>对于高斯滤波器
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">gauss-filter-weight</span><span class="w"> </span><span class="p">(</span><span class="nf">sigma</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">m</span><span class="w"> </span><span class="nv">nil</span><span class="p">)</span>
<span class="w">                            </span><span class="nv">&amp;aux</span>
<span class="w">                              </span><span class="p">(</span><span class="nf">m-min</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:ceiling</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nv">sigma</span><span class="p">)))))</span>
<span class="w">                              </span><span class="p">(</span><span class="nf">m-val</span><span class="w"> </span><span class="p">(</span><span class="nf">the</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nv">null</span><span class="w"> </span><span class="p">(</span><span class="nf">integer</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">m-min</span><span class="p">))))</span>
<span class="w">  </span><span class="s">&quot;Return a Gauss kernel matrix.</span>

<span class="s">Definition:</span>

<span class="s">    gauss(x, y) = exp(- (x^2 + y^2) / (2 * sigma^2)) / (2 * pi * sigma^2)</span>

<span class="s">Parameters:</span>
<span class="s">+ SIGMA: std of Gauss function (&gt; 0)</span>
<span class="s">+ M: size of kernel, by default it&#39;s determined by SIGMA:</span>

<span class="s">  m = 1 + 2 * ceiling(3 * sigma)</span>

<span class="s">  if given M is lower than above value, a warning would be throw</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:&lt;</span><span class="w"> </span><span class="nv">m-val</span><span class="w"> </span><span class="nv">m-min</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">warn</span><span class="w"> </span><span class="s">&quot;Given m=~A is lower than m_min=~A. &quot;</span><span class="w"> </span><span class="nv">m-val</span><span class="w"> </span><span class="nv">m-min</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">half</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:/</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">m-val</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">meshgrid</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">arange</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:-</span><span class="w"> </span><span class="nv">half</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">half</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">arange</span><span class="w"> </span><span class="p">(</span><span class="nf">cl:-</span><span class="w"> </span><span class="nv">half</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">half</span><span class="p">))))</span>
<span class="w">      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">ker</span><span class="w"> </span><span class="p">(</span><span class="nb">exp</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="nv">y</span><span class="p">))</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="nv">sigma</span><span class="p">)))))))</span>
<span class="w">        </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="nv">ker</span><span class="w"> </span><span class="p">(</span><span class="nf">sum</span><span class="w"> </span><span class="nv">ker</span><span class="p">))))))</span>
</pre></div>
    <p>在空间域上: 看作是一种按位置 (距离) 的加权平均, 越是远离的影响权重越小,
      越是靠近的影响权重越大. 差不多是这样的.</p>
    <p>在频率域上: 邻近的频率的影响也一样&#8230; 差不多一样的加权平均.</p>
  </li>
  <li>图像的导数</li>
  <li>Laplacian 算子</li>
  <li>Roberts 算子</li>
  <li>Sobel 算子</li>
  <li>Prewitt 算子</li>
  <li>Scharr 算子</li>
  <li>距离变换</li>
  <li>高斯低通滤波器 (GLPF)</li>
  <li>巴特沃斯低通滤波器 (BLPF)</li>
  <li>IHPF</li>
  <li>GHPF</li>
  <li>BHPF</li>
  <li>带阻滤波器</li>
</ul>
<h1>图像的统计描述</h1>
<h1>图像增强</h1>
<h2>空间域</h2>
<h3>点处理</h3>
<ul>
  <li>输出 \(g(x, y)\) 仅和输入 \(f(x, y)\) 有关 \(g(x, y) = &phi;(f(x, y))\)</li>
  <li>灰度变换
    <ul>
      <li>线性灰度变换
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">gray-image-unify</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">&amp;key</span><span class="w"> </span><span class="p">(</span><span class="nb">min</span><span class="w"> </span><span class="p">(</span><span class="nf">minimum</span><span class="w"> </span><span class="nv">image</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nf">maximum</span><span class="w"> </span><span class="nv">image</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="nb">min</span><span class="p">)</span>
<span class="w">     </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="nb">min</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">linear-gray-rescale</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nb">min</span><span class="w"> </span><span class="nb">max</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">-&gt;*</span><span class="w"> </span><span class="p">(</span><span class="nf">gray-image-unify</span><span class="w"> </span><span class="nv">image</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="nb">min</span><span class="p">)</span><span class="w"> </span><span class="nb">*</span><span class="p">)</span><span class="w"> </span><span class="nb">min</span><span class="p">)))</span>
</pre></div>
      </li>
      <li>分段线性变换</li>
      <li>对数变换
        <p>\[g(x, y) = a + \frac{\mathrm{ln}\left[ f(x, y) + 1 \right]}{b &sdot; \mathrm{ln}(c)}\]</p>
        <p>压缩高灰度区, 拉伸低灰度区</p>
      </li>
      <li>指数变换
        <p>\[g(x, y) = b^{c \left[ f(x, y) - a \right]} - 1\]</p>
        <p>拉伸高灰度区</p>
      </li>
      <li>伽马变换</li>
    </ul>
  </li>
  <li>直方图
    <ul>
      <li>直方图均衡化</li>
    </ul>
  </li>
  <li>图像平滑
    <ul>
      <li>均值平滑
        <p>如名, 略.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">unify-smooth</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">size</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">2d-conv</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="p">(</span><span class="nf">full</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="nv">size</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="nv">size</span><span class="p">))</span>
<span class="w">                       </span><span class="nv">:dtype</span><span class="w"> </span><span class="nv">:float32</span><span class="p">)))</span>
</pre></div>
      </li>
      <li>超限像素平滑
        <p>在均值平滑的基础上, 只在均值和像素值差特别多的情况下才应用均值平均.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">threshold-unify-smooth</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">thres</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">size</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">smooth</span><span class="w"> </span><span class="p">(</span><span class="nf">unify-smooth</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="nv">size</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">where</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="nv">smooth</span><span class="p">))</span><span class="w"> </span><span class="nv">thres</span><span class="p">)</span>
<span class="w">           </span><span class="nv">smooth</span>
<span class="w">           </span><span class="nv">image</span><span class="p">)))</span>
</pre></div>
      </li>
      <li>K-mean 平均
        <p>用窗口内和中心像素最接近的 K 个邻近像素的平均灰度表示</p>
      </li>
      <li>最大均匀性平滑
        <p>环绕图像中每个像素的最均匀的区域, 用灰度均值代替原来的灰度值</p>
      </li>
      <li>有选择保留边缘平滑法</li>
      <li>空间低通滤波
        <ul>
          <li>\(H_{1} = \frac{1}{9} \left(\begin{matrix} 1 &amp; 1 &amp; 1 &#92;&#92; 1 &amp; 1 &amp; 1 &#92;&#92; 1 &amp; 1 &amp; 1 \end{matrix}\right)\)</li>
          <li>\(H_{2} = \frac{1}{10} \left(\begin{matrix} 1 &amp; 1 &amp; 1 &#92;&#92; 1 &amp; 2 &amp; 1 &#92;&#92; 1 &amp; 1 &amp; 1 \end{matrix}\right)\)</li>
          <li>\(H_{3} = \frac{1}{16} \left(\begin{matrix}1 &amp; 2 &amp; 1 &#92;&#92; 2 &amp; 4 &amp; 2 &#92;&#92; 1 &amp; 2 &amp; 1 \end{matrix}\right)\)</li>
          <li>\(H_{4} = \frac{1}{8} \left(\begin{matrix}1 &amp; 1 &amp; 1 &#92;&#92; 1 &amp; 0 &amp; 1 &#92;&#92; 1 &amp; 1 &amp; 1 \end{matrix}\right)\)</li>
          <li>\(H_{5} = \frac{1}{2} \left(\begin{matrix}0 &amp; \frac{1}{4} &amp; 0 &#92;&#92; \frac{1}{4} &amp; 1 &amp; \frac{1}{4} &#92;&#92; 0 &amp; \frac{1}{4} &amp; 0 \end{matrix}\right)\)</li>
        </ul>
      </li>
      <li>中值滤波
        <p>对窗口中的像素灰度排序, 然后用中值代替原来的灰度值.
          不适合点, 线等细节较多的图像.</p>
    <details><summary>实现思路</summary>
        <p>没时间了, 这里给一个实现思路:</p>
        <ol>
          <li>构造 padding 后的图像</li>
          <li>将图像进行 offset 后按像素值排序</li>
          <li>取中值得到最后的图像</li>
        </ol>
    </details>
      </li>
    </ul>
  </li>
  <li>图像锐化
    <ul>
      <li>梯度锐化</li>
      <li>Laplacian 增强算子</li>
      <li>高通滤波法
        <p>用高通滤波算子和图像卷积增强边缘</p>
        <ul>
          <li>\(H_{1} = \left(\begin{matrix}0 &amp; -1 &amp; 0 &#92;&#92; -1 &amp; 5 &amp; -1 &#92;&#92; 0 &amp; -1 &amp; 0\end{matrix}\right)\)</li>
          <li>\(H_{2} = \left(\begin{matrix}-1 &amp; -1 &amp; -1 &#92;&#92; -1 &amp; 9 &amp; -1 &#92;&#92; -1 &amp; -1 &amp; -1\end{matrix}\right)\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2>频率域</h2>
<h2>色彩增强</h2>
<h3>伪彩色</h3>
<ul>
  <li>密度分割法
    <p>按图像灰度级别将图像分成几个区间, 每个区间变成伪彩色图像</p>
  </li>
  <li>频率域伪彩色增强
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">gray-to-rgb-freq-filter</span><span class="w"> </span><span class="p">(</span><span class="nf">image</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nv">b</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">-&gt;*</span><span class="w"> </span><span class="p">(</span><span class="nf">dft2d</span><span class="w"> </span><span class="nv">image</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">concat</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="nb">*</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nb">*</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nb">*</span><span class="p">)</span>
<span class="w">            </span><span class="nv">:axis</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="nv">dft2d</span>
<span class="w">    </span><span class="p">(</span><span class="nf">as-dtype</span><span class="w"> </span><span class="p">(</span><span class="nf">dtype</span><span class="w"> </span><span class="nv">image</span><span class="p">))))</span>
</pre></div>
  </li>
</ul>
<h3>彩色图像</h3>
<ul>
  <li>假彩色增强</li>
  <li>HIS 增强
    <ul>
      <li>RGB \(&rarr;\) IHS</li>
      <li>对 IHS 通道应用灰度增强</li>
      <li>重新变换回 RGB</li>
    </ul>
  </li>
</ul>
<h2>图像代数运算</h2>
<h1>图像统计描述</h1>
<h1>图像的形态学处理</h1>
<h1>图像的分割与边缘检测</h1>
<h1>小波变换初步及应用</h1>
<h1>图像复原与重建</h1>
<ul>
  <li>图像的复原是根据图像退化的数学模型为基础的客观图像复原</li>
  <li>数学描述:
    <p>在空间域上, 退化模型可以看作是加性噪声 (\(n(x, y)\))
      和退化函数 (\(h(x, y)\)) 作用在原始图像 (\(i(x, y)\)) 上的:</p>
    <p>\[d(x, y) = h(x, y) * i(x, y) + n(x, y)\]</p>
    <p>或者是在频率域上</p>
    <p>\[D(u, v) = H(u, v) I(u, v) + N(u, v)\]</p>
  </li>
</ul>
<h2>图像去噪</h2>
<ul>
  <li>噪声模型
    <p>使用噪声直方分布描述噪声模型</p>
    <ul>
      <li>高斯噪声
        <p>\[\mathrm{gauss} = \frac{1}{\sqrt{2 &pi; &sigma;^{2}}} \mathrm{e}^{-(g-m)^{2} / 2 &sigma;^{2}}\]</p>
      </li>
      <li>均匀噪声
        <p>\[\mathrm{uniform} = \frac{1}{b - a}\ \mathrm{iff}\ a \leq x \leq b\]</p>
      </li>
      <li>椒盐噪声</li>
      <li>瑞利噪声
        <p>例: 雷达测距和测速噪声</p>
        <p>\[\mathrm{rayleigh} = \frac{2 x}{&alpha;} \mathrm{e}^{-x^{2} / &alpha;}\]</p>
      </li>
      <li>负指数噪声
        <p>例: 激光图像</p>
        <p>\[\mathrm{neg\ exp} = \frac{\mathrm{e}^{-x/&alpha;}}{&alpha;}\]</p>
      </li>
      <li>爱尔兰 (伽马) 噪声
        <p>\[\mathrm{gamma} = \frac{x^{&alpha;-1}}{(&alpha; - 1)! a^{&alpha;}} \mathrm{e}^{- x / a}\]</p>
      </li>
      <li>周期噪声
        <p>常见产生于干扰, 在频域表现为脉冲信号, 通过带阻滤波器或陷波滤波器去除</p>
      </li>
    </ul>
  </li>
  <li>噪声估计
    <p>无纯噪声图像: 选择图像中已知直方图的一部分, 通过减去已知直方图的方式获得噪声模型</p>
  </li>
  <li>去噪声
    <p>只存在加性噪声的情况下, 可以:</p>
    <ul>
      <li>空间滤波器
        <ul>
          <li>排序滤波</li>
          <li>均值滤波
            <p>在窗口中排序并选择第 \(k\) 大的数, 比如:</p>
            <ul>
              <li>中值排序滤波
                <ul>
                  <li>迭代中值滤波器
                    <p>依次采用窗口不断增大的中值滤波器</p>
                  </li>
                  <li>混合中值滤波器
                    <p>对对角线, 边缘分别中值滤波, 然后对这些中值进行中值滤波</p>
                  </li>
                </ul>
              </li>
              <li>最大值最小值滤波</li>
              <li>中点滤波: 最大值和最小值的平均</li>
              <li>alpha-trimmed mean: 排除端点值的均值
                <p>适合高斯噪声和椒盐噪声</p>
              </li>
            </ul>
          </li>
          <li>几何均值滤波
            <p>\[\mathrm{geo\ mean} = &prod; \left[ i(x, y) \right]^{1/N^{2}}\]</p>
            <p>其中 \(N\) 为窗口大小</p>
          </li>
          <li>谐波均值滤波器
            <p>\[\mathrm{harmonic\ mean} = \frac{N^{2}}{&sum; \frac{1}{i(x, y)}}\]</p>
          </li>
          <li>反谐波均值滤波器
            <p>\[\mathrm{contraharmonic\ mean} = \frac{&sum; i(x, y)^{R+1}}{&sum; i(x, y)^{R}}\]</p>
          </li>
          <li>最小均方差 (MMSE)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2>退化函数频率域复原滤波</h2>
<ul>
  <li>PSF: 点扩散函数</li>
  <li>退化函数估计
    <ul>
      <li>数学建模法</li>
      <li>&#8230;</li>
    </ul>
  </li>
  <li>退化图像还原
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">wiener-filtering</span><span class="w"> </span><span class="p">(</span><span class="nf">img</span><span class="w"> </span><span class="nv">psf</span><span class="w"> </span><span class="nv">gamma</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Image restoration via Wiener Filtering.</span>
<span class="s">Return restored IMG by applying PSF on IMG with noise-signal power ratio GAMMA.</span>

<span class="s">Parameter:</span>
<span class="s">+ IMG: initial `image&#39; object</span>
<span class="s">+ PSF: Point Spread Function</span>
<span class="s">  (funcall psf X Y) should return point spread function on X and Y</span>
<span class="s">+ GAMMA: noise / signal power ratio</span>

<span class="s">Definition:</span>

<span class="s">  let H = dft2d(make-psf-kernel(PSF, IMG))</span>

<span class="s">        conjugate(H)</span>
<span class="s">  R = -------------------            (Wiener Filtering)</span>
<span class="s">       norm(H)^2 + gamma</span>

<span class="s">  res = idft2d(fft2d(IMG) * R)</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nf">function</span><span class="w"> </span><span class="p">(</span><span class="nf">t</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span><span class="w"> </span><span class="nv">psf</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nf">real</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="nv">gamma</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">g</span><span class="w"> </span><span class="p">(</span><span class="nf">dft2d</span><span class="w"> </span><span class="nv">img</span><span class="p">))</span>
<span class="w">         </span><span class="c1">;; h should be (H W 1)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">h</span><span class="w"> </span><span class="p">(</span><span class="nf">dft2d</span><span class="w"> </span><span class="p">(</span><span class="nf">expand-dims</span><span class="w"> </span><span class="p">(</span><span class="nf">make-psf-kernel</span><span class="w"> </span><span class="nv">psf</span><span class="w"> </span><span class="nv">img</span><span class="p">)</span><span class="w"> </span><span class="mi">-1</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">r</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nf">conjugate</span><span class="w"> </span><span class="nv">h</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">square</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="nv">h</span><span class="p">))</span><span class="w"> </span><span class="nv">gamma</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">corner-centered</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="w"> </span><span class="p">(</span><span class="nf">idft2d</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="nv">r</span><span class="p">))))))</span>
</pre></div>
  <details><summary>一些辅助函数</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">make-psf-kernel</span><span class="w"> </span><span class="p">(</span><span class="nf">psf</span><span class="w"> </span><span class="nv">img</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Make PSF Kernel Matrix with shape of IMG.</span>
<span class="s">Return a new Kernel Matrix of shape (H W) from IMG.</span>

<span class="s">Parameters:</span>
<span class="s">+ PSF: Point Spread Function</span>
<span class="s">  (funcall psf X Y) should return element-wise PSF on X and Y</span>
<span class="s">  X, Y are unified into [-1, 1]</span>
<span class="s">+ IMG: an `image&#39; whose shape would be used to calculate PSF kernel</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nf">function</span><span class="w"> </span><span class="p">(</span><span class="nf">t</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span><span class="w"> </span><span class="nv">psf</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">image</span><span class="w"> </span><span class="nv">img</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">ny</span><span class="w"> </span><span class="nv">nx</span><span class="w"> </span><span class="nv">&amp;rest</span><span class="w"> </span><span class="nv">ignore</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">shape</span><span class="w"> </span><span class="nv">img</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">ignore</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">meshgrid</span><span class="w"> </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">nx</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">linspace</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">ny</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">funcall</span><span class="w"> </span><span class="nv">psf</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">))))</span>
</pre></div>
  </details>
  </li>
</ul>
<h1>图像压缩</h1>
<h2>术语</h2>
<ul>
  <li>压缩率: 原始图像大小/压缩后图像大小</li>
  <li>每像素比特率 (bpp): 图像大小 (bits) / 图像比特数 (pixels)</li>
  <li>冗余
    <ul>
      <li>编码冗余</li>
      <li>像素间冗余: 相邻像素重复</li>
      <li>波段间冗余: 色彩波段</li>
      <li>心理视觉冗余: 人看不出来</li>
    </ul>
  </li>
  <li>保真度
    <ul>
      <li>客观保真度
        <ul>
          <li>均方根误差 \(e_{\mathrm{RMS}} = \sqrt{\frac{1}{N^{2}} &sum; \left[ \hat{i} - i \right]}\)</li>
          <li>均方根信噪比 \(\mathrm{SNR}_{\mathrm{RMS}} = \sqrt{\frac{&sum; \hat{i}^{2} }{&sum; (\hat{i} - i)^{2} }}\)</li>
          <li>峰值信噪比 \(\mathrm{SNR}_{\mathrm{PEAK}} = 10 log_{10} \frac{(L - 1)^{2} }{\frac{1}{N^{2}} &sum; (\hat{i} - i)^{2}}\) (越高越好)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2>无损压缩</h2>
<ul>
  <li>霍夫曼编码
    <ol>
      <li>计算直方图得到灰度概率</li>
      <li>按概率从小到大排序</li>
      <li>合并最小两个</li>
      <li>递归生成树</li>
      <li>用数进行编码</li>
    </ol>
  </li>
  <li>哥伦布编码</li>
  <li>行程编码
    <ul>
      <li>(长度 数据)</li>
    </ul>
  </li>
  <li>LZW 编码</li>
  <li>算术编码</li>
</ul>
<h2>有损压缩</h2>
<ul>
  <li>灰度编码
    <p>减少灰度级别后应用行程编码</p>
  </li>
  <li>块截断编码
    <p>将图像分成多个小块, 然后对每个小块进行灰度编码</p>
  </li>
  <li>向量编码</li>
  <li>差分预测编码</li>
  <li>变换编码</li>
  <li>混合编码</li>
</ul>
<h1>边, 线, 形状检测</h1>
<h2>边缘检测</h2>
<ul>
  <li>类似于微分算子, 检测图像亮度剧烈变换的边缘</li>
  <li>梯度算子
    <p>利用灰度函数的一阶或二阶导数作为边缘检测</p>
  </li>
  <li>罗盘掩码
    <p>使用单个掩码将其旋转到指南针的八个主要方向</p>
    <ul>
      <li>Kirsch 罗盘掩码
        <ul>
          <li>\(k_{0} \left(\begin{matrix} -3 &amp; -3 &amp; 5 &#92;&#92; -3 &amp; 0 &amp; 5 &#92;&#92; -3 &amp; -3 &amp; 5 \end{matrix}\right)\)</li>
          <li>\(k_{1} \left(\begin{matrix} -3 &amp; 5 &amp; 5 &#92;&#92; -3 &amp; 0 &amp; 5 &#92;&#92; -3 &amp; -3 &amp; -3 \end{matrix}\right)\)</li>
          <li>\(k_{2} \left(\begin{matrix} 5 &amp; 5 &amp; 5 &#92;&#92; -3 &amp; 0 &amp; -3 &#92;&#92; -3 &amp; -3 &amp; -3 \end{matrix}\right)\)</li>
          <li>\(k_{3} \left(\begin{matrix} 5 &amp; 5 &amp; -3 &#92;&#92; 5 &amp; 0 &amp; -3 &#92;&#92; -3 &amp; -3 &amp; -3 \end{matrix}\right)\)</li>
          <li>\(k_{4} \left(\begin{matrix} 5 &amp; -3 &amp; -3 &#92;&#92; 5 &amp; 0 &amp; -3 &#92;&#92; 5 &amp; -3 &amp; -3 \end{matrix}\right)\)</li>
          <li>\(k_{5} \left(\begin{matrix} -3 &amp; -3 &amp; -3 &#92;&#92; 5 &amp; 0 &amp; -3 &#92;&#92; 5 &amp; 5 &amp; -3 \end{matrix}\right)\)</li>
          <li>\(k_{6} \left(\begin{matrix} -3 &amp; -3 &amp; -3 &#92;&#92; -3 &amp; 0 &amp; -3 &#92;&#92; 5 &amp; 5 &amp; 5 \end{matrix}\right)\)</li>
          <li>\(k_{7} \left(\begin{matrix} -3 &amp; -3 &amp; -3 &#92;&#92; -3 &amp; 0 &amp; 5 &#92;&#92; -3 &amp; 5 &amp; 5 \end{matrix}\right)\)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>边缘检测器阈值
    <p>Otsu</p>
  </li>
  <li>先进边缘检测
    <ul>
      <li>Marr-Hildreth 算法
        <ol>
          <li>高斯卷积 (预处理)</li>
          <li>Laplacian 卷积</li>
          <li>计算零交叉点</li>
        </ol>
        <p>\[\mathrm{LoG} = \left[ \frac{r^{2} + c^{2} - 2 &sigma;^{2}}{&sigma;^{4}} \mathrm{e}^{- \left( \frac{r^{2} + c^{2}}{2 &sigma;^{2}} \right)} \right]\]</p>
      </li>
      <li>Canny 算法
        <ol>
          <li>高斯平滑 (预处理)</li>
          <li>利用 Sobel 或 Prewitt 计算梯度幅度和方向</li>
          <li>应用非极大值抑制, 使边缘变细</li>
          <li>滞后阈值处理: 用两个阈值</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>边缘检测</li>
  <li>直线检测
    <ul>
      <li>Hough 变换</li>
    </ul>
  </li>
  <li>角点检测
    <ul>
      <li>Harris-Stephens 角点检测</li>
    </ul>
  </li>
  <li>形状检测</li>
</ul>
<h1>图像分割</h1>
<h2>预处理</h2>
<ul>
  <li>减少物体个数简化数量</li>
  <li>超像素预处理
    <ul>
      <li>SLIC
        <p>用 R, G, B, 行坐标, 列坐标 进行 K-means 聚类</p>
      </li>
    </ul>
  </li>
</ul>
<h2>分割方法</h2>
<ul>
  <li>分水岭分割: 对较小梯度图像进行分割得到梯度图像</li>
  <li>聚类分割</li>
  <li>阈值处理
    <ul>
      <li>Otsu 阈值
        <p>适合双峰检测</p>
        <ol>
          <li>归一化灰度直方图 \(p_{i}\)
            <p>记:</p>
            <ul>
              <li>阈值为 \(t\)</li>
              <li>小于 \(t\) 的概率为 \(P_{1}\), 大于 \(t\) 的概率为 \(P_{2}\),</li>
              <li>\(m_{1}\) 为小于 \(t\) 的均值, \(m_{2}\) 为大于 \(t\) 的均值</li>
            </ul>
          </li>
          <li>计算使得 \(&sigma;^{2}_{B} = P_{1} P_{2} (m_{1} - m_{2})^{2}\) 最大的阈值</li>
        </ol>
      </li>
      <li>边缘改进全局阈值处理</li>
    </ul>
  </li>
  <li>K-means 聚类
    <ol>
      <li>设定一组初始均值</li>
      <li>将每个样本分配给最近的聚类</li>
      <li>更新聚类中心</li>
      <li>重新迭代</li>
    </ol>
    <p>K-mean 也适合全局阈值的搜索</p>
  </li>
  <li>SLIC 超像素
    <p>用 R, G, B, 行坐标, 列坐标 进行 K-means 聚类,
      但是衡量的距离测度不是欧氏距离</p>
  </li>
</ul>
<h2>形态学滤波</h2>
<ul>
  <li>膨胀: 结构元在图像上卷积滑动</li>
  <li>腐蚀: 结构元在图像上收缩</li>
  <li>开运算: 先腐蚀后膨胀</li>
  <li>闭运算: 先膨胀后腐蚀</li>
  <li>击中-击不中变换: 结构元叠加在图像上, 只在完全匹配的时候表示击中 1</li>
  <li>骨架化: 对象被腐蚀到只有一个像素宽所剩下的部分</li>
</ul>
<h2>图像分割评判标准</h2>
<ul>
  <li>整体误差</li>
  <li>均方根误差</li>
  <li>信噪比</li>
  <li>峰值信噪比</li>
</ul>
<h1>特征提取和分析</h1>
<h1>最后</h1>
<p>讲得很多, 但是实际上有印象的也就只有那几个写过的代码,
  真的有没有理解倒是另外一回事了.</p>
<p>我的评价: 把这些念 PPT 的课都换成自己写代码算了,
  写完还能有助于国产基础软件开发 (bushi).
  只是讲概念完全理解不了, 没有那种具体的印象.
  而且好多课做的纸笔作业更是抽象: 认清课程定位啊淦!
  工程系的课讲证明和定义也就算了, 应用呢?</p>
<p>不过这门课至少还行, 作业有编程&#8230;</p>]]></content><author><name></name></author><category term="notes" /><summary type="html"><![CDATA[About 这是数字图像处理的笔记. 和作业一样, 这里采用 mlx-cl 来实现一些简单的算法和说明. 简单的准备工作 (defpackage #:blog.notes.image (:use :mlx-cl) (:local-nicknames (:fft :mlx-cl.fft) (:la :mlx-cl.linalg)))]]></summary></entry><entry><title type="html">ObjC [1.75] libffi, cffi, cffi-grovel, and C</title><link href="/lisp/objc-libffi/" rel="alternate" type="text/html" title="ObjC [1.75] libffi, cffi, cffi-grovel, and C" /><published>2025-12-30T00:00:00+00:00</published><updated>2025-12-30T00:00:00+00:00</updated><id>/lisp/objc-libffi</id><content type="html" xml:base="/lisp/objc-libffi/"><![CDATA[<h1>About</h1>
<p>无限接近 ObjC [2] 的道路中&#8230; 那么在解决了 <code>NSException</code> (见 [[/lisp/objc-ns-exception/][ObjC [1.5]​]]) 之后,
  又是什么阻碍了我呢? 答案就是我引入的 <code>libffi</code>.</p>
<p>虽然现在错误捕获这一块已经是完全胜利了 (大概), 但是另一个奇怪的问题出现了:
  用 <code>cffi-libffi</code> 调用的函数, 好像返回值不太正确. 那么该怎么办呢? 只好自己去实现了吧.</p>
<h1>如何使用 libffi</h1>
<p>尽管可以依赖网上搜的教程, <a href="https://www.chiark.greenend.org.uk/doc/libffi-dev/html/index.html">libffi 文档</a>,
  或者可以参考 <a href="https://www.youtube.com/watch?v=0o8Ex8mXigU">This Library is a Hidden Gem, Tsoding</a> (<a href="https://www.bilibili.com/video/BV1Pg1SBfE7w/">bilibili</a>),
  或者可以直接问 AI.</p>
<details><summary>可以问 AI, 但是问 AI 好像不太行</summary>
<p>我猜这是可能是因为用的 macOS 内置的 libffi:</p>
<div class="highlight"><pre><span></span>pkg-config<span class="w"> </span>libffi<span class="w"> </span>--cflags
</pre></div>
<p>所以导致了和 AI 常见的 libffi 有所出入&#8230; (当然, 更有可能是因为没啥训练语料,
  所以 AI 在乱说, 所以更建议是问完 AI 之后自己再修改一下 &#8211; 不过试过几遍之后,
  可能会发现还不如自己直接写 &#8211; 问 AI 也是要时间的嘛.</p>
</details>
<p>因为我的目标是要能够调用 ObjC 中的方法, 所以这里尝试给 ObjC 中的 Type Encoding
  都尽可能地测一边: 该如何调用 <a href="https://github.com/li-yiyang/coca/blob/cfb71ae5564b73b3304bbd765fc6b63078b480b3/objc/encoding.lisp#L163">ObjC encoding</a>.</p>
<table>
  <tr><th>ObjC encoding</th><th><code>ffi_type</code></th></tr>
  <tr><td><code>:char</code></td><td><code>ffi_type_sint8</code></td></tr>
  <tr><td><code>:unsigned-char</code>, <code>:bool</code></td><td><code>ffi_type_uint8</code></td></tr>
  <tr><td><code>:int</code></td><td><code>ffi_type_sint32</code></td></tr>
  <tr><td><code>:unsigned-int</code></td><td><code>ffi_type_uint32</code></td></tr>
  <tr><td><code>:short</code></td><td><code>ffi_type_sint16</code></td></tr>
  <tr><td><code>:unsigned-short</code></td><td><code>ffi_type_uint16</code></td></tr>
  <tr><td><code>:long</code>, <code>:long-long</code></td><td><code>ffi_type_sint64</code></td></tr>
  <tr><td><code>:unsigned-long</code>, <code>:unsigned-long-long</code></td><td><code>ffi_type_uint64</code></td></tr>
  <tr><td><code>:float</code></td><td><code>ffi_type_float</code></td></tr>
  <tr><td><code>:double</code></td><td><code>ffi_type_double</code></td></tr>
  <tr><td><code>:string</code>, <code>:object</code>, <code>:class</code>, <code>:sel</code>, <code>:unknown</code></td><td><code>ffi_type_pointer</code></td></tr>
  <tr><td><code>:void</code></td><td><code>ffi_type_void</code></td></tr>
  <tr><td><code>:struct</code></td><td><code>ffi_type_struct</code> (should manually specify)</td></tr>
  <tr><td><code>:union</code></td><td>?</td></tr>
  <tr><td><code>:bits</code></td><td>?</td></tr>
  <tr><td><code>:array</code></td><td>?</td></tr>
</table>
<p>使用 <code>man ffi_call</code> 命令可以获得一个最简单的调用的例子, 这里仿照其结果以及用
  在 [[/lisp/objc-ns-exception/][ObjC [1.5]​]] 中提到的 <code>coca_objc_msgSend</code> 思路实现的一个 <code>ffi_call</code> wrapper
  来作为例子.</p>
<details><summary>点击展开折叠的例子</summary>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ffi.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">coca_objc_msgSend</span><span class="w"> </span><span class="p">(</span><span class="n">ffi_cif</span><span class="w"> </span><span class="o">*</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="kt">IMP</span><span class="w"> </span><span class="n">imp</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">retval</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;coca_objc_msgSend&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ffi_call</span><span class="p">(</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_FN</span><span class="p">(</span><span class="n">imp</span><span class="p">),</span><span class="w"> </span><span class="n">retval</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Safe: %@&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">&lt;&lt;</span><span class="n">ffi_calling_code_here</span><span class="o">&gt;&gt;</span>
<span class="p">}</span>
</pre></div>
<p>不过这里更加推荐直接查看 <code>objc/wrapper.lisp</code> 中的代码作为默认的策略.</p>
</details>
<h2>Basic Types and their return values</h2>
<h3>Trivial C Example</h3>
<p>这里为了方便, 可以来看这样的一个例子:</p>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ffi.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">BOOL</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Got %c, %d, %d, %u, %ld, %lld, %f, %f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ffi_cif</span><span class="w"> </span><span class="n">cif</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi_type</span><span class="o">*</span><span class="w"> </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_sint8</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_uint8</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_sint32</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_uint32</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_sint64</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_uint64</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_float</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_double</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ffi_prep_cif</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_DEFAULT_ABI</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_void</span><span class="p">,</span><span class="w"> </span><span class="n">arg_types</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">FFI_OK</span><span class="p">)</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Error!!!!!!&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="kt">char</span><span class="w">             </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;L&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="kt">BOOL</span><span class="w">             </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">YES</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w">              </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-23333</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">     </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3242342</span><span class="p">;</span>
<span class="w">  </span><span class="kt">long</span><span class="w">             </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-134533256432</span><span class="p">;</span>
<span class="w">  </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span><span class="w">        </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3245633256732234543</span><span class="p">;</span>
<span class="w">  </span><span class="kt">float</span><span class="w">            </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.14159265354</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w">           </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">114.514</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">B</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">I</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">l</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>

<span class="w">  </span><span class="n">ffi_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_FN</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">arg_values</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>大概演示了如何进行简单的 libffi 调用. 不难发现其实可以把上面的 <code>main</code> 函数过程看成两部分:</p>
<ul>
  <li><code>ffi_prep_cif</code>: 准备函数类型签名部分</li>
  <li><code>ffi_call</code>: 实际函数调用部分</li>
</ul>
<p>假如需要反复调用一个函数 &#8211; 这在 ObjC bridge 中应该是较常见的一种状态,
  那么理论上可以通过复用 <code>ffi_cif</code> 来实现减少计算的功能.
  实际上由于我们已知 ObjC method 的 type encoding, 根据 Type Encoding 来生成 <code>ffi_cif</code>
  并非困难的事情.</p>
<details><summary>如何生成&#8230;</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">compile-objc-encoding-ffi-cif</span><span class="w"> </span><span class="p">(</span><span class="nf">encoding</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">multiple-value-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">arg-types</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">decode-objc-type-encoding</span><span class="w"> </span><span class="nv">encoding</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">cif</span><span class="w">    </span><span class="p">(</span><span class="nf">foreign-alloc</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">:struct</span><span class="w"> </span><span class="nv">ffi_cif</span><span class="p">)))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">len</span><span class="w">    </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">arg-types</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">atypes</span><span class="w"> </span><span class="p">(</span><span class="nf">foreign-alloc</span><span class="w"> </span><span class="nv">:pointer</span><span class="w"> </span><span class="nv">:count</span><span class="w"> </span><span class="nv">len</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">:from</span><span class="w"> </span><span class="mi">0</span>
<span class="w">            </span><span class="nv">:for</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">arg-types</span>
<span class="w">            </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">mem-aref</span><span class="w"> </span><span class="nv">atypes</span><span class="w"> </span><span class="nv">:pointer</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">objc-encoding-ffi-type</span><span class="w"> </span><span class="nv">type</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">assert</span><span class="w"> </span><span class="p">(</span><span class="nf">eq</span><span class="w"> </span><span class="p">(</span><span class="nf">ffi_prep_cif</span><span class="w"> </span><span class="nv">cif</span><span class="w"> </span><span class="nv">:default-abi</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-encoding-ffi-type</span><span class="w"> </span><span class="nv">ret</span><span class="p">)</span><span class="w"> </span><span class="nv">atypes</span><span class="p">)</span>
<span class="w">                  </span><span class="nv">:ffi-ok</span><span class="p">))</span>
<span class="w">      </span><span class="nv">cif</span><span class="p">)))</span>
</pre></div>
</details>
<p>只是我们还是需要解决 <code>struct</code> 的难题&#8230;</p>
<h3>Struct</h3>
<p>修改以下上面的代码, 便可以得到:</p>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ffi.h&gt;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_greet</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Greet</span><span class="p">;</span>

<span class="n">Greet</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="n">Greet</span><span class="w"> </span><span class="n">greet</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">greet</span><span class="p">.</span><span class="n">repeat</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Hello %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">greet</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">greet</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ffi_cif</span><span class="w"> </span><span class="n">cif</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi_type</span><span class="w"> </span><span class="n">ffi_type_greet</span><span class="p">;</span>

<span class="w">  </span><span class="n">ffi_type</span><span class="o">*</span><span class="w"> </span><span class="n">elements</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="w">  </span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_pointer</span><span class="p">;</span>
<span class="w">  </span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_sint32</span><span class="p">;</span>
<span class="w">  </span><span class="n">elements</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">  </span><span class="n">ffi_type_greet</span><span class="p">.</span><span class="n">size</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi_type_greet</span><span class="p">.</span><span class="n">alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi_type_greet</span><span class="p">.</span><span class="n">type</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">FFI_TYPE_STRUCT</span><span class="p">;</span>
<span class="w">  </span><span class="n">ffi_type_greet</span><span class="p">.</span><span class="n">elements</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span>

<span class="w">  </span><span class="n">ffi_type</span><span class="o">*</span><span class="w"> </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="n">arg_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_greet</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ffi_prep_cif</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_DEFAULT_ABI</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_greet</span><span class="p">,</span><span class="w"> </span><span class="n">arg_types</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">FFI_OK</span><span class="p">)</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Error!!!!!!&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">Greet</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="w">  </span><span class="n">bar</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Ryo&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">bar</span><span class="p">.</span><span class="n">repeat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">  </span><span class="n">arg_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">;</span>

<span class="w">  </span><span class="n">Greet</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">  </span><span class="n">ffi_call</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_FN</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">arg_values</span><span class="p">);</span>

<span class="w">  </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Got: %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>其实仍然不难发现, <code>ffi_type_greet</code> 也是一个可以被提前定义的量 &#8211;
  在 <code>define-objc-struct</code> 的时候便可以被定义了.</p>
<p>不过好处是由于用的是 <code>libffi</code>, 现在并不需要过分手动展开结构体了,
  只需要实现一个 <code>objc-encoding-ffi-type</code> 即可.</p>
<h3>除了 Struct, 还有&#8230;</h3>
<p>为了能够处理各种类型的输入和输出, 这里将整个调用过程的形式编译为如下的形式
  (<a href="https://github.com/li-yiyang/coca/blob/ad9c9959fb786ca60764982e20ad69654b0021c6/objc/method.lisp#L170">objc-method-foreign-call-form</a>):</p>
<ol>
  <li><code>foreign-alloc</code> \(&rarr;\) <code>arg_types</code></li>
  <li>通过 <a href="https://github.com/li-yiyang/coca/blob/ad9c9959fb786ca60764982e20ad69654b0021c6/objc/method.lisp#L72">objc-method-foreign-alloc-form</a> 在堆上分配调用的参数的空间,
    通过 <a href="https://github.com/li-yiyang/coca/blob/ad9c9959fb786ca60764982e20ad69654b0021c6/objc/method.lisp#L92">objc-method-foreign-setf-form</a> 将 Lisp 的值复制到堆上</li>
  <li>调用设置好的 wrapper <a href="https://github.com/li-yiyang/coca/blob/ad9c9959fb786ca60764982e20ad69654b0021c6/objc/wrapper.lisp#L22">coca_objc_msgSend</a> 来调用 ObjC method</li>
  <li>通过 <a href="https://github.com/li-yiyang/coca/blob/ad9c9959fb786ca60764982e20ad69654b0021c6/objc/method.lisp#L123">objc-method-foreign-aref-form</a> 将结果从指针拷贝到 Lisp 环境中</li>
</ol>
<h1>如何使用 CFFI grovel</h1>
<p><a href="https://cffi.common-lisp.dev/manual/cffi-manual.html#The-Groveller">CFFI-Grovel</a> 提供了一种非常巧妙的方法来构造 CFFI binding: 即通过生成一个 C 程序 (grovel),
  将宏, 常量值, <code>enum</code> 等值打印输出为 Lisp 代码, 然后将这个 Lisp 代码作为代码载入;
  以及通过编译一个 C 程序 (wrapper), 将一些简单的静态库链接编译成动态库载入,
  同时也可以获得简单的 C 互操作性 &#8211; 我认为这比让用户手动打包一个 <code>dylib</code> 要优雅&#8230;</p>
<p>虽然但是, 在 CFFI 的文档和具体实现里面还是有些差别的&#8230; (见 <a href="https://github.com/cffi/cffi/pull/426">PR</a>).
  等上游合并可能有点慢, 这里我选择了自己维护一份用于 ObjC 的 wrapper 拓展.</p>
<h2>Grovel and Wrapper</h2>
<p>实际的代码可以参考 <a href="https://github.com/li-yiyang/cffi/blob/b9ee202b6a8961f81b190b8cf1ba10b203605c62/grovel/grovel.lisp">grovel.lisp</a>, 定义了 grovel file 和 wrapper file
  是如何被映射为 C 代码, 以及如何生成 Lisp 端的接口的.</p>
<p>然后在 <a href="https://github.com/li-yiyang/cffi/blob/b9ee202b6a8961f81b190b8cf1ba10b203605c62/grovel/asdf.lisp">asdf.lisp</a> 中注册了对应的功能来让 ASDF 载入的时候能够按照前面定义的规则进行处理.
  实际上是非常棒的设计.</p>
<details><summary>如何阅读 Lisp 代码</summary>
<p>这里是一点点我的简单的阅读 Lisp 代码的小经验:</p>
<p>因为 Lisp 的动态性, 所以用 C 的那种 &#8220;静态&#8221; 代码分析其实并不是很现实 &#8211; 或者说,
  会很痛苦, 所以最好还是利用 SLY/SLIME 这样的动态环境去分析代码的逻辑:</p>
<ul>
  <li>用 <code>git clone ...</code> 将代码拉到本地</li>
  <li><code>(ql:quickload :system)</code> 将系统载入
    <ul>
      <li><code>(trace ...)</code>: 通过 <code>trace</code> 来跟踪方法调用 &#8211; 其实更多的时候是用来不重定义函数,
        来得到函数的输出和输入, 来确认函数的功能
        <p>当然, 最好还是自己给这个函数加上注释和文档, 这样一来就方便自己下一次重新观察代码.</p>
      </li>
      <li><code>sly-edit-definition</code>: 这样就能够直接跳到函数的定义</li>
      <li><code>sly-who-calls</code>, <code>sly-who-binds</code>, &#8230; 虽然有这些个功能, 但是貌似好多都跟踪不了 (找不到&#8230;</li>
    </ul>
  </li>
  <li>并且在了解了一些 MOP 之后, 现在看到 Class 我也会觉得可以很好地阅读和了解了,
    感觉就只是缺少一个比较好的可视化辅助 &#8211; LEM 的 <a href="https://lem-project.github.io/usage/living-canvas/">Living Canvas</a> 我觉得还挺不错,
    可惜是在 Electron 上实现的, 希望 coca 实现完了之后能够摆脱 Electron 这个可怕的家伙&#8230;</li>
</ul>
</details>
<h2>ObjC File</h2>
<p>如果对实际的实现感兴趣的话, 请参考 <code>grovel/grovel.lisp</code> 以及 <code>grovel/asdf.lisp</code>,
  不过估计也不会有人那么闲吧&#8230; 那还是请参考 <code>grovel/syntax.lisp</code> 中具体的语法说明吧.</p>
<details><summary>那么具体是什么呢? </summary>
<p>在 <code>grovel/asdf.lisp</code> 中, 为 <code>:objc-file</code> 注册了一个处理接口,
  于是所有的 <code>:objc-file</code> 将会被交由 <code>process-objc-file</code> 函数来进行处理.</p>
<p>对于 <code>process-objc-file</code> 函数, 其做的事情导致如下:</p>
<ul>
  <li>从 <code>:objc-file</code> 中读取 S-expr</li>
  <li>根据 S-expr 的 <code>car</code> 信息, 找到对应的 <code>%process-objc-form</code> 方法, 然后对其进行处理</li>
  <li>在 <code>grovel/syntax.lisp</code> 中定义了一堆可用的处理函数</li>
</ul>
</details>
<ul>
  <li><code>progn</code>: 执行一组 ObjC form 指令 (实际上适合用来做 feature switch)</li>
  <li><code>in-package</code>: 设置 Lisp package</li>
  <li><code>objc</code>: 直接嵌入 ObjC 代码</li>
  <li><code>cc-flags</code>: 添加 compiler flags</li>
  <li><code>ld-flags</code>: 添加 linker flags</li>
  <li><code>pkg-config-cflags</code>: 使用 <code>pkg-config ... --cflags</code> 来添加 <code>cc-flags</code></li>
  <li><code>define</code>: 映射到 C 的 <code>#define ...</code> 宏</li>
  <li><code>include</code>: 映射到 C 的 <code>#include &lt;...&gt;</code> 宏</li>
  <li><code>import</code>: 映射到 ObjC 的 <code>#import &lt;...&gt;</code> 宏</li>
</ul>
<p>之后我想我应该添加一些在 Coca.ObjC 包中的函数, 比如 <code>define-objc-struct</code>,
  <code>define-objc-const</code> 之类的命令来让写 ObjC wrapper 的体验和写 Lisp 代码是一模一样的.</p>
<h1>最后</h1>
<p>目前的状态是 <a href="https://github.com/li-yiyang/coca/commit/ad9c9959fb786ca60764982e20ad69654b0021c6">#ad9c995</a>, 我认为算是可以实现一个比较简单的 ObjC 调用了&#8230;
  之后的目标还是继续学习 ObjC 和 Cocoa 的编程来实现最终的 macOS 的 GUI 编程的大业&#8230;</p>]]></content><author><name></name></author><category term="lisp" /><summary type="html"><![CDATA[About 无限接近 ObjC [2] 的道路中&#8230; 那么在解决了 NSException (见 [[/lisp/objc-ns-exception/][ObjC [1.5]​]]) 之后, 又是什么阻碍了我呢? 答案就是我引入的 libffi. 虽然现在错误捕获这一块已经是完全胜利了 (大概), 但是另一个奇怪的问题出现了: 用 cffi-libffi 调用的函数, 好像返回值不太正确. 那么该怎么办呢? 只好自己去实现了吧. 如何使用 libffi 尽管可以依赖网上搜的教程, libffi 文档, 或者可以参考 This Library is a Hidden Gem, Tsoding (bilibili), 或者可以直接问 AI. 可以问 AI, 但是问 AI 好像不太行 我猜这是可能是因为用的 macOS 内置的 libffi: pkg-config libffi --cflags 所以导致了和 AI 常见的 libffi 有所出入&#8230; (当然, 更有可能是因为没啥训练语料, 所以 AI 在乱说, 所以更建议是问完 AI 之后自己再修改一下 &#8211; 不过试过几遍之后, 可能会发现还不如自己直接写 &#8211; 问 AI 也是要时间的嘛. 因为我的目标是要能够调用 ObjC 中的方法, 所以这里尝试给 ObjC 中的 Type Encoding 都尽可能地测一边: 该如何调用 ObjC encoding. ObjC encodingffi_type :charffi_type_sint8 :unsigned-char, :boolffi_type_uint8 :intffi_type_sint32 :unsigned-intffi_type_uint32 :shortffi_type_sint16 :unsigned-shortffi_type_uint16 :long, :long-longffi_type_sint64 :unsigned-long, :unsigned-long-longffi_type_uint64 :floatffi_type_float :doubleffi_type_double :string, :object, :class, :sel, :unknownffi_type_pointer :voidffi_type_void :structffi_type_struct (should manually specify) :union? :bits? :array? 使用 man ffi_call 命令可以获得一个最简单的调用的例子, 这里仿照其结果以及用 在 [[/lisp/objc-ns-exception/][ObjC [1.5]​]] 中提到的 coca_objc_msgSend 思路实现的一个 ffi_call wrapper 来作为例子. 点击展开折叠的例子 #import &lt;Foundation/Foundation.h&gt; #include &lt;ffi.h&gt;]]></summary></entry><entry><title type="html">ObjC [1.5] NSException (EN)</title><link href="/lisp/objc-ns-exception/" rel="alternate" type="text/html" title="ObjC [1.5] NSException (EN)" /><published>2025-12-27T00:00:00+00:00</published><updated>2025-12-27T00:00:00+00:00</updated><id>/lisp/objc-ns-exception</id><content type="html" xml:base="/lisp/objc-ns-exception/"><![CDATA[<h1>About</h1>
<p>So this stuff has bother me for days&#8230;
  How to catch <code>NSException</code> when <code>invoke</code> ObjC methods?</p>
<p>In Lisp, we could do error (condition) capture like this:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">handler-case</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="nv">your-error-condition</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">some-other-error</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">your-error-condition</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;Haha&quot;</span><span class="p">)))</span>
</pre></div>
<p>which, is like you do the following in ObjC:</p>
<div class="highlight"><pre><span></span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@throw</span><span class="w"> </span><span class="n">YourErrorCondition</span>
<span class="p">}</span>
<span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="n">YourErrorCondition</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Haha&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>however, it's not trivial to implement such thing in <a href="https://github.com/li-yiyang/coca/commit/d91a1025bb9cdf72c434eb382dee134c72262b78">coca</a>&#8230;
  I gave up&#8230; Well, just kidding, if I just give up, you won't
  see this post. :p</p>
<blockquote>
  <p>Note: I was natively speaking Chinese. This blog post is written
    in English to share to other Lisp programmers on reddit. If you
    think my English is poor, use LLM to refine or translate it. :p</p>
</blockquote>
<h1>How I Fails: The First Try</h1>
<h2>Callback wrapped by <code>@try</code> and <code>@catch</code></h2>
<p>I posted my struggling experience in reddit:
  <a href="https://www.reddit.com/r/Common_Lisp/comments/1pwetri/cffi_callback_function_in_trycatch_black_is_not/">CFFI callback function in try-catch black is not working</a>.</p>
<p>And here's its trivial ideas:</p>
<ul>
  <li>we want to capture the <code>NSException</code>,
    so we could just write a wrapper code:
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">coca_lisp_call_wrapper</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">call</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">call</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">coca_lisp_exception_callback</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
  </li>
  <li>but if we pass CFFI callback as <code>call</code> arguments:
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">foreign-funcall</span><span class="w"> </span><span class="s">&quot;coca_lisp_call_wrapper&quot;</span><span class="w"> </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">callback</span><span class="w"> </span><span class="nv">invoke-error</span><span class="p">))</span>
</pre></div>
    <p>the <code>NSException</code> is just not captured!</p>
    <p>And here's a minimum reproducable example if you are willing to try:</p>
  <details><summary>Folded, Click me to expand. </summary>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">coca_lisp_call_wrapper</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">call</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">call</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Safe... &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">coca_lisp_error_function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="l">@[</span><span class="mi">@1</span><span class="p">,</span><span class="w"> </span><span class="mi">@2</span><span class="l">]</span><span class="p">;</span>
<span class="w">  </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// this will capture NSException</span>
<span class="w">  </span><span class="n">coca_lisp_call_wrapper</span><span class="p">(</span><span class="o">&amp;</span><span class="n">coca_lisp_error_function</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
    <p>if compiled and run the above code, it would return:</p>
    <pre class="example">
clang -fobjc-arc -framework Foundation -o test test.m &amp;&amp; ./test
test.m:14:3: warning: container access result unused - container access should not be used for side effects [-Wunused-value]
   14 |   arr[10];
      |   ^~~~~~~
1 warning generated.
2025-12-27 21:20:02.399 test[96331:13873785] Safe...
    </pre>
    <p>if compiled as a library and linked into lisp, you may write a
      callback function like this:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defcallback</span><span class="w"> </span><span class="nv">invoke-error</span><span class="w"> </span><span class="nv">:void</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="nf">foreign-funcall</span><span class="w"> </span><span class="s">&quot;coca_lisp_error_function&quot;</span><span class="w"> </span><span class="nv">:void</span><span class="p">))</span>

<span class="p">(</span><span class="nf">foreign-funcall</span><span class="w"> </span><span class="s">&quot;coca_lisp_call_wrapper&quot;</span><span class="w"> </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">callback</span><span class="w"> </span><span class="nv">invoke-error</span><span class="p">))</span>
</pre></div>
    <p>the NSException would not be catched&#8230;</p>
  <details><summary>How to link automatically</summary>
    <p>You could use the <a href="https://cffi.common-lisp.dev/manual/html_node/The-Groveller.html">cffi-grovel</a>, note that the online documentation
      is a little out-dated. And to work properly, you may need my
      CFFI-grovel <a href="https://github.com/cffi/cffi/compare/master...li-yiyang:cffi:master">patch</a>.</p>
  </details>
  </details>
  </li>
</ul>
<h2>Why this</h2>
<p>According to silly LLM, they said that when you switched between Lisp, C, ObjC
  calling frame, the error capture boundary would be broken and so the program
  does not how to throw or capture the exception.</p>
<p>This is really a sad story.</p>
<h1>A trick that solving the problem</h1>
<h2>Invoke <code>IMP</code> directly</h2>
<p>So invoking CFFI Lisp callback is impossible, what if we directly pass the
  C function pointer?</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">foreign-funcall</span><span class="w"> </span><span class="s">&quot;coca_lisp_call_wrapper&quot;</span>
<span class="w">                 </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">foreign-symbol-pointer</span><span class="w"> </span><span class="s">&quot;coca_lisp_error_function&quot;</span><span class="p">))</span>
</pre></div>
<p>this would work fine. The exception would be captured and so the ObjC runtime
  won't just panic and throw <code>SIGABORT</code>.</p>
<p>So want we want is a <code>safe_objc_msgSend</code> that does:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">safe_objc_msgSend</span><span class="w"> </span><span class="p">(</span><span class="kt">IMP</span><span class="w"> </span><span class="n">imp</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="nb">self</span><span class="p">,</span><span class="w"> </span><span class="kt">SEL</span><span class="w"> </span><span class="n">sel</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">imp</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span><span class="w"> </span><span class="n">sel</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">coca_throw_exception_to_lisp</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2><code>va_list</code> is not a trivial thing and <code>__ASM__</code> is not portable</h2>
<p>To implement <code>...</code> in ObjC/C is difficult and using <code>__ASM__</code> to shift
  registers to prepare for function calling is also not so trivial.</p>
<blockquote>
  <p>NOTE: i was not a professional C programmer (neither a professional Lisp programmer).
    So can't be sure the above is true.</p>
</blockquote>
<details><summary>register shifting</summary>
<p>You might try this:</p>
<div class="highlight"><pre><span></span><span class="nl">_coca_dispatch_imp:</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x9</span><span class="p">,</span><span class="w"> </span><span class="no">x0</span><span class="w">    </span><span class="c1">// imp</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x0</span><span class="p">,</span><span class="w"> </span><span class="no">x1</span><span class="w">    </span><span class="c1">// self</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x1</span><span class="p">,</span><span class="w"> </span><span class="no">x2</span><span class="w">    </span><span class="c1">// sel</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x2</span><span class="p">,</span><span class="w"> </span><span class="no">x3</span><span class="w">    </span><span class="c1">// arg1</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x3</span><span class="p">,</span><span class="w"> </span><span class="no">x4</span><span class="w">    </span><span class="c1">// arg2</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x4</span><span class="p">,</span><span class="w"> </span><span class="no">x5</span><span class="w">    </span><span class="c1">// arg3</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x5</span><span class="p">,</span><span class="w"> </span><span class="no">x6</span><span class="w">    </span><span class="c1">// arg4</span>
<span class="w">  </span><span class="nf">mov</span><span class="w"> </span><span class="no">x6</span><span class="p">,</span><span class="w"> </span><span class="no">x7</span><span class="w">    </span><span class="c1">// arg5</span>

<span class="w">  </span><span class="nf">br</span><span class="w"> </span><span class="no">x9</span><span class="w">         </span><span class="c1">// imp(self, sel, ...)</span>
</pre></div>
<p>with the new <code>safe_objc_msgSend</code>:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">safe_objc_msgSend</span><span class="w"> </span><span class="p">(</span><span class="kt">IMP</span><span class="w"> </span><span class="n">imp</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="nb">self</span><span class="p">,</span><span class="w"> </span><span class="kt">SEL</span><span class="w"> </span><span class="n">sel</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">_coca_dispatch_imp</span><span class="p">(</span><span class="n">imp</span><span class="p">,</span><span class="w"> </span><span class="nb">self</span><span class="p">,</span><span class="w"> </span><span class="n">sel</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">coca_throw_exception_to_lisp</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>I haven't try this so cannot ensure it's working properly.</p>
</details>
<h2>LibFFI</h2>
<p>So I guess I'll just use libffi to do this:</p>
<ul>
  <li>lisp: when in <code>coca.objc</code>, we could implement <code>compile-objc-method-calling</code>
    to generate <code>ffi_cif</code></li>
  <li>objc: the <code>safe_objc_msgSend</code> should be implemented like:
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">safe_objc_msgSend</span><span class="w"> </span><span class="p">(</span><span class="n">ffi_cif</span><span class="w"> </span><span class="o">*</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="kt">IMP</span><span class="w"> </span><span class="n">imp</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">retval</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">arg_values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ffi_call</span><span class="p">(</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_FN</span><span class="p">(</span><span class="n">imp</span><span class="p">),</span><span class="w"> </span><span class="n">retval</span><span class="p">,</span><span class="w"> </span><span class="n">arg_values</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">coca_throw_exception</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
  </li>
</ul>
<p>So in theory, we could copy the code in <a href="https://github.com/cffi/cffi/blob/master/libffi/funcall.lisp">cffi/libffi/funcall.lisp</a>.
  The <code>safe_objc_msgSend</code> just works like <code>ffi_call</code>.</p>
<h3>LibFFI and ObjC <code>@try</code> <code>@catch</code> prototype</h3>
<details><summary>A minimum compilable test</summary>
<div class="highlight"><pre><span></span><span class="cp">#import  &lt;Foundation/Foundation.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ffi.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">coca_lisp_test_fail_function</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="bp">NSArray</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="l">@[</span><span class="mi">@1</span><span class="l">]</span><span class="p">;</span>
<span class="w">  </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">coca_objc_msgSend</span><span class="w"> </span><span class="p">(</span><span class="n">ffi_cif</span><span class="w"> </span><span class="o">*</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="kt">IMP</span><span class="w"> </span><span class="n">imp</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">retval</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">**</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ffi_call</span><span class="p">(</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_FN</span><span class="p">(</span><span class="n">imp</span><span class="p">),</span><span class="w"> </span><span class="n">retval</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Safe&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ffi_cif</span><span class="w"> </span><span class="n">cif</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ffi_prep_cif</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_DEFAULT_ABI</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ffi_type_void</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">FFI_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Failed to call ffi_pref_cif&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">coca_objc_msgSend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cif</span><span class="p">,</span><span class="w"> </span><span class="n">FFI_FN</span><span class="p">(</span><span class="n">coca_lisp_test_fail_function</span><span class="p">),</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>the compilation result is like below:</p>
<pre class="example">
clang -fobjc-arc -framework Foundation -lffi -I/Library/Developer/CommandLineTools/SDKs/MacOSX26.sdk/usr/include/ffi -o test test.m &amp;&amp; ./test
test.m:14:3: warning: container access result unused - container access should not be used for side effects [-Wunused-value]
   14 |   arr[10];
      |   ^~~~~~~
1 warning generated.
2025-12-27 23:48:27.165 test[99720:14024008] Safe

Compilation finished at Sat Dec 27 23:48:27, duration 0.39 s
</pre>
<p>so in theory, it's workable&#8230;</p>
</details>
<h3>LibFFI in Common Lisp</h3>
<p>Refering to <a href="https://github.com/cffi/cffi/blob/master/libffi/funcall.lisp">cffi/libffi/funcall.lisp</a>, we could implement our own
  foreign-funcall-form/fsbv-with-libffi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">in-package</span><span class="w"> </span><span class="nv">:coca</span><span class="o">.</span><span class="nv">objc</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">foreign-funcall-form</span><span class="w"> </span>
</pre></div>
<h2>A word about performance</h2>
<p>Yes, performace&#8230; Although I don't like to care about it (I write shit codes,
  really really shit codes), I think we could make a hole on the previous
  <code>compile-objc-method-calling</code> rules: if we got a <code>objc_msgSend</code> with no
  additional arguments other than <code>id self</code> and <code>SEL sel</code>, we could just call
  the simple wrapper function:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">safe_objc_msgSend_0</span><span class="w"> </span><span class="p">(</span><span class="kt">IMP</span><span class="w"> </span><span class="n">imp</span><span class="p">,</span><span class="w"> </span><span class="kt">id</span><span class="w"> </span><span class="n">_self</span><span class="p">,</span><span class="w"> </span><span class="kt">SEL</span><span class="w"> </span><span class="n">sel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">imp</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span><span class="w"> </span><span class="n">sel</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">@catch</span><span class="w"> </span><span class="p">(</span><span class="bp">NSException</span><span class="w"> </span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">coca_throw_exception</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>but this is just left here as it is. I don't think I'd like to implement it.
  Maybe you could generate a wrapper like CFFI-grovel, generate the
  ObjC wrapper code for every method of likely same type encoding, and doing
  JIT like things (compile and load the dylib into lisp image). I'd like to
  see such PR if you are willing to contribute.</p>]]></content><author><name></name></author><category term="lisp" /><summary type="html"><![CDATA[About So this stuff has bother me for days&#8230; How to catch NSException when invoke ObjC methods? In Lisp, we could do error (condition) capture like this: (handler-case (error your-error-condition) (some-other-error () ...) (your-error-condition () (format t &quot;Haha&quot;))) which, is like you do the following in ObjC: @try { @throw YourErrorCondition } @catch (YourErrorCondition *e) { NSLog(@&quot;Haha&quot;) } however, it's not trivial to implement such thing in coca&#8230; I gave up&#8230; Well, just kidding, if I just give up, you won't see this post. :p Note: I was natively speaking Chinese. This blog post is written in English to share to other Lisp programmers on reddit. If you think my English is poor, use LLM to refine or translate it. :p How I Fails: The First Try Callback wrapped by @try and @catch I posted my struggling experience in reddit: CFFI callback function in try-catch black is not working. And here's its trivial ideas: we want to capture the NSException, so we could just write a wrapper code: void coca_lisp_call_wrapper (void (*call)(void)) { @try { call(); } @catch (NSException *e) { coca_lisp_exception_callback(e); } } but if we pass CFFI callback as call arguments: (foreign-funcall &quot;coca_lisp_call_wrapper&quot; :pointer (callback invoke-error)) the NSException is just not captured! And here's a minimum reproducable example if you are willing to try: Folded, Click me to expand. #import &lt;Foundation/Foundation.h&gt;]]></summary></entry><entry><title type="html">MOP: again!</title><link href="/lisp/mop/" rel="alternate" type="text/html" title="MOP: again!" /><published>2025-12-24T00:00:00+00:00</published><updated>2025-12-24T00:00:00+00:00</updated><id>/lisp/mop</id><content type="html" xml:base="/lisp/mop/"><![CDATA[<h1>About</h1>
<p>虽然之前写的/之前的 <a href="https://www.lispworks.com/documentation/lw70/MOP/mop/concepts.html">MOP</a> 阅读和学习尝试都有点中道崩猝.
  要说这次可能有什么不同的话, 那就是至少我现在是带着项目进行的学习了.
  嗯, 应该可以这么说吧&#8230; (<a href="https://github.com/li-yiyang/coca">coca</a> 和 <a href="https://github.com/li-yiyang/mlx-cl">mlx-cl</a>).</p>
<p>注: 假如有兴趣的话, 不妨来试试 <a href="https://github.com/li-yiyang/mopdoc">MOPDoc</a>, 为 MOP 添加 documentation string.
  这样就可以用 SLIME/SLY 来 inspect.</p>
<p>这里参考的是 AMOP (Art of MetaObject Protocol).</p>
<h1>The Design and Implementation of Metaobject Protocols</h1>
<h2>How CLOS is Implemented</h2>
<h3>A Subset of CLOS</h3>
<p>书中是用了一个 CLOS 的子集来做教学例子.
  这里就用真实对应的 CLOS 和 <a href="https://github.com/pcostanza/closer-mop/tree/master">closer-mop</a> 进行联系.</p>
<p>以下的代码在 <code>CLOSER-COMMON-LISP-USER</code> 下运行.</p>
<details><summary>注: 这部分建议读什么</summary>
<p>感觉这部分属于是作者小小炫技了: 在 CLOS 上实现一个 CLOS 的子集.
  但是我并不是很关心具体是怎么实现的, 所以读这一部分的时候基本是跳着读的.</p>
<p>其实这部分可以主要用来关注在 CLOS 的 interface 下面的具体发生了什么过程.
  比如创建实例 <code>make-instance</code> 的时候, 发生了什么过程:</p>
<ul>
  <li><code>allocate-instance</code></li>
  <li><code>initialize-instance</code></li>
</ul>
</details>
<h3>The Basic Backstage Structures</h3>
<h3>Representing Classes</h3>
<p>在 <code>standard-class</code> 这个 Metaclass 类中, 有以下的 <code>slots</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;slot-definition-name</span><span class="w"> </span><span class="p">(</span><span class="nf">class-slots</span><span class="w"> </span><span class="p">(</span><span class="nf">find-class</span><span class="w"> </span><span class="ss">&#39;standard-class</span><span class="p">)))</span>
</pre></div>
<table>
  <tr><td>sb-pcl::%type</td><td>sb-pcl::source</td><td>sb-pcl::plist</td><td>sb-pcl::name</td><td>sb-pcl::class-eq-specializer</td><td>sb-pcl::direct-superclasses</td><td>sb-pcl::direct-subclasses</td><td>sb-pcl::direct-methods</td><td>sb-pcl::%documentation</td><td>sb-pcl::safe-p</td><td>sb-pcl::finalized-p</td><td>sb-pcl::%class-precedence-list</td><td>sb-pcl::cpl-available-p</td><td>sb-pcl::can-precede-list</td><td>sb-pcl::incompatible-superclass-list</td><td>sb-pcl::wrapper</td><td>sb-pcl::prototype</td><td>sb-pcl::direct-slots</td><td>sb-pcl::slots</td></tr>
</table>
<h4>The <code>defclass</code> Macro</h4>
<p>可以把 <code>defclass</code> 的过程看作是:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">defclass</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="w"> </span><span class="nv">direct-superclasses</span><span class="w"> </span><span class="nv">direct-slots</span><span class="w"> </span><span class="nv">&amp;rest</span><span class="w"> </span><span class="nv">options</span><span class="p">)</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nf">ensure-class</span>
<span class="w">    </span><span class="ss">&#39;,name</span>
<span class="w">    </span><span class="nv">:direct-superclasses</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nf">canonicalize-direct-superclasses</span>
<span class="w">                           </span><span class="nv">direct-superclasses</span><span class="p">)</span>
<span class="w">    </span><span class="nv">:direct-slots</span><span class="w">        </span><span class="o">,</span><span class="p">(</span><span class="nf">canonicalize-direct-slots</span>
<span class="w">                           </span><span class="nv">direct-slots</span><span class="p">)</span>
<span class="w">    </span><span class="o">,@</span><span class="p">(</span><span class="nf">canonicalize-defclass-options</span><span class="w"> </span><span class="nv">options</span><span class="p">)))</span>
</pre></div>
<p>其中 <code>canonicalize-</code> 的这些部分可以暂时当作是一个正则化的过程, 忽略.</p>
<p>注: 实际上可能并不是这样实现的 <code>defclass</code>.</p>
<h4>Direct Superclasses</h4>
<p>是一组 superclasses 的列表.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">canonicalize-direct-superclasses</span><span class="w"> </span><span class="p">(</span><span class="nf">direct-superclasses</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;find-class</span><span class="w"> </span><span class="nv">direct-superclasses</span><span class="p">))</span>
</pre></div>
<h4>Direct Slots</h4>
<ul>
  <li><code>name</code> \(&rarr;\) <code>:name name</code></li>
  <li><code>initform</code> \(&rarr;\) <code>:initform initform :initfunction (lambda () initform)</code>
    <p>其中</p>
    <ul>
      <li><code>:initfunction</code>: 是一个无参数的 <code>lambda</code> 函数, 用于在 lexical 环境被调用生成初始化的值</li>
      <li><code>:initform</code>: 仅是被保留用于可读性</li>
    </ul>
  </li>
  <li><code>initarg</code> \(&rarr;\) <code>:initargs (initarg initarg...)</code></li>
  <li><code>accessor</code> \(&rarr;\) <code>:reader accessor :writer (setf accessor)</code></li>
  <li><code>reader</code> \(&rarr;\) <code>:readers (reader reader...)</code></li>
  <li><code>writer</code> \(&rarr;\) <code>:writers (writer writer...)</code></li>
</ul>
<p>例:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">ensure-class</span>
<span class="w"> </span><span class="ss">&#39;class</span>
<span class="w"> </span><span class="nv">:direct-superclasses</span><span class="w"> </span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="w"> </span><span class="nv">:direct-slots</span><span class="w">  </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span>
<span class="w">                       </span><span class="nv">:name</span><span class="w">            </span><span class="ss">&#39;name</span><span class="w">             </span><span class="c1">; slot-definition-name</span>
<span class="w">                       </span><span class="nv">:initform</span><span class="w">        </span><span class="ss">&#39;val</span><span class="w">              </span><span class="c1">; slot-definition-initform</span>
<span class="w">                       </span><span class="nv">:initfunction</span><span class="w">   </span><span class="o">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w">  </span><span class="c1">; slot-definition-initfunction</span>
<span class="w">                       </span><span class="nv">:initargs</span><span class="w">        </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">:name</span><span class="p">)</span><span class="w">          </span><span class="c1">; slot-definition-initargs</span>
<span class="w">                       </span><span class="nv">:readers</span><span class="w">         </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">name</span><span class="p">)</span><span class="w">           </span><span class="c1">; slot-definition-readers</span>
<span class="w">                       </span><span class="nv">:writers</span><span class="w">         </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">setf</span><span class="w"> </span><span class="nv">name</span><span class="p">)))))</span><span class="w"> </span><span class="c1">; slot-definition-writers</span>
</pre></div>
<h4>Class Options</h4>
<p>被转换为 <code>plist</code> 作为更多的参数如下被 <code>ensure-class</code> 类似如下调用:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">make-instance</span><span class="w"> </span><span class="ss">&#39;standard-class</span><span class="w"> </span><span class="o">,@</span><span class="nv">class-options-plist</span><span class="p">)</span>
</pre></div>
<h4><code>ensure-class</code></h4>
<p>相当于是做了如下的事情:</p>
<ul>
  <li><code>make-instance</code>: 从 Metaclass 创建了一个 class 类</li>
  <li><code>(setf find-class)</code>: 在 class lookup table 中注册对应的类</li>
</ul>
<h4>Intializing Class Metaobjects</h4>
<ul>
  <li>生成 <code>direct-superclasses</code></li>
  <li>向 superclass 的 <code>direct-subclasses</code> 添加自己</li>
  <li>定义 <code>reader</code> 和 <code>accessor</code> 函数</li>
  <li>以及处理其他的继承关系</li>
</ul>
<h4>Inheritance</h4>
<ul>
  <li>计算类的继承关系</li>
  <li>计算 slot: 从父类中继承, 并最终生成 <code>effective-slot-definition</code></li>
</ul>
<h3>Printing Objects</h3>
<p>调用 <code>print-object</code>.</p>
<h3>Representing the Structure of Instances</h3>
<ul>
  <li>Object identity
    <ul>
      <li><code>make-instance</code>: 类似于如下的过程
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">instance</span><span class="w"> </span><span class="p">(</span><span class="nf">allocate-instance</span><span class="w"> </span><span class="nv">class</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;initialize-instance</span><span class="w"> </span><span class="nv">instance</span><span class="w"> </span><span class="nv">initargs</span><span class="p">)</span>
<span class="w">  </span><span class="nv">instance</span><span class="p">)</span>
</pre></div>
      </li>
      <li><code>initialize-instance</code>, <code>reinitialize-instance</code> 都共同地使用了 <code>shared-initialize</code></li>
    </ul>
  </li>
  <li>Slot storage:
    <ul>
      <li><code>(alocate-instance class &amp;rest args)</code>: 为类实例及其 slots 划分空间</li>
      <li><code>(slot-value instance slot-name)</code>: 获取实例的 slot 的值</li>
      <li><code>(slot-boundp instance slot-name)</code>: 判断是否绑定了值</li>
      <li><code>(slot-makunbound instance slot-name)</code>: unbind slot</li>
      <li><code>(slot-exists-p instance slot-name)</code>: 判断是否存在</li>
    </ul>
  </li>
  <li>Classification:
    <ul>
      <li><code>class-of</code>: 获得实例的类</li>
    </ul>
  </li>
  <li>Reclassification:
    <ul>
      <li><code>change-class</code></li>
      <li><code>update-instance-for-different-class</code></li>
    </ul>
  </li>
</ul>
<h3>Representing Generic Functions</h3>
<h4>The <code>defgeneric</code> Macro</h4>
<p>相当于是把 <code>defgeneric</code> 变成 <code>ensure-generic-function</code></p>
<p>类似于:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">ensure-generic-function</span><span class="w"> </span><span class="p">(</span><span class="nf">function-name</span><span class="w"> </span><span class="nv">&amp;rest</span><span class="w"> </span><span class="nv">keys</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">fboundp</span><span class="w"> </span><span class="nv">function-name</span><span class="p">)</span>
<span class="w">      </span><span class="o">...</span>
<span class="w">      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">gf</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;make-instance</span><span class="w"> </span><span class="ss">&#39;standard-generic-function</span><span class="w"> </span><span class="nv">:name</span><span class="w"> </span><span class="nv">function-name</span><span class="w"> </span><span class="nv">keys</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">fdefinition</span><span class="w"> </span><span class="nv">function-name</span><span class="p">)</span><span class="w"> </span><span class="nv">gf</span><span class="p">)</span>
<span class="w">        </span><span class="nv">gf</span><span class="p">)))</span>
</pre></div>
<h3>Representing Methods</h3>
<p>同上, <code>ensure-method</code>.</p>
<h3>Invoking Generic Functions</h3>
<h3>A Word About Preformance</h3>
<h2>Introspection and Analysis</h2>
<details><summary>这一部分读什么</summary>
<p>这部分主要给了一堆的接口可以用来在拓展 CLOS 的时候编程地实现属性的读取和写入.
  但是我没啥精力去抄书, 所以这部分不如直接看 API&#8230;</p>
</details>
<h2>Extending the Language</h2>
<h3>Specialized Class Metaobjects</h3>
<p>通过定义 Metaclass, 可以实现修改默认类实例的生成规则.</p>
<p>例:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defclass</span><span class="w"> </span><span class="nv">counted-class</span><span class="w"> </span><span class="p">(</span><span class="nf">standard-class</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="nf">counter</span><span class="w"> </span><span class="nv">:initform</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defmethod</span><span class="w"> </span><span class="nv">make-instance</span><span class="w"> </span><span class="nv">:after</span><span class="w"> </span><span class="p">((</span><span class="nf">class</span><span class="w"> </span><span class="nv">counted-class</span><span class="p">)</span><span class="w"> </span><span class="nv">&amp;key</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="p">(</span><span class="nf">slot-value</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="ss">&#39;counter</span><span class="p">)))</span>
</pre></div>
<p>一般的做法:</p>
<ol>
  <li>定义一个 metaobject class <code>(defclass CLASS (standard-class) (...) ...)</code></li>
  <li>在 CLOS 上修改对应的过程</li>
  <li>创建对应 metaobject class 的实例 &#8211; 即受 metaclass 行为控制的类</li>
</ol>
<h3>Terminology</h3>
<table>
  <tr><th>Terminology</th><th>Examples, Values</th></tr>
  <tr><td>standard metaobject classes</td><td><code>standrad-class</code>, <code>standard-generic-function</code>, <code>standard-method</code></td></tr>
  <tr><td>specialized metaobject classes</td><td>user defined subclasses of standard metaobject classes</td></tr>
  <tr><td>standard methods</td><td>methods</td></tr>
  <tr><td>metaobjects</td><td>instance of metaobject class</td></tr>
  <tr><td></td><td>specialized class metaobjects,</td></tr>
  <tr><td>metaobject class</td><td></td></tr>
</table>
<h3>Using Specialized Class Metaobject Classes</h3>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defclass</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:metaclass</span><span class="w"> </span><span class="nv">metaclass</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:metaclass-init-arg</span><span class="w"> </span><span class="nv">init-val</span><span class="p">))</span>
</pre></div>
<h3>Class Precedence Lists</h3>
<p>使用 <code>compute-class-precedence-list</code> 来得到一个类的所有的依赖列表.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">compute-class-precedence-list</span><span class="w"> </span><span class="p">(</span><span class="nf">find-class</span><span class="w"> </span><span class="ss">&#39;coca:ns-window</span><span class="p">))</span>
</pre></div>
<pre class="example">
(#&lt;coca.appkit:ns-window NSWindow 20BF3C908&gt;
 #&lt;coca.appkit::ns-responder NSResponder 20BF3D600&gt;
 #&lt;coca.foundation:ns-object NSObject 20BEDDD58&gt;
 #&lt;standard-class coca.objc:standard-objc-object&gt;
 #&lt;standard-class coca.objc::objc-pointer&gt;
 #&lt;standard-class common-lisp:standard-object&gt;
 #&lt;sb-pcl::slot-class sb-pcl::slot-object&gt; #&lt;sb-pcl:system-class common-lisp:t&gt;)
</pre>
<h3>Slot Inheritance</h3>
<h4>Slot Inheritance Protocol</h4>
<ul>
  <li><code>(compute-slots class)</code> 返回元素为 <code>effective-slot-definition</code> 的列表
    <p>在调用 <code>compute-slots</code> 时, <code>class-precedence-list</code> 应当已经被初始化;</p>
  </li>
  <li><code>(compute-effective-slot-definition class slots)</code> 用于合并 <code>slots</code>
    <ul>
      <li><code>slots</code>: 元素为 <code>direct-slot-definition</code> 的列表</li>
    </ul>
  </li>
</ul>
<h4>User Code for the Slot Extension</h4>
<p>AMOP 里面用了一个 <code>attributes-class</code> 来作为例子.
  这里直接抛开例子, 大概介绍一下过程:</p>
<ul>
  <li>需要一个 metaclass
    <ul>
      <li>通过 <code>compute-effective-slot-definition</code> 更改合并的逻辑或者参与合并的过程</li>
      <li>通过参与 <code>compute-slots</code> 过程来改变或者更新元数据</li>
    </ul>
  </li>
</ul>
<h3>Other Inheritance Protocols</h3>
<h4>Precomputing Default Initialization Arguments</h4>
<h3>Slot Access</h3>
<p>以下的接口可以重写默认的 slot 规则:</p>
<ul>
  <li><code>(slot-value-using-class class instance slot-name)</code></li>
  <li><code>(slot-boundp-using-class class instance slot-name)</code></li>
  <li><code>(slot-makunbound-using-class class instance slot-name)</code></li>
</ul>
<h3>Instance Allocation</h3>
<p>以下的接口可以重写默认的 slot 初始化规则:</p>
<ul>
  <li><code>(allocate-instance class)</code></li>
  <li><code>(slot-definition-allocation slot-definition)</code></li>
</ul>
<h2>Protocol Design</h2>
<p>因为并不关心这一部分, 所以就略过了.</p>
<h3>A Simple Generic Function Invocation Protocol</h3>
<h4>Generic Function Invocation</h4>
<h3>Functional and Procedural Protocols</h3>
<h4>Documenting Generic Functions vs Methods</h4>
<h4>Overriding the Standard Method</h4>
<h3>Layered Protocols</h3>
<h3>Improving Performance</h3>
<h4>Effective Method Functions</h4>
<h4>Method Functions</h4>
<h4>Discriminating Functions</h4>
<h4>Streamlined Generic Function Invocation</h4>
<h3>Protocol Design Summary</h3>
<h1>So, in Coca</h1>
<h2>About</h2>
<p>在 coca 这个项目里面, 因为我希望能够实现一个比较优雅的 Class property 的读取.
  于是希望能够实现这样的操作:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">slot-value</span><span class="w"> </span><span class="nv">objc-object</span><span class="w"> </span><span class="ss">&#39;objc-property</span><span class="p">)</span>
</pre></div>
<p>来代替 <code>(invoke objc-object objc-property)</code>:</p>
<p>核心的思路如下 (以下的内容建议配合代码 <a href="https://github.com/li-yiyang/coca/blob/1c0790af7d6855b6d8b4866d2dec19820f9409c7/objc/objc-class.lisp">objc-class.lisp</a> 进行阅读):</p>
<ul>
  <li>通过注册一个 <a href="https://github.com/li-yiyang/coca/blob/1c0790af7d6855b6d8b4866d2dec19820f9409c7/objc/objc-class.lisp#L56C11-L56C29">objc-property-slot</a> 来作为 <code>standard-slot-definition</code> 功能的 mixin,
    即对于 ObjC instance property, 其所有的逻辑性功能都在该类中实现</li>
  <li>在 MOP 中, 需要区分 <code>direct-slot-definition</code> 和 <code>effective-slot-definition</code>,
    前者类似于在 <code>defclass</code> 的时候定义的 <code>slot</code>,
    在确认 Class 初始化的时候 (<code>ensure-finalized</code>),
    会被转换/合并为 <code>effective-slot-definition</code>,
    即实际所持有的 <code>slot-definition</code></li>
</ul>
<p>于是就可以实现一个在 <code>coerce-to-objc-class</code> 的时候,
  自动化注册 <code>slot-definition</code> 的操作.</p>
<h1>后记</h1>
<p>AMOP 属于是那种, 从一个非常简单的小例子开始, 慢慢不知不觉就实现了一个庞大系统的书.
  不过由于这个庞大系统的耦合性实在是太强了, 只实现一个简单的小组件/或者说,
  只实现 <code>defclass</code> 好像没啥用 &#8211; 因为确实 OOP 的知识不是这本书应该讲的内容.</p>
<p>我现在想要的教科书应该也是类似这样的教科书, 从一些最简单的部分开始,
  然后慢慢地构建一个庞大的系统 &#8211; 听起来好像和现在的教学没啥区别,
  大家不都是从一个简单的, 几乎类似于公理一样的一些前提假设出发,
  不断地添加新的知识点/记忆点吗? 好像确实, 但是这个构建的过程应当是可以复用的,
  是可以重新定义的. 比如说实现了计算素数的函数, 那么之后就可以重复应用这个函数,
  来实现更加复杂的功能, 然后在性能或者表达能力受限的时候,
  重新返回过来去修正&#8230; 好像确实就应当是正常的教学设计本来应该的方式.</p>
<p>那么还应该添加一个可以预见的目标 &#8211; 应当是携带着目标来去实现最终的结果,
  这样会有一个全局的视野 &#8211; 这样利用 REPL 编程的好处就可以显现出来了:
  一开始可以构建一些不存在的辅助函数, 比如说先实现了一个类似于伪代码一样的主函数,
  其中的各种功能分支像是占位符一样得先放在这里 &#8211; 也许是已经存在的,
  也许是需要调优的, 也许是还没有实现的. 总之这样在之后的更细的小任务里面,
  应该就不会迷失具体最终要做什么.</p>]]></content><author><name></name></author><category term="lisp" /><summary type="html"><![CDATA[About 虽然之前写的/之前的 MOP 阅读和学习尝试都有点中道崩猝. 要说这次可能有什么不同的话, 那就是至少我现在是带着项目进行的学习了. 嗯, 应该可以这么说吧&#8230; (coca 和 mlx-cl). 注: 假如有兴趣的话, 不妨来试试 MOPDoc, 为 MOP 添加 documentation string. 这样就可以用 SLIME/SLY 来 inspect. 这里参考的是 AMOP (Art of MetaObject Protocol). The Design and Implementation of Metaobject Protocols How CLOS is Implemented A Subset of CLOS 书中是用了一个 CLOS 的子集来做教学例子. 这里就用真实对应的 CLOS 和 closer-mop 进行联系. 以下的代码在 CLOSER-COMMON-LISP-USER 下运行. 注: 这部分建议读什么 感觉这部分属于是作者小小炫技了: 在 CLOS 上实现一个 CLOS 的子集. 但是我并不是很关心具体是怎么实现的, 所以读这一部分的时候基本是跳着读的. 其实这部分可以主要用来关注在 CLOS 的 interface 下面的具体发生了什么过程. 比如创建实例 make-instance 的时候, 发生了什么过程: allocate-instance initialize-instance The Basic Backstage Structures Representing Classes 在 standard-class 这个 Metaclass 类中, 有以下的 slots: (mapcar #&#39;slot-definition-name (class-slots (find-class &#39;standard-class))) sb-pcl::%typesb-pcl::sourcesb-pcl::plistsb-pcl::namesb-pcl::class-eq-specializersb-pcl::direct-superclassessb-pcl::direct-subclassessb-pcl::direct-methodssb-pcl::%documentationsb-pcl::safe-psb-pcl::finalized-psb-pcl::%class-precedence-listsb-pcl::cpl-available-psb-pcl::can-precede-listsb-pcl::incompatible-superclass-listsb-pcl::wrappersb-pcl::prototypesb-pcl::direct-slotssb-pcl::slots The defclass Macro 可以把 defclass 的过程看作是: (defmacro defclass (name direct-superclasses direct-slots &amp;rest options) `(ensure-class &#39;,name :direct-superclasses ,(canonicalize-direct-superclasses direct-superclasses) :direct-slots ,(canonicalize-direct-slots direct-slots) ,@(canonicalize-defclass-options options))) 其中 canonicalize- 的这些部分可以暂时当作是一个正则化的过程, 忽略. 注: 实际上可能并不是这样实现的 defclass. Direct Superclasses 是一组 superclasses 的列表. (defun canonicalize-direct-superclasses (direct-superclasses) (mapcar #&#39;find-class direct-superclasses)) Direct Slots name \(&rarr;\) :name name initform \(&rarr;\) :initform initform :initfunction (lambda () initform) 其中 :initfunction: 是一个无参数的 lambda 函数, 用于在 lexical 环境被调用生成初始化的值 :initform: 仅是被保留用于可读性 initarg \(&rarr;\) :initargs (initarg initarg...) accessor \(&rarr;\) :reader accessor :writer (setf accessor) reader \(&rarr;\) :readers (reader reader...) writer \(&rarr;\) :writers (writer writer...) 例: (ensure-class &#39;class :direct-superclasses (...) :direct-slots (list (list :name &#39;name ; slot-definition-name :initform &#39;val ; slot-definition-initform :initfunction #&#39;(lambda () val) ; slot-definition-initfunction :initargs &#39;(:name) ; slot-definition-initargs :readers &#39;(name) ; slot-definition-readers :writers &#39;((setf name))))) ; slot-definition-writers Class Options 被转换为 plist 作为更多的参数如下被 ensure-class 类似如下调用: (make-instance &#39;standard-class ,@class-options-plist) ensure-class 相当于是做了如下的事情: make-instance: 从 Metaclass 创建了一个 class 类 (setf find-class): 在 class lookup table 中注册对应的类 Intializing Class Metaobjects 生成 direct-superclasses 向 superclass 的 direct-subclasses 添加自己 定义 reader 和 accessor 函数 以及处理其他的继承关系 Inheritance 计算类的继承关系 计算 slot: 从父类中继承, 并最终生成 effective-slot-definition Printing Objects 调用 print-object. Representing the Structure of Instances Object identity make-instance: 类似于如下的过程 (let ((instance (allocate-instance class))) (apply #&#39;initialize-instance instance initargs) instance) initialize-instance, reinitialize-instance 都共同地使用了 shared-initialize Slot storage: (alocate-instance class &amp;rest args): 为类实例及其 slots 划分空间 (slot-value instance slot-name): 获取实例的 slot 的值 (slot-boundp instance slot-name): 判断是否绑定了值 (slot-makunbound instance slot-name): unbind slot (slot-exists-p instance slot-name): 判断是否存在 Classification: class-of: 获得实例的类 Reclassification: change-class update-instance-for-different-class Representing Generic Functions The defgeneric Macro 相当于是把 defgeneric 变成 ensure-generic-function 类似于: (defun ensure-generic-function (function-name &amp;rest keys) (if (fboundp function-name) ... (let ((gf (apply #&#39;make-instance &#39;standard-generic-function :name function-name keys))) (setf (fdefinition function-name) gf) gf))) Representing Methods 同上, ensure-method. Invoking Generic Functions A Word About Preformance Introspection and Analysis 这一部分读什么 这部分主要给了一堆的接口可以用来在拓展 CLOS 的时候编程地实现属性的读取和写入. 但是我没啥精力去抄书, 所以这部分不如直接看 API&#8230; Extending the Language Specialized Class Metaobjects 通过定义 Metaclass, 可以实现修改默认类实例的生成规则. 例: (defclass counted-class (standard-class) ((counter :initform 0)))]]></summary></entry><entry><title type="html">ObjC (00): ObjC Runtime Inspector</title><link href="/lisp/objc/objc-0/" rel="alternate" type="text/html" title="ObjC (00): ObjC Runtime Inspector" /><published>2025-12-09T00:00:00+00:00</published><updated>2025-12-09T00:00:00+00:00</updated><id>/lisp/objc/objc-0</id><content type="html" xml:base="/lisp/objc/objc-0/"><![CDATA[<h1>About</h1>
<p>这估计又会是一次比较失败的 ObjC-bridge 的尝试 &#8211; 但是我可以比较高兴地说,
  虽然之前的每次都是比较失败的, 至少次次我都有一些新的东西学到.</p>
<p>这次的目标大概就是能够实现一个简单的 ObjC Runtime Inspector:</p>
<ol>
  <li><code>(coerce-to-objc-class objc-class-name)</code> 会生成一个 Lisp Class:
    比如 <code>(coerce-to-objc-class &quot;NSString&quot;)</code> 会生成 <code>ns-string</code> 类,
    同时绑定一堆的类/实例的方法
    <p>这里参考的是 <a href="https://felixk15.github.io/posts/c_ocoa/">Develop with Cocoa for Apple Devices without using Objective-C</a></p>
  </li>
  <li>在 <code>(invoke obj sel &amp;rest args)</code> 的时候实现一个传 <code>struct</code> 参数的功能,
    从而实现能够 <code>(make-ns-rect :x x :y y :width width :height height)</code>
    并最终实现可以创建一个最简单的窗口</li>
</ol>
<h1>ObjC Runtime with JUST C API</h1>
<blockquote>
  <p>The Objective-C runtime is a runtime library that provides support for
    the dynamic properties of the Objective-C language, and as such is
    linked to by all Objective-C apps. Objective-C runtime library support
    functions are implemented in the shared library found at
    /usr/lib/libobjc.A.dylib.</p>
</blockquote>
<p>(ref: <a href="https://developer.apple.com/documentation/objectivec/objective-c-runtime?language=objc">Objective-C Runtime</a>)</p>
<p>ObjC Runtime 可以被看作是一个纯 C 的 API, 尽管历史上有一些尝试 Cross-compile ObjC
  到 C 的操作 (比如 <a href="https://web.archive.org/web/20190110121255/http://users.telenet.be/stes/compiler.html">Protable Object Compiler</a>), 或者是使用 clang 的 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-rewrite-objc">=-rewrite-objc=</a>.
  但是实际上貌似也没有很好用&#8230;</p>
<details><summary>关于 -rewrite-objc</summary>
<p>假如有这样的 <code>test.m</code> 代码文件</p>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="c1">// --- Main Entry Function ---</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">@autoreleasepool</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Hello World&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>可以如下实现 &#8220;rewrite&#8221; 的操作:</p>
<div class="highlight"><pre><span></span>clang<span class="w"> </span>-rewrite-objc<span class="w"> </span>test.m<span class="w"> </span>-o<span class="w"> </span>test.cpp
</pre></div>
<p>但是实际上得到的结果几乎是不可读的. 不过有一个小 trick:
  你可以通过构建一个空代码文档:</p>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</pre></div>
<p>然后用 <code>diff</code> 的方式来判断相比空文件,
  新的代码在 rewrite 的时候有什么不同.</p>
<div class="highlight"><pre><span></span>diff<span class="w"> </span>empty.cpp<span class="w"> </span>test.cpp
</pre></div>
<pre class="example">
108a109
&gt; static __NSConstantStringImpl __NSConstantStringImpl__var_folders_j2_gn8hljx139d7671xs5x0xw400000gn_T_test_4a1764_mi_0 __attribute__ ((section (&quot;__DATA, __cfstring&quot;))) = {__CFConstantStringClassReference,0x000007c8,&quot;Hello World&quot;,11};
63348c63349,63354
&lt;
---
&gt; int main(int argc, const char * argv[]) {
&gt;     /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
&gt;       NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_j2_gn8hljx139d7671xs5x0xw400000gn_T_test_4a1764_mi_0);
&gt;     }
&gt;     return 0;
&gt; }
</pre>
</details>
<p>欸, 但是现在不是有 LLM AI 么? 大可以让 AI 来帮我们重写.</p>
<pre class="example">
Rewrite the following Objective-C code using ObjC runtime with only valid C code.
Return code only with out explanation. The code logic should be same as original,
with minimal comments.


</pre>
<details><summary>一个例子</summary>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;objc/objc.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;objc/runtime.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;objc/message.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// Function pointer typedef for better readability and casting</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">NSObjectInitMethod</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">);</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">NSLogMethod</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">,</span><span class="w"> </span><span class="n">NSString</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Manually setting up the Autorelease Pool equivalent (less strict than @autoreleasepool)</span>
<span class="w">    </span><span class="c1">// In pure C/runtime context, setting up a pool requires calling NSObject/NSAutoreleasePool methods.</span>
<span class="w">    </span><span class="c1">// However, for a simple `NSLog` call, we often rely on the runtime environment</span>
<span class="w">    </span><span class="c1">// or manually interact with NSAutoreleasePool. Since NSAutoreleasePool is deprecated</span>
<span class="w">    </span><span class="c1">// and modern ObjC uses scope-based pools, we&#39;ll try to simulate the minimum environment</span>
<span class="w">    </span><span class="c1">// to allow ObjC calls to work, which often means initializing an autorelease pool</span>
<span class="w">    </span><span class="c1">// and draining it.</span>

<span class="w">    </span><span class="n">Class</span><span class="w"> </span><span class="n">NSAutoreleasePoolClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSAutoreleasePool&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">SEL</span><span class="w"> </span><span class="n">initSel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">SEL</span><span class="w"> </span><span class="n">newSel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;new&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">SEL</span><span class="w"> </span><span class="n">drainSel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;drain&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">SEL</span><span class="w"> </span><span class="n">NSLogSel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;NSLog&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Create an autorelease pool instance: [NSAutoreleasePool new];</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="n">pool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Class</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">NSAutoreleasePoolClass</span><span class="p">,</span><span class="w"> </span><span class="n">newSel</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Call NSLog: NSLog(@&quot;Hello World&quot;);</span>
<span class="w">    </span><span class="c1">// We need to get the NSString * object for @&quot;Hello World&quot;</span>
<span class="w">    </span><span class="c1">// Since we can&#39;t use the Objective-C literal @&quot;...&quot;, we must rely on</span>
<span class="w">    </span><span class="c1">// an external mechanism or the runtime&#39;s internal string creation.</span>
<span class="w">    </span><span class="c1">// For simplicity in a self-contained C file, we often assume the constant</span>
<span class="w">    </span><span class="c1">// string exists or use a bridging function. A common way for known strings</span>
<span class="w">    </span><span class="c1">// is to use C-string bridges, but the most correct runtime way is to find</span>
<span class="w">    </span><span class="c1">// the static string object defined by the compiler.</span>
<span class="w">    </span><span class="c1">// Given the constraints of &quot;pure C code&quot;, we cannot easily create</span>
<span class="w">    </span><span class="c1">// an NSString* object that the C code doesn&#39;t define.</span>
<span class="w">    </span><span class="c1">// If we assume the ObjC runtime is initialized and handles string literals</span>
<span class="w">    </span><span class="c1">// in the same manner as a compiled ObjC file (which is a stretch for pure C),</span>
<span class="w">    </span><span class="c1">// we would use a predefined external pointer.</span>

<span class="w">    </span><span class="c1">// As a simplification, we must usually cheat and use an external symbol</span>
<span class="w">    </span><span class="c1">// or use a helper function to get an NSString.</span>
<span class="w">    </span><span class="c1">// The closest to a pure C solution while still being valid ObjC runtime is</span>
<span class="w">    </span><span class="c1">// to use the external symbol `__CFStringMakeConstantString` or `objc_auto.c`&#39;s</span>
<span class="w">    </span><span class="c1">// string mechanism.</span>

<span class="w">    </span><span class="c1">// ******* Using a common workaround to get a static NSString *******</span>
<span class="w">    </span><span class="c1">// This function is usually what the compiler calls for @&quot;...&quot;</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="n">__CFStringMakeConstantString</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Create the NSString* object for &quot;Hello World&quot;</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="n">helloWorldString</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__CFStringMakeConstantString</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Call NSLog((id)nil, NSLogSel, helloWorldString);</span>
<span class="w">    </span><span class="c1">// NSLog is a variadic function and is usually called as a C function or via</span>
<span class="w">    </span><span class="c1">// a special objc_msgSend variant. The standard `NSLog` signature is:</span>
<span class="w">    </span><span class="c1">// void NSLog(NSString *format, ...);</span>
<span class="w">    </span><span class="c1">// When called via message passing, it looks like:</span>
<span class="w">    </span><span class="c1">// ((void (*)(id, SEL, id))objc_msgSend)(nil, NSLogSel, helloWorldString);</span>

<span class="w">    </span><span class="c1">// Use objc_msgSend for the call. NSLog&#39;s &quot;receiver&quot; is typically `nil` or treated as a C function.</span>
<span class="w">    </span><span class="c1">// It&#39;s safer to call it as a C function if the environment is set up.</span>
<span class="w">    </span><span class="c1">// For strict `objc_msgSend` use:</span>
<span class="w">    </span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">nil</span><span class="p">,</span><span class="w"> </span><span class="n">NSLogSel</span><span class="p">,</span><span class="w"> </span><span class="n">helloWorldString</span><span class="p">);</span>


<span class="w">    </span><span class="c1">// Drain the pool: [pool drain];</span>
<span class="w">    </span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">pool</span><span class="p">,</span><span class="w"> </span><span class="n">drainSel</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</details>
<p>基本上还算是可以使用的, 所以用这样的方法可以快速得到如何在 C 里面去使用 ObjC Runtime 的例子了.</p>
<h1>Inspect ObjC Runtime</h1>
<h2>Wrapper of foreign-pointer</h2>
<p>这里用:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defclass</span><span class="w"> </span><span class="nv">objc-pointer</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">((</span><span class="nf">objc-object-pointer</span>
<span class="w">    </span><span class="nv">:initarg</span><span class="w">       </span><span class="nv">:objc-object-pointer</span>
<span class="w">    </span><span class="nv">:reader</span><span class="w">        </span><span class="nv">objc-object-pointer</span><span class="p">)))</span>
</pre></div>
<p>来处理 <code>foreign-pointer</code>.</p>
<p>核心的思想是通过 <code>objc-pointer</code> 这个类来对 <code>foreign-pointer</code> 进行类型标记.
  同时可以根据不同的类型来处理 <code>foreign-pointer</code>.</p>
<details><summary>ObjC 中的各种指针</summary>
<table>
  <tr><th>ObjC Runtime Pointer</th><th>Lisp Class</th><th>Note</th></tr>
  <tr><td><a href="https://developer.apple.com/documentation/objectivec/class?language=objc">typedef struct objc_class * Class;</a></td><td><code>objc-class</code></td><td></td></tr>
  <tr><td><a href="https://developer.apple.com/documentation/objectivec/sel?language=objc">typedef struct objc_selector * SEL;</a></td><td><code>sel</code></td><td></td></tr>
</table>
<p>P.S. 传指针才是好文明, 传结构体真不是个好决定&#8230; 说的就是你啊, <a href="https://developer.apple.com/documentation/foundation/nsrect?language=objc">NSRect</a>!</p>
</details>
<h2>Class</h2>
<p>在 ObjC Runtime 中, 提供了很多的 meta-programming 的接口,
  这里不妨和 Common Lisp 的 <a href="https://www.lispworks.com/documentation/lw81/MOP/mop/index.html">MOP (MetaObject Protocol)</a> 一起对比来看:</p>
<table>
  <tr><th>ObjC Runtime</th><th>MOP</th><th>Note</th></tr>
  <tr><td><a href="https://developer.apple.com/documentation/objectivec/class_getname(_:)?language=objc">class_getName</a></td><td><code>(class-name class)</code></td><td>获取 <code>class</code> 的名字</td></tr>
  <tr><td><a href="https://developer.apple.com/documentation/objectivec/class_getsuperclass(_:)?language=objc">class_getSuperClass</a></td><td><code>(c2mop:class-direct-superclasses class)</code></td><td>获取 <code>class</code> 的父类</td></tr>
  <tr><td>&lt;a href=&#8221;https://developer.apple.com/documentation/objectivec/objc_getclasslist(@@html:<span style="text-decoration:underline;">@@:@@html:</span>@@:)?language=objc&#8221;&gt;objc_getClassList</a></td><td></td><td>获取当前 runtime 中的所有的类</td></tr>
</table>
<details><summary>c2mop</summary>
<p>因为不同的 Lisp 实现对应的有不同的 MOP 实现,
  所以在这里用 <a href="https://github.com/pcostanza/closer-mop">closer-mop</a> 来实现 MOP 的 Layer.</p>
<p>不过这里就体现出了 Common Lisp (或者说 Lisp) 的历史问题了. 因为 Lisp 出现得太早了,
  大部分的计算机变成范式还完全没有出现, 每个人都在用自己的方式来提出自己的设计,
  然后哪怕出现了 ANSI Common Lisp, 他们重新定义的 Common Lisp 的标准仍然是 &#8220;当年&#8221;
  觉得比较好的设计. 从现在来看, 一些函数名称就没有那么现代了.</p>
<p>比如在 tsoding 写 Emacs 插件的直播 (<a href="https://youtu.be/QH6KOEVnSZA">I wrote an Emacs plugin (YouTube)</a>, <a href="https://www.bilibili.com/video/BV1EA2pBkE5V/">(Bilibili)</a>)
  里面就可以看出不怎么写 Lisp 的人对 Lisp 的 API 的吐槽.</p>
</details>
<details><summary>graphviz</summary>
<p>我突然有一个很贱的想法, 如果把整个的继承关系全部画在一张图片里面:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">dot-subclass-plot</span><span class="w"> </span><span class="p">(</span><span class="nf">class</span><span class="w"> </span><span class="nv">&amp;key</span><span class="w"> </span><span class="nv">exclude</span><span class="w"> </span><span class="nv">stream</span>
<span class="w">                                  </span><span class="p">(</span><span class="nf">rankdir</span><span class="w"> </span><span class="s">&quot;LR&quot;</span><span class="p">)</span>
<span class="w">                                  </span><span class="p">(</span><span class="nf">node</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">:shape</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">:rect</span><span class="p">)))</span>
<span class="w">                                  </span><span class="p">(</span><span class="nf">edge</span><span class="w"> </span><span class="o">&#39;</span><span class="p">()))</span>
<span class="w">  </span><span class="s">&quot;Generate DOT plot of CLASS.</span>
<span class="s">Write output to STREAM.</span>

<span class="s">Parameters:</span>
<span class="s">+ CLASS: start root lisp class</span>
<span class="s">+ EXCLUDE: a list of classes to exclude</span>
<span class="s">+ STREAM: DOT code output stream</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">null</span><span class="w"> </span><span class="nv">stream</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">with-output-to-string</span><span class="w"> </span><span class="p">(</span><span class="nf">stream</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">dot-subclass-plot</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">:exclude</span><span class="w"> </span><span class="nv">exclude</span><span class="w"> </span><span class="nv">:stream</span><span class="w"> </span><span class="nv">stream</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">class</span><span class="w">  </span><span class="p">(</span><span class="nf">find-class</span><span class="w"> </span><span class="nv">class</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nf">exclue</span><span class="w"> </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;find-class</span><span class="w"> </span><span class="nv">exclude</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">labels</span><span class="w"> </span><span class="p">((</span><span class="nf">attr</span><span class="w"> </span><span class="p">(</span><span class="nf">which</span><span class="w"> </span><span class="nv">attrs</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">etypecase</span><span class="w"> </span><span class="nv">attrs</span>
<span class="w">                     </span><span class="p">(</span><span class="nb">string</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">stream</span><span class="w"> </span><span class="s">&quot;~A [~A];~%&quot;</span><span class="w"> </span><span class="nv">which</span><span class="w"> </span><span class="nv">attrs</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="nb">list</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">stream</span><span class="w"> </span><span class="s">&quot;~A [&quot;</span><span class="w"> </span><span class="nv">which</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="p">(</span><span class="nf">prop</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">attrs</span><span class="w"> </span><span class="nv">:do</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">stream</span><span class="w"> </span><span class="s">&quot;~A=~A,&quot;</span><span class="w"> </span><span class="nv">prop</span><span class="w"> </span><span class="nv">val</span><span class="p">))</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">stream</span><span class="w"> </span><span class="s">&quot;];~%&quot;</span><span class="p">))))</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">excludep</span><span class="w"> </span><span class="p">(</span><span class="nf">class</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">member</span><span class="w"> </span><span class="nv">class</span><span class="w"> </span><span class="nv">exclude</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;equal</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">iter</span><span class="w"> </span><span class="p">(</span><span class="nf">class</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">subclasses</span><span class="w"> </span><span class="p">(</span><span class="nf">remove-if</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;excludep</span><span class="w"> </span><span class="p">(</span><span class="nf">c2mop:class-direct-subclasses</span><span class="w"> </span><span class="nv">class</span><span class="p">))))</span>
<span class="w">                     </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">subclasses</span>
<span class="w">                       </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">stream</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">~A</span><span class="se">\&quot;</span><span class="s"> -&gt; {~{</span><span class="se">\&quot;</span><span class="s">~A</span><span class="se">\&quot;</span><span class="s">~^, ~}};~%&quot;</span>
<span class="w">                               </span><span class="p">(</span><span class="nf">objc-class-name</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span>
<span class="w">                               </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;objc-class-name</span><span class="w"> </span><span class="nv">subclasses</span><span class="p">))</span>
<span class="w">                       </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;iter</span><span class="w"> </span><span class="nv">subclasses</span><span class="p">)))))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">write-line</span><span class="w"> </span><span class="s">&quot;digraph {&quot;</span><span class="w"> </span><span class="nv">stream</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">stream</span><span class="w"> </span><span class="s">&quot;rankdir=~A;~%&quot;</span><span class="w"> </span><span class="nv">rankdir</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="p">(</span><span class="nf">attr</span><span class="w"> </span><span class="s">&quot;node&quot;</span><span class="w"> </span><span class="nv">node</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">edge</span><span class="w"> </span><span class="p">(</span><span class="nf">attr</span><span class="w"> </span><span class="s">&quot;edge&quot;</span><span class="w"> </span><span class="nv">edge</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">iter</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nf">write-line</span><span class="w"> </span><span class="s">&quot;}&quot;</span><span class="w"> </span><span class="nv">stream</span><span class="p">)))))</span>
</pre></div>
<p>没啥特别的, 大伙看看散了吧:</p>
<p><img src="/_img/lisp/objc/ns-object-subclasses.svg" alt="/_img/lisp/objc/ns-object-subclasses.svg" /></p>
<p>P.S. 这图还挺大, 不知道会不会拖慢网页加载速度&#8230; 不过现在这个博客也就是个屎山了,
  懒得改.</p>
</details>
<h2>Methods</h2>
<h3>Method Part-Zero: funcall is <code>[obj SEL ...]</code></h3>
<p>现在大伙都知道了, <code>[obj SEL ...]</code> 是 ObjC 调用方法的一种特殊操作,
  其本质对应于 ObjC Runtime 中的 <a href="https://developer.apple.com/documentation/objectivec/objc_msgsend?language=objc">objc_msgSend</a>.</p>
<p>而 <a href="https://developer.apple.com/documentation/objectivec/sel?language=objc">SEL</a>, 形如 <a href="https://developer.apple.com/documentation/foundation/nsstring/init(utf8string:)-8bcy8?language=objc">stringWithUTF8String:</a>, 通过 <a href="https://developer.apple.com/documentation/objectivec/sel_registername(_:)?language=objc">sel_registerName</a> 的方式,
  将 <code>SEL</code> 的名字和其地址指针挂钩.</p>
<details><summary><code>@</code></summary>
<p>感觉 ObjC 的作者挺喜欢用 <code>@</code> 来标记语法的.</p>
<p>比如 <code>NSString</code> 可以通过:</p>
<div class="highlight"><pre><span></span><span class="bp">NSString</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="bp">NSString</span><span class="w"> </span><span class="n">stringWithUTF8String</span><span class="o">:</span><span class="w"> </span><span class="n">c_string</span><span class="p">];</span>
</pre></div>
<p>的方式来进行创建, 也可以通过 =@&#8221;c string&#8221;= 的方式来进行创建.
  假如了解 C 的语法, 那么其实从 C 变到 ObjC 还是挺自然的.</p>
<p>比如在 C 里面已经把 <code>func(arg)</code> 形式占用了, 为了保证不会破坏原有的 C 函数,
  ObjC 的做法是通过引入 <code>[obj SEL arg]</code> 的方式来实现类似于 <code>obj.SEL(arg)</code> 形式的函数调用.
  (感觉想是一开始想用 <code>SEL[obj, arg]</code> 形式, 但是发现 <code>arr[]</code> 的语法被数组占用了,
  所以变成了方便编译器实现的 <code>[obj SEL arg]</code> 语法).</p>
<p>并且 ObjC 的关键词大多也是 <code>@</code> 开头的, 比如 <code>@implement</code> 之类的.</p>
<p>不过也有可能是历史原因, 因为需要兼容 C 的语法 (C-extension like),
  所以像 Cpp/Python/JS 那样的 <code>balabala.method(bala)</code>
  的调用形式不容易在 C 里面实现/移植?</p>
<p>注: 虽说是模仿的 Smalltalk, 但是我怎么看都不觉得 Smalltalk 的语法,
  额, 易读. 应该是 OOP 的思想是模仿 Smalltalk 中的设计吧.</p>
<div class="highlight"><pre><span></span><span class="nf">exampleWithNumber:</span> <span class="nv">x</span>
    <span class="o">|</span><span class="nv"> y </span><span class="o">|</span>
    <span class="bp">true</span> <span class="nf">&amp;</span> <span class="bp">false</span> <span class="nf">not</span> <span class="nf">&amp;</span> (<span class="bp">nil</span> <span class="nf">isNil</span>) <span class="nb">ifFalse:</span> [<span class="bp">self</span> <span class="nf">halt</span>]<span class="p">.</span>
    <span class="nv">y</span> <span class="o">:=</span> <span class="bp">self</span> <span class="nf">size</span> <span class="nf">+</span> <span class="bp">super</span> <span class="nf">size</span><span class="p">.</span>
    <span class="ss">#(</span><span class="sc">$a</span> <span class="ss">#a</span> <span class="s">&#39;a&#39;</span> <span class="m">1</span> <span class="m">1.0</span><span class="ss">)</span>
        <span class="nf">do:</span> [ <span class="o">:</span><span class="nv">each</span> <span class="o">|</span>
            <span class="nc">Transcript</span> <span class="nf">show:</span> (<span class="nv">each</span> <span class="nf">class</span> <span class="nf">name</span>)<span class="p">;</span>
                       <span class="nf">show:</span> <span class="s">&#39; &#39;</span>]<span class="p">.</span>
    <span class="o">^</span><span class="nv">x</span> <span class="nf">&lt;</span> <span class="nv">y</span>
</pre></div>
<p>不过感觉那个时代的计算机语言设计更适合在纸上书写而不是在屏幕上阅读&#8230;</p>
<p>注: 你可以在网页上体验 Smalltalk Machine. 试用体验上来说, 感觉和 Lisp Machine
  是同时代的设计.</p>
</details>
<h3>Method Part-I: Inspect <code>Method</code> data</h3>
<p>使用 &lt;a href=&#8221;https://developer.apple.com/documentation/objectivec/class_getinstancemethod(@@html:<span style="text-decoration:underline;">@@:@@html:</span>@@:)?language=objc&#8221;&gt;class_getInstanceMethod</a> 和 &lt;a href=&#8221;https://developer.apple.com/documentation/objectivec/class_getclassmethod(@@html:<span style="text-decoration:underline;">@@:@@html:</span>@@:)?language=objc&#8221;&gt;class_getClassMethod</a> 可以根据 <code>Class</code> 和 <code>SEL</code>
  来找到对应的 <code>Method</code> &#8211; 一个指向具体方法实现元数据的指针.</p>
<ul>
  <li>通过 <a href="https://developer.apple.com/documentation/objectivec/method_getname(_:)?language=objc">method_getName</a> 可以得到其对应的 <code>SEL</code>, 从而又可以得到其对应的名称.</li>
  <li>通过 <a href="https://developer.apple.com/documentation/objectivec/method_gettypeencoding(_:)?language=objc">method_getTypeEncoding</a> 可以得到其对应的返回值, 参数类型
    <p>注: 可以参考 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a> 来实现一个 Type Encoding parser.</p>
  <details><summary>一个简单的做法</summary>
    <p>通过 <code>method_getTypeEncoding</code> 得到的字符串类似于: =&#8221;@24@0:8r*16&#8221;=,
      其可以被看作是一列 Type Encoding 的 <code>concat</code>.</p>
    <p>于是可以实现一个 <code>(parse-type-encoding string &amp;key start)</code>,
      其返回值为 <code>type-encoding</code>, <code>ends</code>. 于是就可以递归地去 parse 给定的 type encoding.</p>
  </details>
  </li>
</ul>
<p>那么既然有了 Type Encoding, 于是就可以在 Lisp 侧去编译一个调用 <code>objc_msgSend</code> 过程的函数.
  在 Lisp 中, 实现类似的操作并不是一个非常困难的事情:</p>
<p>比如说有 <code>[NSString stringWithUTF8String: string]</code>, 其函数 Type Encoding 可以被 parse 为:</p>
<div class="highlight"><pre><span></span><span class="nv">objc&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-class-method-signature</span><span class="w"> </span><span class="s">&quot;NSString&quot;</span><span class="w"> </span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">:object</span><span class="w"> </span><span class="nv">:sel</span><span class="w"> </span><span class="p">(</span><span class="nf">:const</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">:string</span><span class="p">))</span>
<span class="nv">:object</span>
<span class="s">&quot;@24@0:8r*16&quot;</span>
</pre></div>
<p>那么调用的形式应当为:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">class</span><span class="w"> </span><span class="nv">sel</span><span class="w"> </span><span class="nb">string</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">coerce-to-objc-object</span>
<span class="w">   </span><span class="p">(</span><span class="nf">foreign-funcall</span>
<span class="w">    </span><span class="s">&quot;objc_msgSend&quot;</span>
<span class="w">    </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-object-pointer</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span>
<span class="w">    </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-object-pointer</span><span class="w"> </span><span class="nv">sel</span><span class="p">)</span>
<span class="w">    </span><span class="nv">:string</span><span class="w">  </span><span class="nb">string</span>
<span class="w">    </span><span class="nv">:pointer</span><span class="p">)))</span>
</pre></div>
<details><summary>一个困难</summary>
<p>一个稍微有点困难的地方就是不知道该怎么传入 <code>struct</code> 类型的数&#8230;
  一个暴力一点的做法就是把 <code>struct</code> 向量化然后一个个传入调用帧里面, 类似于这样:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">class</span><span class="w"> </span><span class="nv">sel</span><span class="w"> </span><span class="nv">cg-point</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">coerce-to-objc-object</span>
<span class="w">   </span><span class="p">(</span><span class="nf">foreign-funcall</span>
<span class="w">    </span><span class="s">&quot;objc_msgSend&quot;</span>
<span class="w">    </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-object-pointer</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span>
<span class="w">    </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-object-pointer</span><span class="w"> </span><span class="nv">sel</span><span class="p">)</span>
<span class="w">    </span><span class="c1">;; (:struct &quot;CGSize&quot; (:double :double))</span>
<span class="w">    </span><span class="nv">:double</span><span class="w">  </span><span class="p">(</span><span class="nf">cg-point-x</span><span class="w"> </span><span class="nv">cg-point</span><span class="p">)</span>
<span class="w">    </span><span class="nv">:double</span><span class="w">  </span><span class="p">(</span><span class="nf">cg-point-y</span><span class="w"> </span><span class="nv">cg-point</span><span class="p">)</span>
<span class="w">    </span><span class="nv">:pointer</span><span class="p">)))</span>
</pre></div>
<p>这个方法虽然感觉有点不合理, 但是能跑&#8230; 但是该如何程序化地去实现, 就有点难搞了.
  当然, 还有一个比较困难的地方是, 对于结构体的结构体, 在传参数的时候会遇到如下的问题:</p>
<p>比如有一个 <code>cg-rect</code> (<code>CGRect</code>) 的结构, 其包含 <code>origin</code> (<code>CGPoint</code>) 和 <code>size</code> (<code>CGSize</code>)
  两个结构作为自己的子值&#8230; 虽然仍然可以用形如</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">class</span><span class="w"> </span><span class="nv">sel</span><span class="w"> </span><span class="nv">ns-rect</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">coerce-to-objc-object</span>
<span class="w">   </span><span class="p">(</span><span class="nf">foreign-funcall</span>
<span class="w">    </span><span class="s">&quot;objc_msgSend&quot;</span>
<span class="w">    </span><span class="nv">:double</span><span class="w"> </span><span class="p">(</span><span class="nf">cg-rect-origin</span><span class="w"> </span><span class="p">(</span><span class="nf">cg-point-x</span><span class="w"> </span><span class="nv">ns-rect</span><span class="p">))</span>
<span class="w">    </span><span class="nv">:double</span><span class="w"> </span><span class="p">(</span><span class="nf">cg-rect-origin</span><span class="w"> </span><span class="p">(</span><span class="nf">cg-point-y</span><span class="w"> </span><span class="nv">ns-rect</span><span class="p">))</span>
<span class="w">    </span><span class="nv">:double</span><span class="w"> </span><span class="p">(</span><span class="nf">cg-rect-size</span><span class="w">   </span><span class="p">(</span><span class="nf">cg-size-w</span><span class="w">  </span><span class="nv">ns-rect</span><span class="p">))</span>
<span class="w">    </span><span class="nv">:double</span><span class="w"> </span><span class="p">(</span><span class="nf">cg-rect-size</span><span class="w">   </span><span class="p">(</span><span class="nf">cg-size-h</span><span class="w">  </span><span class="nv">ns-rect</span><span class="p">)))))</span>
</pre></div>
<p>来绕过. 但是感觉实现起来会有一些麻烦&#8230; 相当于是要实现一个简单的 expander.</p>
<p>这里有一个还算 &#8220;比较优雅&#8221; 的方式来实现:</p>
<p>定义一个 generic function 叫做 <code>(objc-encoding-arg-form encoding)</code>,
  其返回一个 <code>list</code> 并如下构造 <code>lambda</code> 表达式:</p>
<div class="highlight"><pre><span></span><span class="o">`</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nf">gen-lambda-list</span><span class="w"> </span><span class="nv">encodings</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nf">objc-encoding-wrapper</span><span class="w"> </span><span class="nv">encoding</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">foreign-funcall</span>
<span class="w">     </span><span class="s">&quot;objc_msgSend&quot;</span>
<span class="w">     </span><span class="o">,@</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;append</span><span class="w"> </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;objc-encoding-arg-form</span><span class="w"> </span><span class="nv">encodings</span><span class="p">))</span>
<span class="w">     </span><span class="o">,</span><span class="p">(</span><span class="nf">objc-encoding-cffi-type</span><span class="w"> </span><span class="nv">return-encoding</span><span class="p">))))</span>
</pre></div>
</details>
<h3>Method Part-II: Inspect all the method of <code>Class</code></h3>
<p>使用 &lt;a href=&#8221;https://developer.apple.com/documentation/objectivec/class_copymethodlist(@@html:<span style="text-decoration:underline;">@@:@@html:</span>@@:)?language=objc&#8221;&gt;class_copyMethodList</a> 可以获得 <code>Class</code> 的所有的方法,
  于是可以用这样的方式来分析在当前 Runtime 中具体有哪些方法的实现:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">all-objc-class-methods</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-class</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Return a list of `sel&#39; as methods of OBJC-CLASS. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">with-foreign-object</span><span class="w"> </span><span class="p">(</span><span class="nf">cnt</span><span class="w"> </span><span class="nv">:pointer</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">class_copyMethodList</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-object-pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce-to-objc-class</span><span class="w"> </span><span class="nv">objc-class</span><span class="p">))</span>
<span class="w">                                     </span><span class="nv">cnt</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">unwind-protect</span>
<span class="w">           </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">:below</span><span class="w"> </span><span class="p">(</span><span class="nf">mem-aref</span><span class="w"> </span><span class="nv">cnt</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">                 </span><span class="nv">:collect</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce-to-selector</span><span class="w"> </span><span class="p">(</span><span class="nf">method_getName</span><span class="w"> </span><span class="p">(</span><span class="nf">mem-aref</span><span class="w"> </span><span class="nv">arr</span><span class="w"> </span><span class="nv">:pointer</span><span class="w"> </span><span class="nv">i</span><span class="p">))))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">foreign-free</span><span class="w"> </span><span class="nv">arr</span><span class="p">)))))</span>
</pre></div>
<p>于是就可以提前预处理编译所有的 ObjC Runtime 中的所有方法.</p>
<h1>Creating an NSWindow</h1>
<p>这里参考 <a href="https://github.com/gammasoft71/Examples_Cocoa">gammasoft71/Examples_Cocoa</a>.</p>
<h2><a href="https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Applications/Application/Application.m">Application</a></h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">app</span><span class="w"> </span><span class="p">(</span><span class="nf">invoke</span><span class="w"> </span><span class="s">&quot;NSApplication&quot;</span><span class="w"> </span><span class="s">&quot;sharedApplication&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">win</span><span class="w"> </span><span class="p">(</span><span class="nf">invoke</span><span class="w"> </span><span class="p">(</span><span class="nf">invoke</span><span class="w"> </span><span class="s">&quot;NSWindow&quot;</span><span class="w"> </span><span class="s">&quot;alloc&quot;</span><span class="p">)</span>
<span class="w">                   </span><span class="s">&quot;initWithContentRect:styleMask:backing:defer:&quot;</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">make-ns-rect</span><span class="w"> </span><span class="nv">:x</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="nv">:y</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="nv">:w</span><span class="w"> </span><span class="mi">300</span><span class="w"> </span><span class="nv">:h</span><span class="w"> </span><span class="mi">300</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">ns-window-style</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">:titled</span><span class="w"> </span><span class="nv">:closable</span><span class="w"> </span><span class="nv">:miniaturizable</span><span class="w"> </span><span class="nv">:resizable</span><span class="p">))</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">ns-backing</span><span class="w"> </span><span class="nv">:store-buffered</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">nil</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">invoke</span><span class="w"> </span><span class="nv">win</span><span class="w"> </span><span class="s">&quot;setIsVisible:&quot;</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">invoke</span><span class="w"> </span><span class="nv">app</span><span class="w"> </span><span class="s">&quot;run&quot;</span><span class="p">))</span>
</pre></div>
<details><summary>ObjC Version</summary>
<p>原始的代码如下:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Cocoa/Cocoa.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[</span><span class="n">NSApplication</span><span class="w"> </span><span class="n">sharedApplication</span><span class="p">];</span>
<span class="w">  </span><span class="n">NSWindow</span><span class="o">*</span><span class="w"> </span><span class="n">window1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[[</span><span class="n">NSWindow</span><span class="w"> </span><span class="n">alloc</span><span class="p">]</span><span class="w"> </span><span class="n">initWithContentRect</span><span class="o">:</span><span class="n">NSMakeRect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span><span class="w"> </span><span class="mi">300</span><span class="p">)</span><span class="w"> </span><span class="n">styleMask</span><span class="o">:</span><span class="n">NSWindowStyleMaskTitled</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSWindowStyleMaskClosable</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSWindowStyleMaskMiniaturizable</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSWindowStyleMaskResizable</span><span class="w"> </span><span class="n">backing</span><span class="o">:</span><span class="n">NSBackingStoreBuffered</span><span class="w"> </span><span class="n">defer</span><span class="o">:</span><span class="nb">NO</span><span class="p">]</span><span class="w"> </span><span class="n">autorelease</span><span class="p">];</span>
<span class="w">  </span><span class="p">[</span><span class="n">window1</span><span class="w"> </span><span class="n">setIsVisible</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
<span class="w">  </span><span class="p">[</span><span class="n">NSApp</span><span class="w"> </span><span class="n">run</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
<p>如果尝试使用</p>
<div class="highlight"><pre><span></span>gcc<span class="w"> </span>-fobjc-arc<span class="w"> </span>Application.m<span class="w"> </span>-framework<span class="w"> </span>Cocoa
</pre></div>
<p>却并不能正常地进行编译&#8230; 需要移除 <code>autorelease</code> 才能编译&#8230; 很奇怪.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Cocoa/Cocoa.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NSApplication</span><span class="o">*</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">NSApplication</span><span class="w"> </span><span class="n">sharedApplication</span><span class="p">];</span>
<span class="w">  </span><span class="n">NSWindow</span><span class="o">*</span><span class="w"> </span><span class="n">window1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="n">NSWindow</span><span class="w"> </span><span class="n">alloc</span><span class="p">]</span>
<span class="w">                        </span><span class="nl">initWithContentRect</span><span class="p">:</span><span class="n">NSMakeRect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span><span class="w"> </span><span class="mi">300</span><span class="p">)</span>
<span class="w">                                  </span><span class="nl">styleMask</span><span class="p">:</span><span class="n">NSWindowStyleMaskTitled</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSWindowStyleMaskClosable</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSWindowStyleMaskMiniaturizable</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">NSWindowStyleMaskResizable</span>
<span class="w">                                    </span><span class="nl">backing</span><span class="p">:</span><span class="n">NSBackingStoreBuffered</span>
<span class="w">                                      </span><span class="nl">defer</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
<span class="w">  </span><span class="p">[</span><span class="n">window1</span><span class="w"> </span><span class="n">setIsVisible</span><span class="o">:</span><span class="nb">YES</span><span class="p">];</span>
<span class="w">  </span><span class="p">[</span><span class="n">NSApp</span><span class="w"> </span><span class="n">run</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
<p>这样设计就可以保证正常的编译了, 不过由于并没有实现退出逻辑,
  所以在窗口关闭了之后仍会保持运行&#8230; 稍稍有些麻烦, 但是至少动起来了.</p>
</details>
<p>注: 由于 macOS 中仅允许 GUI 程序在主线程中创建 (<code>main loop</code>),
  所以实际上还需要保证代码在主线程中运行.</p>
<p>注: 由于 SBCL 的 float trap 的问题 (<a href="https://www.reddit.com/r/lisp/comments/1ceio6b/is_it_safe_to_disable_floating_point_traps/">Ref</a>), 实际上还需要手动关闭来保证不会报错
  (在 macOS SBCL 上做 CFFI 的时候好像经常出现&#8230;)</p>
<p>最终的效果 (非常简陋的) 如下:</p>
<p><img src="/_img/lisp/objc/trivial-application.png" alt="/_img/lisp/objc/trivial-application.png" /></p>]]></content><author><name></name></author><category term="lisp" /><category term="objc" /><summary type="html"><![CDATA[About 这估计又会是一次比较失败的 ObjC-bridge 的尝试 &#8211; 但是我可以比较高兴地说, 虽然之前的每次都是比较失败的, 至少次次我都有一些新的东西学到. 这次的目标大概就是能够实现一个简单的 ObjC Runtime Inspector: (coerce-to-objc-class objc-class-name) 会生成一个 Lisp Class: 比如 (coerce-to-objc-class &quot;NSString&quot;) 会生成 ns-string 类, 同时绑定一堆的类/实例的方法 这里参考的是 Develop with Cocoa for Apple Devices without using Objective-C 在 (invoke obj sel &amp;rest args) 的时候实现一个传 struct 参数的功能, 从而实现能够 (make-ns-rect :x x :y y :width width :height height) 并最终实现可以创建一个最简单的窗口 ObjC Runtime with JUST C API The Objective-C runtime is a runtime library that provides support for the dynamic properties of the Objective-C language, and as such is linked to by all Objective-C apps. Objective-C runtime library support functions are implemented in the shared library found at /usr/lib/libobjc.A.dylib. (ref: Objective-C Runtime) ObjC Runtime 可以被看作是一个纯 C 的 API, 尽管历史上有一些尝试 Cross-compile ObjC 到 C 的操作 (比如 Protable Object Compiler), 或者是使用 clang 的 =-rewrite-objc=. 但是实际上貌似也没有很好用&#8230; 关于 -rewrite-objc 假如有这样的 test.m 代码文件 #import &lt;Foundation/Foundation.h&gt;]]></summary></entry><entry><title type="html">LapOrk (OTAMATONE)</title><link href="/lapork/lapork-otamatone/" rel="alternate" type="text/html" title="LapOrk (OTAMATONE)" /><published>2025-11-02T00:00:00+00:00</published><updated>2025-11-02T00:00:00+00:00</updated><id>/lapork/lapork-otamatone</id><content type="html" xml:base="/lapork/lapork-otamatone/"><![CDATA[<h1>About</h1>
<p>作业是设计一个自己的声音,
  因为刷到了 <a href="https://www.bilibili.com/video/BV17z4y1e7UT/">【雫るる】电音蝌蚪演奏音乐会 开庭时带上你的蝌蚪</a>,
  那么就尝试用 SuperCollider 复刻试试. (虽然不一定能成)</p>
<h1>Analyze</h1>
<p>从视频里面截取了一个单音, 然后在 Audacity 中 Analyze-Plot Spectrum
  查看频谱:</p>
<p><img src="/_img/lapork/otamatone/spectrum.png" alt="/_img/lapork/otamatone/spectrum.png" /></p>
<h2>Analyze I: \(\mathrm{FFT}^{-1}\)</h2>
<p>理论上去生成频谱然后逆变换就可以得到声音了,
  比如把频谱中的峰挑出来再合成:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">otamatone1</span><span class="w"> </span><span class="p">((</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="mi">700</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.9</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.95</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="mf">-0.5</span><span class="p">)</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">klang</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w">   </span><span class="mi">2</span><span class="w">   </span><span class="mi">3</span><span class="w">   </span><span class="mi">4</span><span class="w">    </span><span class="mi">5</span><span class="w">    </span><span class="mi">6</span><span class="w">    </span><span class="mi">7</span><span class="p">)</span>
<span class="w">                                 </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">0.1</span><span class="w">  </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.01</span><span class="p">)</span>
<span class="w">                                 </span><span class="nv">nil</span><span class="p">)</span>
<span class="w">                           </span><span class="nv">freq</span><span class="p">))))</span>
</pre></div>
<details><summary>解释</summary>
<ul>
  <li><a href="https://doc.sccode.org/Classes/Klang.html">Klang</a>: 给一组 <code>(频率, 增幅, 相位)</code> 并合成正弦波的叠加,
    理论上等效于:
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;+</span><span class="w"> </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="nv">phr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="nv">phr</span><span class="w"> </span><span class="nv">amp</span><span class="p">))</span>
<span class="w">                    </span><span class="nv">freq</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="nv">pharses</span><span class="p">))</span>
</pre></div>
    <p>比如以 <code>700</code> 为基础频率, 得到:</p>
    <p><img src="/_img/lapork/otamatone/otamatone1.svg" alt="/_img/lapork/otamatone/otamatone1.svg" /></p>
  </li>
  <li><code>ADSR</code> 设计得让声音有一个没啥变化的死鱼一样地起伏:
    <p><img src="/_img/lapork/otamatone/otamatone1-adsr.svg" alt="/_img/lapork/otamatone/otamatone1-adsr.svg" /></p>
  </li>
  <li>其他的都之前介绍过了</li>
</ul>
</details>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*tone*</span><span class="w"> </span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;otamatone1</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">*tone*</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="mi">800</span><span class="p">)</span><span class="w"> </span><span class="mi">100</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">*tone*</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">))</span>
</pre></div>
<p>注: <code>Klang</code> 貌似并不支持控制 <code>freq</code>.</p>
<details><summary>一个暴力的修正方法</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">otamatone1</span><span class="w"> </span><span class="p">((</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="mi">700</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.9</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.95</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="mf">-0.5</span><span class="p">)</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;sc::+~</span>
<span class="w">                         </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="nv">a</span><span class="p">)</span>
<span class="w">                                   </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="nv">freq</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">a</span><span class="p">))</span>
<span class="w">                                 </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w">   </span><span class="mi">2</span><span class="w">   </span><span class="mi">3</span><span class="w">   </span><span class="mi">4</span><span class="w">   </span><span class="mi">5</span><span class="w">    </span><span class="mi">6</span><span class="w">    </span><span class="mi">7</span><span class="p">)</span>
<span class="w">                                 </span><span class="o">&#39;</span><span class="p">(</span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.01</span><span class="p">))))))</span>
</pre></div>
<p>对应到 SuperCollider 中的代码如下:</p>
<div class="highlight"><pre><span></span>(
SynthDef(\otamatone1, { |out=0, gate=1, amp=0.9, freq=700|
	var env = EnvGen.ar(
		Env.adsr(0.01, 0.01, 0.95, 0.01, 1, -0.5),
		gate,
		doneAction: 2
	);
	var sig = SinOsc.ar(freq, 0.0, 0.2) +
	SinOsc.ar(2 * freq, 0.0, 0.2) +
	SinOsc.ar(3 * freq, 0.0, 0.1) +
	SinOsc.ar(4 * freq, 0.0, 0.1);
	Out.ar(out, amp * sig * env);
} ).add;
)
</pre></div>
</details>
<p>Update: 稍微更聪明一点的办法:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">otamatone1</span><span class="w"> </span><span class="p">((</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="mi">700</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.9</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.95</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="mf">-0.5</span><span class="p">)</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">dyn-klang</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="nv">freq</span><span class="p">)</span>
<span class="w">                                     </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.01</span><span class="p">)</span>
<span class="w">                                     </span><span class="nv">nil</span><span class="p">)))))</span>
</pre></div>
<video controls width="600" style="display: block; margin: auto;"><source src="/_img/lapork/otamatone/otamatone1.mp4" type="video/mp4" /></video>
<p>(TouchOSC 文件见 <a href="/_img/lapork/otamatone1.tosc">otamatone1.tosc</a>)</p>
<h2>Analyze II: WOWOWOWOWOWOWOWOWOWOWA</h2>
<p>上面的演示视频里面, 如果鼠标在划移的话, 听起来声音会像一些,
  但是如果只是停在某处不动的话, 就会有一种比较怪怪的感觉:</p>
<p>如果把前面频谱分析的片段时间拉长一点, 就会看到在时间轴方向上,
  频率会有一个小小的波动:</p>
<p><img src="/_img/lapork/otamatone/tone.jpeg" alt="/_img/lapork/otamatone/tone.jpeg" /></p>
<p>所以其实是需要给这个 <code>freq</code> 加上一点点的正弦的偏置的&#8230;</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">otamatone2</span><span class="w"> </span><span class="p">((</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="mi">700</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.9</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">wowf</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wowa</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wowb</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wow</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.95</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="mf">-0.5</span><span class="p">)</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">dyn-klang</span><span class="o">.</span><span class="nv">ar</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">sc::+~</span><span class="w"> </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="nv">freq</span><span class="p">)</span>
<span class="w">                                </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">wow</span>
<span class="w">                                        </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="nv">wowf</span><span class="w"> </span><span class="mi">0</span>
<span class="w">                                                    </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">wowa</span><span class="w"> </span><span class="nv">freq</span><span class="p">)</span>
<span class="w">                                                    </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">wowb</span><span class="w"> </span><span class="nv">freq</span><span class="p">))))</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">0.1</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.05</span><span class="w"> </span><span class="mf">0.01</span><span class="p">)</span>
<span class="w">                        </span><span class="nv">nil</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*tone*</span><span class="w"> </span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;otamatone2</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
</pre></div>
<h2>Analyze III: Saw</h2>
<p>与其做逆傅立叶变换那套, 不妨试试用信号滤波, 由伟大的 LLM 告诉我们,
  一个三角波信号的傅立叶变换为分立的频谱峰, 其峰值为 \(\frac{1}{n}\)&#8230;</p>
<p>虽然现在的频谱峰很接近了, 但是现在的峰值显然不是 \(\frac{1}{n}\) 的分布,
  所以可以猜测里面做了一个滤波 &#8211; 总之先试试低通:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">otamatone3</span><span class="w"> </span><span class="p">((</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="mi">700</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.9</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">wowf</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wowa</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wowb</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wow</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span>
<span class="w">   </span><span class="nv">out</span>
<span class="w">   </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">amp</span>
<span class="w">      </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.95</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="mf">-0.5</span><span class="p">)</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">hpf</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">lpf</span><span class="o">.</span><span class="nv">ar</span>
<span class="w">               </span><span class="p">(</span><span class="nf">saw</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">sc::+~</span><span class="w"> </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">wow</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">wowf</span><span class="w"> </span><span class="mi">0</span>
<span class="w">                                                       </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="nv">wowa</span><span class="p">)</span>
<span class="w">                                                       </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="nv">wowb</span><span class="p">)))</span>
<span class="w">                               </span><span class="nv">freq</span><span class="p">))</span>
<span class="w">               </span><span class="nv">freq</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nf">sc::*~</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="mi">2</span><span class="p">)))))</span>
</pre></div>
<p>这样再加一个 <code>wow</code> 的控制就好了.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:wow</span><span class="w"> </span><span class="p">(</span><span class="nf">wow</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">*tone*</span><span class="w"> </span><span class="nv">:wow</span><span class="w"> </span><span class="nv">wow</span><span class="p">))</span>
</pre></div>
<p>效果如下:</p>
<video controls width="600" style="display: block; margin: auto;"><source src="/_img/lapork/otamatone/otamatone3.mp4" type="video/mp4" /></video>
<p>大概就酱.</p>]]></content><author><name></name></author><category term="lapork" /><summary type="html"><![CDATA[About 作业是设计一个自己的声音, 因为刷到了 【雫るる】电音蝌蚪演奏音乐会 开庭时带上你的蝌蚪, 那么就尝试用 SuperCollider 复刻试试. (虽然不一定能成) Analyze 从视频里面截取了一个单音, 然后在 Audacity 中 Analyze-Plot Spectrum 查看频谱: Analyze I: \(\mathrm{FFT}^{-1}\) 理论上去生成频谱然后逆变换就可以得到声音了, 比如把频谱中的峰挑出来再合成: (defsynth otamatone1 ((out 0) (freq 700) (gate 1) (amp 0.9)) (out.ar out (* (env-gen.ar (adsr 0.01 0.01 0.95 0.01 amp -0.5) :gate gate) (klang.ar (list (list 1 2 3 4 5 6 7) (list 0.2 0.2 0.1 0.1 0.05 0.05 0.01) nil) freq)))) 解释 Klang: 给一组 (频率, 增幅, 相位) 并合成正弦波的叠加, 理论上等效于: (reduce #&#39;+ (mapcar (lambda (freq amp phr) (sin-osc.ar freq phr amp)) freq amp pharses)) 比如以 700 为基础频率, 得到: ADSR 设计得让声音有一个没啥变化的死鱼一样地起伏: 其他的都之前介绍过了 (defparameter *tone* (synth &#39;otamatone1 :gate 0))]]></summary></entry><entry><title type="html">LapOrk (03: A Little More on Sound Waves)</title><link href="/lapork/lapork-03/" rel="alternate" type="text/html" title="LapOrk (03: A Little More on Sound Waves)" /><published>2025-10-16T00:00:00+00:00</published><updated>2025-10-16T00:00:00+00:00</updated><id>/lapork/lapork-03</id><content type="html" xml:base="/lapork/lapork-03/"><![CDATA[<style>img { width: 400px; display: block; margin: auto; }</style>
<h1>About</h1>
<p>之后的一些代码会放到 Github 上面 (<a href="https://github.com/li-yiyang/lapork-lecture">li-yiyang/lapork-lecture</a>),
  方便复用了.</p>
<h2>TLDR</h2>
<ul>
  <li>声音是波, 一些特别的波型的产生和对他们进行一个调参数</li>
  <li>采样的播放</li>
  <li>声道, 输出的设备以及其他</li>
</ul>
<h1>Sound is Waves</h1>
<details><summary>咬文嚼字一下</summary>
<p>其实严格来说, 声音是振动 \(f(t)\), 而波是声音的传播 (时空分布) \(f(x, t)\).
  不知道这样会不会更加严格一些.</p>
</details>
<p>比如说打开示波器, 去检查声音信号随时间的变化情况:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mf">0.125</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">350</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">440</span><span class="p">))))</span>
</pre></div>
<p><img src="/_img/lapork/03/phone.png" alt="/_img/lapork/03/phone.png" /></p>
<h2>波形与频谱的显示</h2>
<h3>lapork.plot</h3>
<p>emmm, 但是不是所有时候都能手上拿着一台示波器,
  那么是否有没有好的方法来解决这个问题呢?
  虽然在 SuperCollider 中有 <a href="https://doc.sccode.org/Reference/plot.html">=plot=</a> 这样的函数,
  但是在 <code>cl-collider</code> 中并没有类似的功能.</p>
<p>参考 <a href="https://github.com/byulparan/cl-collider/issues/81">cl-collider/issue #81</a> 中的方法,
  可以用 Gnuplot 简单的实现一个绘图功能.</p>
<p>完整的代码见 <a href="https://github.com/li-yiyang/lapork-lecture/tree/main/lisp/plot">lapork/plot</a>.</p>
<details><summary>具体思路的说明</summary>
<ul>
  <li><code>plot</code>: 相当于是在后台开了一个 <a href="http://www.gnuplot.info/">Gnuplot</a> 程序,
    通过生成 inline data 和 plot 命令, 可以用来绘图</li>
  <li><code>scope</code>: 例
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">scope</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span><span class="w"> </span><span class="nv">:frames</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span>
</pre></div>
  </li>
  <li><code>freqscope</code>:</li>
</ul>
</details>
<h3>各种各样的波形的显示</h3>
<p>在前面的几节里面已经接触过:</p>
<ul>
  <li><code>sin-osc</code>: 正弦波</li>
  <li><code>blip</code>: 脉冲</li>
  <li><code>white-noise</code>: 白噪声
    <p>类似的还有:</p>
    <ul>
      <li><code>brown-noise</code>: 棕噪声</li>
      <li><code>pink-noise</code>: 粉噪声</li>
    </ul>
  </li>
</ul>
<p>下面是一些声音种类以及其波形的形状:</p>
<style>td img { width: 200px; display: block; margin: auto; } </style>
<table>
  <tr><th>声音</th><th>波形</th></tr>
  <tr><td><code>sin-osc</code> 正弦波</td><td><img src="/_img/lapork/03/sin.svg" alt="/_img/lapork/03/sin.svg" /></td></tr>
  <tr><td><code>blip</code> 脉冲波</td><td><img src="/_img/lapork/03/blip.svg" alt="/_img/lapork/03/blip.svg" /></td></tr>
  <tr><td><code>saw</code> 锯齿波</td><td><img src="/_img/lapork/03/saw.svg" alt="/_img/lapork/03/saw.svg" /></td></tr>
  <tr><td><code>pulse</code> 方波</td><td><img src="/_img/lapork/03/pulse.svg" alt="/_img/lapork/03/pulse.svg" /></td></tr>
  <tr><td><code>white-noise</code> 白噪声</td><td><img src="/_img/lapork/03/white-noise.svg" alt="/_img/lapork/03/white-noise.svg" /></td></tr>
  <tr><td><code>brown-noise</code> 粽噪声</td><td><img src="/_img/lapork/03/brown-noise.svg" alt="/_img/lapork/03/brown-noise.svg" /></td></tr>
  <tr><td><code>pink-noise</code> 粉噪声</td><td><img src="/_img/lapork/03/pink-noise.svg" alt="/_img/lapork/03/pink-noise.svg" /></td></tr>
  <tr><td><code>gray-noise</code> 灰噪声</td><td><img src="/_img/lapork/03/gray-noise.svg" alt="/_img/lapork/03/gray-noise.svg" /></td></tr>
  <tr><td><code>lf-tri</code> 低频 (Low Frequency) 三角波</td><td><img src="/_img/lapork/03/lf-tri.svg" alt="/_img/lapork/03/lf-tri.svg" /></td></tr>
  <tr><td><code>lf-pulse</code> 低频 (Low Frequency) 方波</td><td><img src="/_img/lapork/03/lf-pulse.svg" alt="/_img/lapork/03/lf-pulse.svg" /></td></tr>
  <tr><td><code>sin-osc</code> 和 <code>lf-noise1</code> (低频噪声) 的合成</td><td><img src="/_img/lapork/03/sin-noise1.svg" alt="/_img/lapork/03/sin-noise1.svg" /></td></tr>
</table>
<p>部分解释:</p>
<ul>
  <li><code>lf-*</code> 开头的 (对应 SuperCollider 中 <code>LF</code>) 开头的表示 Low Frequency,
    用于去更好地生成一些低频的信号.
    <p>例: 比较 <code>pulse</code> 和 <code>lf-pulse</code> 的波形, 前者是通过多个正弦波 (傅立叶分解) 叠加得到的,
      后者则是直接通过翻转值 (<code>0</code> 或 <code>1</code>) 来产生的. 在低频的情况下,
      (通过 CPU 控制的) 直接翻转显然更优, 而高频情况下, 由于会对 CPU 产生较大的负担,
      还是不如用声卡的输出来的方便.</p>
  </li>
  <li>不同的音色</li>
</ul>
<h2>滤波器</h2>
<h2>你说, 我在听 &#8211; 录音的导入和导出</h2>
<h3>导入声音</h3>
<p>可以导入一段声音 (sampling, 采样) 进行播放:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">layer</span>
<span class="w">  </span><span class="p">(</span><span class="nf">buffer-read</span><span class="w"> </span><span class="s">&quot;~/Code/lapork-lecture/samples/whispers/layer.aiff&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">play-buf</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">layer</span><span class="w"> </span><span class="p">(</span><span class="nf">buf-rate-scale</span><span class="o">.</span><span class="nv">ir</span><span class="w"> </span><span class="nv">layer</span><span class="p">)))</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><code>buffer-read</code> 可以读入一段采样音频文件</li>
  <li><code>play-buf.ar</code> 给 <code>layer</code> 这个 buffer 准备了一些预先需要知道的信息:
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play-buf</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">channels</span><span class="w"> </span><span class="nv">buffer-id</span><span class="w"> </span><span class="nv">rate</span><span class="p">)</span>
</pre></div>
    <ul>
      <li><code>channels</code> 有几个声道</li>
      <li><code>buffer-id</code> 也就是读到的 <code>layer</code></li>
      <li><code>rate</code> 播放速率, 默认的 <code>rate</code> 不知道为啥会让速度变得非常快, 所以这里需要加上</li>
    </ul>
    <p>代码调用有些不太优雅了其实</p>
  </li>
</ul>
<details><summary>这段采样的来历</summary>
<p>在 Lain 每一集开头都会有一段很有意思的机械合成声音,
  传说是用 Macintosh 发布会的那个问候同款的合成器制成的 (ref: <a href="https://www.reddit.com/r/Lain/comments/15x63rn/looking_for_the_macintosh_voice/">r/Lain</a>).</p>
<p>在今天的 macOS 里面, 其实还保留了这个神奇的声音生成工具:</p>
<div class="highlight"><pre><span></span>say<span class="w"> </span>-v<span class="w"> </span><span class="s1">&#39;Whisper&#39;</span><span class="w"> </span><span class="s1">&#39;Layer, zero two&#39;</span><span class="w"> </span><span class="c1"># read</span>
</pre></div>
<p>你可以用:</p>
<div class="highlight"><pre><span></span>say<span class="w"> </span>-v<span class="w"> </span><span class="s1">&#39;Whisper&#39;</span><span class="w"> </span>-o<span class="w"> </span><span class="nv">$OUTPUT</span><span class="w"> </span><span class="s1">&#39;Layer&#39;</span>
</pre></div>
<p>来生成采样.</p>
</details>
<h3>拿小本本记下 &#8211; 导出声音</h3>
<h2>合成声音 &#8211; 一些应用?</h2>
<h3>Phone Tones</h3>
<p>做这个的原因是之前听过一首歌, 开头是一段拨号, 然后是 “Hello, its me&#8230; ”,
  挺好听的, 只是我忘了具体歌名叫啥了.</p>
<p>根据 <a href="https://www.itu.int/rec/T-REC-Q.23-198811-I/en">Technical features of push-button telephone sets (ITU)</a> 的说明,
  可以得到一个拨号声音信号是如下定义的:</p>
<p>在按下按钮的时候, 根据按钮的编码发送一个混合频率的声音:</p>
<table>
  <tr><th>Low freq \ High freq</th><th>1209</th><th>1336</th><th>1477</th><th>1633</th></tr>
  <tr><td>697</td><td>1</td><td>2</td><td>3</td><td>A</td></tr>
  <tr><td>770</td><td>4</td><td>5</td><td>6</td><td>B</td></tr>
  <tr><td>852</td><td>7</td><td>8</td><td>9</td><td>C</td></tr>
  <tr><td>941</td><td>*</td><td>0</td><td>#</td><td>D</td></tr>
</table>
<p>这, 简单啊:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">phone-tone</span><span class="w"> </span><span class="p">((</span><span class="nf">gate</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">low</span><span class="w"> </span><span class="mi">350</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">high</span><span class="w"> </span><span class="mi">440</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="nv">amp</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">low</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">high</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.8</span><span class="w"> </span><span class="mf">0.02</span><span class="p">)</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">))))</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><code>gate</code> 用来作为 <code>ADSR</code> 的开启和关闭的信号, 这个可以参考后文中和 TouchOSC 联动的部分</li>
  <li><code>low</code> 和 <code>high</code> 作为拨号信号编码的两个频率
    <p>默认播放的是 <code>350</code>, <code>440</code>, 也就是常听到的拿起电话准备拨号的声音</p>
  </li>
</ul>
<p>那么做一个简单的 TouchOSC 界面:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">start-osc-server</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;phone-tone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">on/off</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:tone-switch</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">on/off</span><span class="w"> </span><span class="nv">gate</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:tone-silent</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span><span class="w"> </span><span class="c1">;; OFF</span>
<span class="w">        </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">on/off</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="mi">0</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:tone1</span><span class="w"> </span><span class="p">(</span><span class="nf">on/off</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">on/off</span><span class="p">)</span><span class="w"> </span><span class="c1">;; OFF</span>
<span class="w">      </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="mi">350</span><span class="w"> </span><span class="nv">:high</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="mi">697</span><span class="w"> </span><span class="nv">:high</span><span class="w"> </span><span class="mi">1209</span><span class="p">)))</span>

<span class="c1">;;; ...</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><a href="https://github.com/li-yiyang/lapork-lecture/blob/e0d1b28b7a39440d0ab02eda50b0cf3abfa8aee5/lisp/oscdef/oscdef.lisp#L55">=start-osc-server=</a> 打开一个 OSC server 来接受控制的 OSC 指令</li>
  <li><code>synth</code> 定义了一个初始 <code>gate</code> 状态为关闭的 <code>phone-tone</code> 的合成器, 也就是我们的拨号器</li>
  <li>定义了三个 OSC 指令, 分别对应 TouchOSC 中的按钮名称:
    <ul>
      <li><code>toneSwitch</code>: 是否使用拨号器 (开关合成器 <code>phone</code> 的 <code>gate</code> 信号,
        同时修改局部变量 <code>on/off</code> 的值为开或关);</li>
      <li><code>toneSilent</code>: 一时的静音, 当 <code>gate</code> 为非 <code>0</code> 时, 将 <code>phone</code> 的 <code>gate</code> 信号设为 <code>0</code>,
        其他的时候恢复正常状态;</li>
      <li><code>tone1</code>: 使用按键 <code>1</code> 的声音, 若关闭, 则将声音重新置为等待拨号的呜呜声状态</li>
      <li>其他的 <code>tone*</code> 同理</li>
    </ul>
  </li>
</ul>
<details><summary>完整的 TouchOSC 和控制代码</summary>
<p>因为手动一个个设置 <code>tone*</code> 太麻烦了, 所以这里我使用了 Common Lisp 的特性:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">macrolet</span><span class="w"> </span><span class="p">((</span><span class="nf">tone*</span><span class="w"> </span><span class="p">(</span><span class="nf">high-freqs</span><span class="w"> </span><span class="nv">&amp;rest</span><span class="w"> </span><span class="nv">tone-table</span><span class="p">)</span>
<span class="w">             </span><span class="o">`</span><span class="p">(</span><span class="nf">progn</span>
<span class="w">                </span><span class="o">,@</span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="p">(</span><span class="nf">low</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">tones</span><span class="p">)</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">tone-table</span>
<span class="w">                        </span><span class="nv">:collect</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">tone</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">tones</span>
<span class="w">                              </span><span class="nv">:for</span><span class="w"> </span><span class="nv">high</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">high-freqs</span>
<span class="w">                              </span><span class="nv">:collect</span>
<span class="w">                              </span><span class="o">`</span><span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="s">&quot;tone~A&quot;</span><span class="w"> </span><span class="nv">tone</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="p">)</span>
<span class="w">                                 </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span>
<span class="w">                                     </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="mi">350</span><span class="w">  </span><span class="nv">:high</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span>
<span class="w">                                     </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="o">,</span><span class="nv">low</span><span class="w"> </span><span class="nv">:high</span><span class="w"> </span><span class="o">,</span><span class="nv">high</span><span class="p">))))</span>
<span class="w">                          </span><span class="nv">:into</span><span class="w"> </span><span class="nv">defs</span>
<span class="w">                        </span><span class="nv">:finally</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;append</span><span class="w"> </span><span class="nv">defs</span><span class="p">))))))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">tone*</span><span class="w"> </span><span class="p">(</span><span class="w">        </span><span class="mi">1209</span><span class="w"> </span><span class="mi">1336</span><span class="w"> </span><span class="mi">1477</span><span class="w"> </span><span class="mi">1633</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">697</span><span class="w">     </span><span class="mi">1</span><span class="w">    </span><span class="mi">2</span><span class="w">    </span><span class="mi">3</span><span class="w">    </span><span class="nv">A</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">770</span><span class="w">     </span><span class="mi">4</span><span class="w">    </span><span class="mi">5</span><span class="w">    </span><span class="mi">6</span><span class="w">    </span><span class="nv">B</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">852</span><span class="w">     </span><span class="mi">7</span><span class="w">    </span><span class="mi">8</span><span class="w">    </span><span class="mi">9</span><span class="w">    </span><span class="nv">C</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">941</span><span class="w">     </span><span class="nb">*</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="nv">|</span><span class="cm">#|  D)))</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><code>macrolet</code> 定义了一个局部的宏展开 <code>tone*</code>, 将输入的参数看作是一个表格,
    第一行是高频信息, 剩下的行 (<code>&amp;rest</code>) 为 <code>(低频信息 . 按键名称)</code></li>
</ul>
<p>完整的代码见: <a href="https://github.com/li-yiyang/lapork-lecture/blob/main/lisp/examples/lapork-03/phone.lisp">phone.lisp</a> 以及 <a href="https://github.com/li-yiyang/lapork-lecture/blob/main/touchosc/lecture-03/phone-calling.tosc">phone-calling.tosc</a>.</p>
</details>
<p>效果如下:</p>
<video controls width="600" style="display: block; margin: auto;"><source src="/_img/lapork/03/phone.mp4" type="video/mp4" /></video>
<p>一些鬼点子: 如果用这个生成一段随机拨号音, 然后配上 Lain 的 Whisper 采样 greeting,
  估计会有种赛博朋克的感觉.</p>
<h3>Fire</h3>]]></content><author><name></name></author><category term="lapork" /><summary type="html"><![CDATA[About 之后的一些代码会放到 Github 上面 (li-yiyang/lapork-lecture), 方便复用了. TLDR 声音是波, 一些特别的波型的产生和对他们进行一个调参数 采样的播放 声道, 输出的设备以及其他 Sound is Waves 咬文嚼字一下 其实严格来说, 声音是振动 \(f(t)\), 而波是声音的传播 (时空分布) \(f(x, t)\). 不知道这样会不会更加严格一些. 比如说打开示波器, 去检查声音信号随时间的变化情况: (play (* 0.125 (+ (sin-osc.ar 350) (sin-osc.ar 440)))) 波形与频谱的显示 lapork.plot emmm, 但是不是所有时候都能手上拿着一台示波器, 那么是否有没有好的方法来解决这个问题呢? 虽然在 SuperCollider 中有 =plot= 这样的函数, 但是在 cl-collider 中并没有类似的功能. 参考 cl-collider/issue #81 中的方法, 可以用 Gnuplot 简单的实现一个绘图功能. 完整的代码见 lapork/plot. 具体思路的说明 plot: 相当于是在后台开了一个 Gnuplot 程序, 通过生成 inline data 和 plot 命令, 可以用来绘图 scope: 例 (scope (sin-osc.ar 440) :frames 200) freqscope: 各种各样的波形的显示 在前面的几节里面已经接触过: sin-osc: 正弦波 blip: 脉冲 white-noise: 白噪声 类似的还有: brown-noise: 棕噪声 pink-noise: 粉噪声 下面是一些声音种类以及其波形的形状: 声音波形 sin-osc 正弦波 blip 脉冲波 saw 锯齿波 pulse 方波 white-noise 白噪声 brown-noise 粽噪声 pink-noise 粉噪声 gray-noise 灰噪声 lf-tri 低频 (Low Frequency) 三角波 lf-pulse 低频 (Low Frequency) 方波 sin-osc 和 lf-noise1 (低频噪声) 的合成 部分解释: lf-* 开头的 (对应 SuperCollider 中 LF) 开头的表示 Low Frequency, 用于去更好地生成一些低频的信号. 例: 比较 pulse 和 lf-pulse 的波形, 前者是通过多个正弦波 (傅立叶分解) 叠加得到的, 后者则是直接通过翻转值 (0 或 1) 来产生的. 在低频的情况下, (通过 CPU 控制的) 直接翻转显然更优, 而高频情况下, 由于会对 CPU 产生较大的负担, 还是不如用声卡的输出来的方便. 不同的音色 滤波器 你说, 我在听 &#8211; 录音的导入和导出 导入声音 可以导入一段声音 (sampling, 采样) 进行播放: (defparameter layer (buffer-read &quot;~/Code/lapork-lecture/samples/whispers/layer.aiff&quot;))]]></summary></entry></feed>