<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-10-20T09:49:52+00:00</updated><id>/feed.xml</id><title type="html">My Blog</title><subtitle>某不知名的很硬的双非学校的物理系学生的无聊博客</subtitle><entry><title type="html">LapOrk (03: A Little More on Sound Waves)</title><link href="/lapork/lapork-03/" rel="alternate" type="text/html" title="LapOrk (03: A Little More on Sound Waves)" /><published>2025-10-16T00:00:00+00:00</published><updated>2025-10-16T00:00:00+00:00</updated><id>/lapork/lapork-03</id><content type="html" xml:base="/lapork/lapork-03/"><![CDATA[<style>img { width: 400px; display: block; margin: auto; }</style>
<h1>About</h1>
<p>之后的一些代码会放到 Github 上面 (<a href="https://github.com/li-yiyang/lapork-lecture">li-yiyang/lapork-lecture</a>),
  方便复用了.</p>
<h2>TLDR</h2>
<ul>
  <li>声音是波, 一些特别的波型的产生和对他们进行一个调参数</li>
  <li>采样的播放</li>
  <li>声道, 输出的设备以及其他</li>
</ul>
<h1>Sound is Waves</h1>
<details><summary>咬文嚼字一下</summary>
<p>其实严格来说, 声音是振动 \(f(t)\), 而波是声音的传播 (时空分布) \(f(x, t)\).
  不知道这样会不会更加严格一些.</p>
</details>
<p>比如说打开示波器, 去检查声音信号随时间的变化情况:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mf">0.125</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">350</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">440</span><span class="p">))))</span>
</pre></div>
<p><img src="/_img/lapork/03/phone.png" alt="/_img/lapork/03/phone.png" /></p>
<h2>波形与频谱的显示</h2>
<h3>lapork.plot</h3>
<p>emmm, 但是不是所有时候都能手上拿着一台示波器,
  那么是否有没有好的方法来解决这个问题呢?
  虽然在 SuperCollider 中有 <a href="https://doc.sccode.org/Reference/plot.html">=plot=</a> 这样的函数,
  但是在 <code>cl-collider</code> 中并没有类似的功能.</p>
<p>参考 <a href="https://github.com/byulparan/cl-collider/issues/81">cl-collider/issue #81</a> 中的方法,
  可以用 Gnuplot 简单的实现一个绘图功能.</p>
<p>完整的代码见 <a href="https://github.com/li-yiyang/lapork-lecture/tree/main/lisp/plot">lapork/plot</a>.</p>
<details><summary>具体思路的说明</summary>
<ul>
  <li><code>plot</code>: 相当于是在后台开了一个 <a href="http://www.gnuplot.info/">Gnuplot</a> 程序,
    通过生成 inline data 和 plot 命令, 可以用来绘图</li>
  <li><code>scope</code>: 例
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">scope</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span><span class="w"> </span><span class="nv">:frames</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span>
</pre></div>
  </li>
  <li><code>freqscope</code>:</li>
</ul>
</details>
<h3>各种各样的波形的显示</h3>
<p>在前面的几节里面已经接触过:</p>
<ul>
  <li><code>sin-osc</code>: 正弦波</li>
  <li><code>blip</code>: 脉冲</li>
  <li><code>white-noise</code>: 白噪声
    <p>类似的还有:</p>
    <ul>
      <li><code>brown-noise</code>: 棕噪声</li>
      <li><code>pink-noise</code>: 粉噪声</li>
    </ul>
  </li>
</ul>
<p>下面是一些声音种类以及其波形的形状:</p>
<style>td img { width: 200px; display: block; margin: auto; } </style>
<table>
  <tr><th>声音</th><th>波形</th></tr>
  <tr><td><code>sin-osc</code> 正弦波</td><td><img src="/_img/lapork/03/sin.svg" alt="/_img/lapork/03/sin.svg" /></td></tr>
  <tr><td><code>blip</code> 脉冲波</td><td><img src="/_img/lapork/03/blip.svg" alt="/_img/lapork/03/blip.svg" /></td></tr>
  <tr><td><code>saw</code> 锯齿波</td><td><img src="/_img/lapork/03/saw.svg" alt="/_img/lapork/03/saw.svg" /></td></tr>
  <tr><td><code>pulse</code> 方波</td><td><img src="/_img/lapork/03/pulse.svg" alt="/_img/lapork/03/pulse.svg" /></td></tr>
  <tr><td><code>white-noise</code> 白噪声</td><td><img src="/_img/lapork/03/white-noise.svg" alt="/_img/lapork/03/white-noise.svg" /></td></tr>
  <tr><td><code>brown-noise</code> 粽噪声</td><td><img src="/_img/lapork/03/brown-noise.svg" alt="/_img/lapork/03/brown-noise.svg" /></td></tr>
  <tr><td><code>pink-noise</code> 粉噪声</td><td><img src="/_img/lapork/03/pink-noise.svg" alt="/_img/lapork/03/pink-noise.svg" /></td></tr>
  <tr><td><code>gray-noise</code> 灰噪声</td><td><img src="/_img/lapork/03/gray-noise.svg" alt="/_img/lapork/03/gray-noise.svg" /></td></tr>
  <tr><td><code>lf-tri</code> 低频 (Low Frequency) 三角波</td><td><img src="/_img/lapork/03/lf-tri.svg" alt="/_img/lapork/03/lf-tri.svg" /></td></tr>
  <tr><td><code>lf-pulse</code> 低频 (Low Frequency) 方波</td><td><img src="/_img/lapork/03/lf-pulse.svg" alt="/_img/lapork/03/lf-pulse.svg" /></td></tr>
  <tr><td><code>sin-osc</code> 和 <code>lf-noise1</code> (低频噪声) 的合成</td><td><img src="/_img/lapork/03/sin-noise1.svg" alt="/_img/lapork/03/sin-noise1.svg" /></td></tr>
</table>
<p>部分解释:</p>
<ul>
  <li><code>lf-*</code> 开头的 (对应 SuperCollider 中 <code>LF</code>) 开头的表示 Low Frequency,
    用于去更好地生成一些低频的信号.
    <p>例: 比较 <code>pulse</code> 和 <code>lf-pulse</code> 的波形, 前者是通过多个正弦波 (傅立叶分解) 叠加得到的,
      后者则是直接通过翻转值 (<code>0</code> 或 <code>1</code>) 来产生的. 在低频的情况下,
      (通过 CPU 控制的) 直接翻转显然更优, 而高频情况下, 由于会对 CPU 产生较大的负担,
      还是不如用声卡的输出来的方便.</p>
  </li>
  <li>不同的音色</li>
</ul>
<h2>滤波器</h2>
<h2>你说, 我在听 &#8211; 录音的导入和导出</h2>
<h3>导入声音</h3>
<p>可以导入一段声音 (sampling, 采样) 进行播放:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">layer</span>
<span class="w">  </span><span class="p">(</span><span class="nf">buffer-read</span><span class="w"> </span><span class="s">&quot;~/Code/lapork-lecture/samples/whispers/layer.aiff&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">play-buf</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">layer</span><span class="w"> </span><span class="p">(</span><span class="nf">buf-rate-scale</span><span class="o">.</span><span class="nv">ir</span><span class="w"> </span><span class="nv">layer</span><span class="p">)))</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><code>buffer-read</code> 可以读入一段采样音频文件</li>
  <li><code>play-buf.ar</code> 给 <code>layer</code> 这个 buffer 准备了一些预先需要知道的信息:
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play-buf</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">channels</span><span class="w"> </span><span class="nv">buffer-id</span><span class="w"> </span><span class="nv">rate</span><span class="p">)</span>
</pre></div>
    <ul>
      <li><code>channels</code> 有几个声道</li>
      <li><code>buffer-id</code> 也就是读到的 <code>layer</code></li>
      <li><code>rate</code> 播放速率, 默认的 <code>rate</code> 不知道为啥会让速度变得非常快, 所以这里需要加上</li>
    </ul>
    <p>代码调用有些不太优雅了其实</p>
  </li>
</ul>
<details><summary>这段采样的来历</summary>
<p>在 Lain 每一集开头都会有一段很有意思的机械合成声音,
  传说是用 Macintosh 发布会的那个问候同款的合成器制成的 (ref: <a href="https://www.reddit.com/r/Lain/comments/15x63rn/looking_for_the_macintosh_voice/">r/Lain</a>).</p>
<p>在今天的 macOS 里面, 其实还保留了这个神奇的声音生成工具:</p>
<div class="highlight"><pre><span></span>say<span class="w"> </span>-v<span class="w"> </span><span class="s1">&#39;Whisper&#39;</span><span class="w"> </span><span class="s1">&#39;Layer, zero two&#39;</span><span class="w"> </span><span class="c1"># read</span>
</pre></div>
<p>你可以用:</p>
<div class="highlight"><pre><span></span>say<span class="w"> </span>-v<span class="w"> </span><span class="s1">&#39;Whisper&#39;</span><span class="w"> </span>-o<span class="w"> </span><span class="nv">$OUTPUT</span><span class="w"> </span><span class="s1">&#39;Layer&#39;</span>
</pre></div>
<p>来生成采样.</p>
</details>
<h3>拿小本本记下 &#8211; 导出声音</h3>
<h2>合成声音 &#8211; 一些应用?</h2>
<h3>Phone Tones</h3>
<p>做这个的原因是之前听过一首歌, 开头是一段拨号, 然后是 “Hello, its me&#8230; ”,
  挺好听的, 只是我忘了具体歌名叫啥了.</p>
<p>根据 <a href="https://www.itu.int/rec/T-REC-Q.23-198811-I/en">Technical features of push-button telephone sets (ITU)</a> 的说明,
  可以得到一个拨号声音信号是如下定义的:</p>
<p>在按下按钮的时候, 根据按钮的编码发送一个混合频率的声音:</p>
<table>
  <tr><th>Low freq \ High freq</th><th>1209</th><th>1336</th><th>1477</th><th>1633</th></tr>
  <tr><td>697</td><td>1</td><td>2</td><td>3</td><td>A</td></tr>
  <tr><td>770</td><td>4</td><td>5</td><td>6</td><td>B</td></tr>
  <tr><td>852</td><td>7</td><td>8</td><td>9</td><td>C</td></tr>
  <tr><td>941</td><td>*</td><td>0</td><td>#</td><td>D</td></tr>
</table>
<p>这, 简单啊:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">phone-tone</span><span class="w"> </span><span class="p">((</span><span class="nf">gate</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">low</span><span class="w"> </span><span class="mi">350</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">high</span><span class="w"> </span><span class="mi">440</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="nv">amp</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">low</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">high</span><span class="p">))</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="mf">0.8</span><span class="w"> </span><span class="mf">0.02</span><span class="p">)</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">gate</span><span class="p">))))</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><code>gate</code> 用来作为 <code>ADSR</code> 的开启和关闭的信号, 这个可以参考后文中和 TouchOSC 联动的部分</li>
  <li><code>low</code> 和 <code>high</code> 作为拨号信号编码的两个频率
    <p>默认播放的是 <code>350</code>, <code>440</code>, 也就是常听到的拿起电话准备拨号的声音</p>
  </li>
</ul>
<p>那么做一个简单的 TouchOSC 界面:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">start-osc-server</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;phone-tone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">on/off</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:tone-switch</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">on/off</span><span class="w"> </span><span class="nv">gate</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:tone-silent</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span><span class="w"> </span><span class="c1">;; OFF</span>
<span class="w">        </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="nv">on/off</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:gate</span><span class="w"> </span><span class="mi">0</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="nv">:tone1</span><span class="w"> </span><span class="p">(</span><span class="nf">on/off</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">on/off</span><span class="p">)</span><span class="w"> </span><span class="c1">;; OFF</span>
<span class="w">      </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="mi">350</span><span class="w"> </span><span class="nv">:high</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="mi">697</span><span class="w"> </span><span class="nv">:high</span><span class="w"> </span><span class="mi">1209</span><span class="p">)))</span>

<span class="c1">;;; ...</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><a href="https://github.com/li-yiyang/lapork-lecture/blob/e0d1b28b7a39440d0ab02eda50b0cf3abfa8aee5/lisp/oscdef/oscdef.lisp#L55">=start-osc-server=</a> 打开一个 OSC server 来接受控制的 OSC 指令</li>
  <li><code>synth</code> 定义了一个初始 <code>gate</code> 状态为关闭的 <code>phone-tone</code> 的合成器, 也就是我们的拨号器</li>
  <li>定义了三个 OSC 指令, 分别对应 TouchOSC 中的按钮名称:
    <ul>
      <li><code>toneSwitch</code>: 是否使用拨号器 (开关合成器 <code>phone</code> 的 <code>gate</code> 信号,
        同时修改局部变量 <code>on/off</code> 的值为开或关);</li>
      <li><code>toneSilent</code>: 一时的静音, 当 <code>gate</code> 为非 <code>0</code> 时, 将 <code>phone</code> 的 <code>gate</code> 信号设为 <code>0</code>,
        其他的时候恢复正常状态;</li>
      <li><code>tone1</code>: 使用按键 <code>1</code> 的声音, 若关闭, 则将声音重新置为等待拨号的呜呜声状态</li>
      <li>其他的 <code>tone*</code> 同理</li>
    </ul>
  </li>
</ul>
<details><summary>完整的 TouchOSC 和控制代码</summary>
<p>因为手动一个个设置 <code>tone*</code> 太麻烦了, 所以这里我使用了 Common Lisp 的特性:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">macrolet</span><span class="w"> </span><span class="p">((</span><span class="nf">tone*</span><span class="w"> </span><span class="p">(</span><span class="nf">high-freqs</span><span class="w"> </span><span class="nv">&amp;rest</span><span class="w"> </span><span class="nv">tone-table</span><span class="p">)</span>
<span class="w">             </span><span class="o">`</span><span class="p">(</span><span class="nf">progn</span>
<span class="w">                </span><span class="o">,@</span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="p">(</span><span class="nf">low</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">tones</span><span class="p">)</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">tone-table</span>
<span class="w">                        </span><span class="nv">:collect</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">tone</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">tones</span>
<span class="w">                              </span><span class="nv">:for</span><span class="w"> </span><span class="nv">high</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">high-freqs</span>
<span class="w">                              </span><span class="nv">:collect</span>
<span class="w">                              </span><span class="o">`</span><span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="s">&quot;tone~A&quot;</span><span class="w"> </span><span class="nv">tone</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gate</span><span class="p">)</span>
<span class="w">                                 </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">gate</span><span class="p">)</span>
<span class="w">                                     </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="mi">350</span><span class="w">  </span><span class="nv">:high</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span>
<span class="w">                                     </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">phone</span><span class="w"> </span><span class="nv">:low</span><span class="w"> </span><span class="o">,</span><span class="nv">low</span><span class="w"> </span><span class="nv">:high</span><span class="w"> </span><span class="o">,</span><span class="nv">high</span><span class="p">))))</span>
<span class="w">                          </span><span class="nv">:into</span><span class="w"> </span><span class="nv">defs</span>
<span class="w">                        </span><span class="nv">:finally</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;append</span><span class="w"> </span><span class="nv">defs</span><span class="p">))))))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">tone*</span><span class="w"> </span><span class="p">(</span><span class="w">        </span><span class="mi">1209</span><span class="w"> </span><span class="mi">1336</span><span class="w"> </span><span class="mi">1477</span><span class="w"> </span><span class="mi">1633</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">697</span><span class="w">     </span><span class="mi">1</span><span class="w">    </span><span class="mi">2</span><span class="w">    </span><span class="mi">3</span><span class="w">    </span><span class="nv">A</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">770</span><span class="w">     </span><span class="mi">4</span><span class="w">    </span><span class="mi">5</span><span class="w">    </span><span class="mi">6</span><span class="w">    </span><span class="nv">B</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">852</span><span class="w">     </span><span class="mi">7</span><span class="w">    </span><span class="mi">8</span><span class="w">    </span><span class="mi">9</span><span class="w">    </span><span class="nv">C</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="mi">941</span><span class="w">     </span><span class="nb">*</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="nv">|</span><span class="cm">#|  D)))</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><code>macrolet</code> 定义了一个局部的宏展开 <code>tone*</code>, 将输入的参数看作是一个表格,
    第一行是高频信息, 剩下的行 (<code>&amp;rest</code>) 为 <code>(低频信息 . 按键名称)</code></li>
</ul>
<p>完整的代码见: <a href="https://github.com/li-yiyang/lapork-lecture/blob/main/lisp/examples/lapork-03/phone.lisp">phone.lisp</a> 以及 <a href="https://github.com/li-yiyang/lapork-lecture/blob/main/touchosc/lecture-03/phone-calling.tosc">phone-calling.tosc</a>.</p>
</details>
<p>效果如下:</p>
<video controls width="600" style="display: block; margin: auto;"><source src="/_img/lapork/03/phone.mp4" type="video/mp4" /></video>
<p>一些鬼点子: 如果用这个生成一段随机拨号音, 然后配上 Lain 的 Whisper 采样 greeting,
  估计会有种赛博朋克的感觉.</p>
<h3>Fire</h3>]]></content><author><name></name></author><category term="lapork" /><summary type="html"><![CDATA[About 之后的一些代码会放到 Github 上面 (li-yiyang/lapork-lecture), 方便复用了. TLDR 声音是波, 一些特别的波型的产生和对他们进行一个调参数 采样的播放 声道, 输出的设备以及其他 Sound is Waves 咬文嚼字一下 其实严格来说, 声音是振动 \(f(t)\), 而波是声音的传播 (时空分布) \(f(x, t)\). 不知道这样会不会更加严格一些. 比如说打开示波器, 去检查声音信号随时间的变化情况: (play (* 0.125 (+ (sin-osc.ar 350) (sin-osc.ar 440)))) 波形与频谱的显示 lapork.plot emmm, 但是不是所有时候都能手上拿着一台示波器, 那么是否有没有好的方法来解决这个问题呢? 虽然在 SuperCollider 中有 =plot= 这样的函数, 但是在 cl-collider 中并没有类似的功能. 参考 cl-collider/issue #81 中的方法, 可以用 Gnuplot 简单的实现一个绘图功能. 完整的代码见 lapork/plot. 具体思路的说明 plot: 相当于是在后台开了一个 Gnuplot 程序, 通过生成 inline data 和 plot 命令, 可以用来绘图 scope: 例 (scope (sin-osc.ar 440) :frames 200) freqscope: 各种各样的波形的显示 在前面的几节里面已经接触过: sin-osc: 正弦波 blip: 脉冲 white-noise: 白噪声 类似的还有: brown-noise: 棕噪声 pink-noise: 粉噪声 下面是一些声音种类以及其波形的形状: 声音波形 sin-osc 正弦波 blip 脉冲波 saw 锯齿波 pulse 方波 white-noise 白噪声 brown-noise 粽噪声 pink-noise 粉噪声 gray-noise 灰噪声 lf-tri 低频 (Low Frequency) 三角波 lf-pulse 低频 (Low Frequency) 方波 sin-osc 和 lf-noise1 (低频噪声) 的合成 部分解释: lf-* 开头的 (对应 SuperCollider 中 LF) 开头的表示 Low Frequency, 用于去更好地生成一些低频的信号. 例: 比较 pulse 和 lf-pulse 的波形, 前者是通过多个正弦波 (傅立叶分解) 叠加得到的, 后者则是直接通过翻转值 (0 或 1) 来产生的. 在低频的情况下, (通过 CPU 控制的) 直接翻转显然更优, 而高频情况下, 由于会对 CPU 产生较大的负担, 还是不如用声卡的输出来的方便. 不同的音色 滤波器 你说, 我在听 &#8211; 录音的导入和导出 导入声音 可以导入一段声音 (sampling, 采样) 进行播放: (defparameter layer (buffer-read &quot;~/Code/lapork-lecture/samples/whispers/layer.aiff&quot;))]]></summary></entry><entry><title type="html">LapTop Ork (02: Synth, Network)</title><link href="/lapork/lapork-02/" rel="alternate" type="text/html" title="LapTop Ork (02: Synth, Network)" /><published>2025-09-29T00:00:00+00:00</published><updated>2025-09-29T00:00:00+00:00</updated><id>/lapork/lapork-02</id><content type="html" xml:base="/lapork/lapork-02/"><![CDATA[<h1>About</h1>
<p><del>有点想把名字改成今日声</del> (有点神经了)</p>
<h2>太长不看版</h2>
<p>本期看点:</p>
<ul>
  <li>小伙定义了一个合成器, 竟对波形如此如此, 那般那般</li>
  <li>利用 <a href="https://en.wikipedia.org/wiki/Open_Sound_Control">OSC</a> 进行一个赛博音乐会</li>
</ul>
<h1>Synth</h1>
<h2>正弦波</h2>
<p><a href="/lapork/lapork-01/">上期</a> 说到, 可以用波形来描述声音, 比如最简单的正弦波</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">440</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w">                </span><span class="c1">; (play *)</span>
</pre></div>
<p>以及拍频的叠加:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">440</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mf">0.5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">442</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mf">0.5</span><span class="p">))</span>
</pre></div>
<p>效果如图所示:</p>
<p><img src="/_img/lapork/02/wav-440.jpg" alt="/_img/lapork/02/wav-440.jpg" /></p>
<p>即, 通过叠加不同的正弦波信号, 可以产生不同 (波形) 的声音.
  于是比较聪明的一个方法就是用一组正弦波去合成一个任意的周期性信号
  (可以参考 Mathematica 函数 <a href="https://reference.wolfram.com/language/ref/FourierDST.html">FourierDST</a>).</p>
<details><summary>一个简单的示例代码</summary>
<div class="highlight"><pre><span></span><span class="n">Module</span><span class="p">[{</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">xg</span><span class="p">,</span><span class="w"> </span><span class="n">fg</span><span class="p">,</span><span class="w"> </span><span class="n">coef</span><span class="p">,</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Function</span><span class="p">[{</span><span class="n">x</span><span class="p">},</span><span class="w"> </span><span class="n">If</span><span class="p">[</span><span class="n">Abs</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]]</span>
<span class="w"> </span><span class="p">},</span>
<span class="w"> </span><span class="n">xg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Table</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="o">/</span><span class="n">n</span><span class="p">}];</span>
<span class="w"> </span><span class="n">fg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">xg</span><span class="p">;</span>
<span class="w"> </span><span class="n">coef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FourierDST</span><span class="p">[</span><span class="n">fg</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Sqrt</span><span class="p">[</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>
<span class="w"> </span><span class="n">Show</span><span class="p">[</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">   </span><span class="n">ListPlot</span><span class="p">[</span><span class="n">Transpose</span><span class="p">[{</span><span class="n">xg</span><span class="p">,</span><span class="w"> </span><span class="n">fg</span><span class="p">}],</span><span class="w"> </span><span class="n">PlotRange</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">All</span><span class="p">],</span>
<span class="w">   </span><span class="n">Plot</span><span class="p">[</span><span class="n">Sum</span><span class="p">[</span><span class="n">coef</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Sin</span><span class="p">[</span><span class="n">Pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">],</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">}],</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span>
<span class="w">    </span><span class="n">PlotRange</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">All</span><span class="p">]</span>
<span class="w">   </span><span class="p">},</span>
<span class="w">  </span><span class="n">PlotRange</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">All</span><span class="p">]]</span>
</pre></div>
<p><img src="/_img/lapork/02/fourierdst.jpg" alt="/_img/lapork/02/fourierdst.jpg" /></p>
<p>诶? 那如果我直接输出信号波形岂不是更快? 甚至还能够任意地拟合.
  你说的对, 请参考 <a href="https://www.wolframcloud.com/obj/liyiyang21a/Published/img2wav.nb">img2wav.nb</a> 来尝试用声音画图片吧.</p>
</details>
<p>那假如把一个正弦波的信号的两个参数 (增幅, 频率) 视为一个可以变化的量,
  比如:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.2</span><span class="p">)))</span>
</pre></div>
<p>即增幅是一个随时间变化的量, 出来的效果其实和前面的叠拍频的效果差不多:</p>
<p><img src="/_img/lapork/02/wav-amp.jpg" alt="/_img/lapork/02/wav-amp.jpg" /></p>
<p>(注: 为了方便打印, 这里用的是 <code>(sin-osc.ar 440.0 0.0 (sin-osc.ar 10.0 0.0 0.2))</code>)</p>
<h2>包络</h2>
<p>上面的思路相当于给原始的正弦波波形添加了一个正弦波包络,
  直接思路打开, 为什么不叠加任意形状的包络呢?
  比如一个被蛇吞掉的大象:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.8</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">kr</span>
<span class="w">          </span><span class="p">(</span><span class="nf">env</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="w">    </span><span class="mf">0.1</span><span class="w">     </span><span class="mf">1.0</span><span class="w">     </span><span class="mf">0.8</span><span class="w">     </span><span class="mf">0.9</span><span class="w">     </span><span class="mf">1.0</span><span class="w">     </span><span class="mf">0.1</span><span class="w">   </span><span class="mi">0</span><span class="p">)</span>
<span class="w">               </span><span class="o">&#39;</span><span class="p">(</span><span class="w"> </span><span class="mf">0.5</span><span class="w">     </span><span class="mf">0.1</span><span class="w">     </span><span class="mf">0.1</span><span class="w">     </span><span class="mf">0.5</span><span class="w">     </span><span class="mf">0.1</span><span class="w">     </span><span class="mf">0.1</span><span class="w">    </span><span class="mf">0.5</span><span class="p">))</span>
<span class="w">          </span><span class="nv">:act</span><span class="w"> </span><span class="nv">:free</span><span class="p">)))</span>
</pre></div>
<p>效果如下:</p>
<p><img src="/_img/lapork/02/elemphant-in-snake.jpg" alt="/_img/lapork/02/elemphant-in-snake.jpg" /></p>
<p>解释:</p>
<ul>
  <li><code>env</code> 用来构造一个 *Env*​olope (包络) 对象, 其参数如下说明:
    <pre class="example">
(env levels times &amp;optional (curve :lin) (release-node -99) (loop-node -99))
    </pre>
    <p>其中:</p>
    <ul>
      <li><code>levels</code> 和 <code>times</code> 相当于是描述了一个包络的 XY 图像,
        但是用的是一个比较 “别扭的” 的方式进行的
        <pre class="example">
levels: 第一段的幅值                            第二段的幅值 ...
times:               第一段和第二段之间的时间差              第二段和第三段之间的时间差 ...
curves:           第一段和第二段之间变换的波形类型           ...
        </pre>
        <p>即, <code>times</code> 是每段 <code>level</code> 之间的事件间隔持续的时间长度</p>
        <p>假如你觉得这种方式有点奇奇怪怪的, 不妨看看 <a href="/jekyll/little-sound-dj/">LSDj</a> 中对波形的定义吧</p>
      </li>
      <li><code>curve</code> 和 <code>times</code> 同理, 可以是一个间隔之间的变换方式,
        也可以直接是一个全部区间的变形方式, 常见的有:
        <ul>
          <li><code>:lin</code> 线性 (默认的)</li>
          <li><code>:exp</code> 指数 (幂律) (但是试了之后效果一般)</li>
          <li><code>:sin</code> 正弦 (试试看, 会发现波形在抖)</li>
        </ul>
      </li>
      <li>其他的还没试过, 可以自己看 <a href="https://doc.sccode.org/Classes/Env.html">文档</a></li>
    </ul>
  </li>
  <li><code>env-gen.kr</code> 根据 <code>env</code> 对象来构造一个控制信号,
    这个控制信号就可以像一般的振幅一样来用了 (包络信号嘛)
    <ul>
      <li><code>act</code>: 控制在包络结束的时候干什么, 比如:
        <ul>
          <li><code>:free</code> 将整个信号清除,
            这就会导致上面的信号在播放后不会像之前的 <code>sin-osc</code> 一样一直在吵</li>
          <li><code>:no-action</code> 啥也不干,
            一般需要手动 <code>free</code> 掉</li>
          <li>其他见 <a href="https://doc.sccode.org/Classes/Done.html">Done</a> 的文档</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h3>预制包络</h3>
<p>显然, 一个个手动构造包络 (<code>env</code>) 也有点太麻烦了. 并且也有点没必要,
  为什么不试试用那些已经构造好的信号形状来去构造包络呢?</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">blip</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="p">(</span><span class="nf">sine</span><span class="w"> </span><span class="mf">1.5</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="nv">:act</span><span class="w"> </span><span class="nv">:free</span><span class="p">)))</span>
</pre></div>
<p><img src="/_img/lapork/02/dumpling.jpg" alt="/_img/lapork/02/dumpling.jpg" /></p>
<p>(我愿称之为饺子音)</p>
<p>解释:</p>
<ul>
  <li><code>(blip.ar &amp;optional freq nharm mul add)</code>
    在一个周期里面产生 <code>nharm</code> 个峰, 第 <code>0</code> 个峰为脉冲峰
    <p><img src="/_img/lapork/02/blip.jpg" alt="/_img/lapork/02/blip.jpg" /></p>
  </li>
  <li><code>(sine &amp;optional dur amp)</code> 产生一个持续时间为 <code>dur</code> (s),
    幅值为 <code>amp</code> 的一个 \(&pi; / 2\) 波形的包络</li>
</ul>
<p>那么是否还有其他的包络呢? 也许是有的吧, 但是没有用过.</p>
<h3>ADSR (*A*​ttack, *D*​ecay, *S*​ustain, *R*​elease)</h3>
<p>这个是我在合成器中看到的概念,
  大概是早期模拟合成器里面用来描述和控制包络的一种 “语言”.</p>
<p>即:</p>
<p><img src="/_img/lapork/02/ADSR_parameter.svg" alt="/_img/lapork/02/ADSR_parameter.svg" /></p>
<p>(图片来源于 <a href="https://en.wikipedia.org/wiki/Envelope_(music)">Wikipedia</a>)</p>
<details><summary>那么来试试吧&#8230;</summary>
<p>按照 Wikipedia 上的定义, 并不难给出这样的一个表示:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">adsr-env</span><span class="w"> </span><span class="p">(</span><span class="nf">attack</span><span class="w"> </span><span class="nv">decay</span><span class="w"> </span><span class="nv">sustain</span><span class="w"> </span><span class="nv">release</span>
<span class="w">                 </span><span class="nv">&amp;key</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">sustain-level</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">peak-level</span><span class="w">    </span><span class="mf">1.0</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">curve</span><span class="w"> </span><span class="nv">:lin</span><span class="p">))</span>
<span class="w">  </span><span class="s">&quot;Create a ADSR envolope. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">sustain*</span><span class="w"> </span><span class="p">(</span><span class="nf">sc::mul</span><span class="w"> </span><span class="nv">sustain-level</span><span class="w"> </span><span class="nv">peak-level</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">env</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">0</span><span class="w">      </span><span class="nv">peak-level</span><span class="w">     </span><span class="nv">sustain*</span><span class="w">       </span><span class="nv">sustain*</span><span class="w">       </span><span class="mi">0</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">list</span><span class="w">  </span><span class="nv">attack</span><span class="w">          </span><span class="nv">decay</span><span class="w">        </span><span class="nv">sustain</span><span class="w">        </span><span class="nv">release</span><span class="p">)</span>
<span class="w">         </span><span class="nv">curve</span><span class="p">)))</span>
</pre></div>
<p>于是可以测试一下:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mi">440</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr-env</span><span class="w"> </span><span class="mf">0.3</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.4</span><span class="w"> </span><span class="mf">0.3</span><span class="p">))))</span>
</pre></div>
<p>以下是不同的 <code>curve</code> 时的包络的形状:</p>
<p><img src="/_img/lapork/02/adsr.jpg" alt="/_img/lapork/02/adsr.jpg" /></p>
<p>注: 虽然也有一个函数叫做 <a href="https://github.com/byulparan/cl-collider/blob/cc05bfb2ecfa34b9cd0660d19a638434f447be5c/ugens/EnvGen.lisp#L181">=adsr=</a>, 但是其 <code>sustain</code> 的行为是按下后等待一个
  <code>release</code> 的信号, 和简单的 ADSR 稍微有一点点区别. (吗? )</p>
</details>
<h2>All you need is Synth</h2>
<p>上面的例子中, 用包络和基底的波形 (<code>sin-osc</code>, <code>blip</code>) 可以构造出比较有趣的声音,
  如果习惯编程的话, 应该会下意识地想要用函数来简化声音的构造, 比如:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">play-note</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;key</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="mf">440.0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">duration</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="p">(</span><span class="nf">adsr-env</span><span class="w"> </span><span class="mf">0.2</span><span class="w"> </span><span class="mf">0.3</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">duration</span><span class="w"> </span><span class="mf">0.4</span><span class="p">)</span><span class="w"> </span><span class="mf">0.6</span>
<span class="w">                                          </span><span class="nv">:curve</span><span class="w"> </span><span class="nv">:sin</span><span class="p">)))))</span>
</pre></div>
<p>于是你就可以用:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="w"> </span><span class="nv">dur</span><span class="w"> </span><span class="nb">sleep</span><span class="p">)</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="o">&#39;</span><span class="p">((</span><span class="mi">200</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="w">                                  </span><span class="p">(</span><span class="mi">210</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="w">                                  </span><span class="p">(</span><span class="mi">300</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span>
<span class="w">      </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nf">play-note</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="nv">:duration</span><span class="w"> </span><span class="nv">dur</span><span class="p">)</span>
<span class="w">      </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nb">sleep</span><span class="w"> </span><span class="nb">sleep</span><span class="p">))</span>
</pre></div>
<p>这样的方式来演奏了呢~</p>
<p>但是如果在合成器的视角来看的话, 其实还有一种方式:</p>
<ul>
  <li>把每个 Lisp 的 S-expression 看作是一个信号单元, 比如
    <code>sin-osc</code> 是一个振荡器单元, 它的参数是从其他单元连过来的线,
    它的输出是连接到一个 (加法器) 的输出单元 (DSP)</li>
  <li>那么把这些单元串在一起, 你就得到了一个 “Synthesizer” (合成器) 啦</li>
  <li>比如你可以在播放音乐的时候去改变一些参数, 就像是扭旋钮一样,
    去改变这个声音出来的感觉</li>
</ul>
<details><summary>一些例子</summary>
<ul>
  <li>比如我觉得比较帅的 <a href="https://mirack.app">miRack</a></li>
  <li>或者如果你觉得比较贵的话, 可以试试看 <a href="https://vcvrack.com/Rack">VCV Rack</a></li>
  <li>或者你觉得太便宜的话, 可以去试试看实体的 <a href="https://en.wikipedia.org/wiki/Eurorack">Eurorack Synthesizer</a></li>
</ul>
</details>
<p>但是毕竟是编程嘛, 咱也并不不需要去扭旋扭和连线, 只需要:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">snake-elemphant</span><span class="w"> </span><span class="p">((</span><span class="nf">freq</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">duration</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span>
<span class="w">                           </span><span class="p">(</span><span class="nf">attack</span><span class="w"> </span><span class="mf">0.1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">decay</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">hold</span><span class="w"> </span><span class="mf">1.0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">curve</span><span class="w"> </span><span class="nv">:lin</span><span class="p">)</span>
<span class="w">                           </span><span class="p">(</span><span class="nf">bais</span><span class="w"> </span><span class="mf">0.05</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">sustain</span><span class="w"> </span><span class="mf">0.95</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">env</span><span class="w"> </span><span class="p">(</span><span class="nf">env</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="nv">bais</span><span class="w">   </span><span class="mf">1.0</span><span class="w">   </span><span class="nv">sustain</span><span class="w">  </span><span class="nv">sustain</span><span class="w">  </span><span class="mf">1.0</span><span class="w">   </span><span class="nv">bais</span><span class="w">   </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nb">list</span><span class="w">  </span><span class="nv">hold</span><span class="w"> </span><span class="nv">attack</span><span class="w"> </span><span class="nv">attack</span><span class="w"> </span><span class="nv">duration</span><span class="w"> </span><span class="nv">attack</span><span class="w"> </span><span class="nv">attack</span><span class="w"> </span><span class="nv">decay</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">curve</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">sig</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">(</span><span class="nf">env-gen</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="nv">env</span><span class="w"> </span><span class="nv">:act</span><span class="w"> </span><span class="nv">:free</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="nv">sig</span><span class="p">))))</span>
</pre></div>
<p>解释:</p>
<ul>
  <li><code>defsynth</code> 定义了一个名字叫做 <code>snake-elemphant</code> 的合成器, 默认的参数是用 <code>&amp;key</code> 的形式</li>
  <li><code>out.ar</code> 将输出的信号发送到 <code>out</code> (<code>0</code> 表示左声道, <code>1</code> 表示右声道, 其他的看你的设备了)
    信道的缓冲区 (buffer) 中, 可以想像成把连好的线都接到耳机/音箱上</li>
</ul>
<p>于是就可以用:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;snake-elemphant</span><span class="p">)</span>
</pre></div>
<p>来播放一段声音了.</p>
<p>是不是觉得有点普通?</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;snake-elemphant</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="nv">:duration</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="nv">:curve</span><span class="w"> </span><span class="nv">:sin</span><span class="p">)</span>
</pre></div>
<p>是不是感觉还是有点普通?</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">node</span><span class="w"> </span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;snake-elemphant</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="nv">:duration</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="nv">:from</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="nv">:upto</span><span class="w"> </span><span class="mi">400</span><span class="w"> </span><span class="nv">:by</span><span class="w"> </span><span class="mi">50</span>
<span class="w">        </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nb">sleep</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="nv">freq</span><span class="p">)</span>
<span class="w">        </span><span class="nv">:finally</span><span class="w"> </span><span class="p">(</span><span class="nf">free</span><span class="w"> </span><span class="nv">node</span><span class="p">)))</span>
</pre></div>
<p>相当于是在合成器工作的时候也能扭旋扭改变其参数.</p>
<h1>OSC</h1>
<h2>Course Specific Softwares</h2>
<p>课上用了这样的一个工作流:</p>
<ul>
  <li><a href="https://hexler.net/touchosc">TouchOSC</a> 用于构建一个虚拟的 “旋钮” 控制板,
    用可视化拖拽的方式可以去构建一堆的仪表 (按钮, 滑块等),
    然后通过交互仪表的方式, 通过 OSC 协议去向服务器发送控制信号</li>
  <li><a href="https://hexler.net/protokolhttps://hexler.net/protokol">Protokol</a> 可以看作是一个用于 OSC 协议的 “电流表”,
    相当于是本地监听, 然后转发给其他的服务器/端口</li>
  <li><a href="https://docs.supercollider.online/Classes/OSCdef.html">SuperCollider OSCDef</a> 用来连接到 OSC 服务器上去接受 OSC 控制信号,
    然后通过这个控制信号去 <code>ctrl</code> 合成器的表现</li>
  <li>OscGroupClient 一个看起来像是本地端口转发的一个东西,
    看了一下 <code>.app</code> 的构成像是一个简单的 Python + Tk 做的软件,
    简单逆向了一下好像是用的 Python <code>osc</code>, 具体啥功能暂时没细看</li>
</ul>
<p>那么实际上上面的这些完全可以 All in Lisp 了呢.</p>
<h2>Behind The Scene</h2>
<p>这里参考 <a href="https://github.com/zzkt/osc/blob/core/osc-examples.lisp">osc-examples.lisp</a> 来做一个简单的说明:</p>
<h3>OSCDef</h3>
<p>OSCDef 相当于构建了一个简单 OSC 协议的监听,
  然后根据接受到的 OSC 控制信号来控制 synth.</p>
<details><summary>于是可以编写如下的简单控制代码</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*oscdef-table*</span><span class="w"> </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="ss">&#39;equal</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;A rule mapping table of OSC control definition.</span>

<span class="s">Dev Note:</span>
<span class="s">The table use string as name key, and a list of functions</span>
<span class="s">as control process. &quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*osc-debug*</span><span class="w"> </span><span class="nv">nil</span>
<span class="w">  </span><span class="s">&quot;Set to non-nil to debug the OSC messages. &quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">declaim</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nf">integer</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="nv">*osc-in-port*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*osc-in-port*</span><span class="w"> </span><span class="mi">2333</span>
<span class="w">  </span><span class="s">&quot;Listening port of OSC. &quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">declaim</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nv">null</span><span class="w"> </span><span class="nv">bt:thread</span><span class="p">)</span><span class="w"> </span><span class="nv">*osc-listening-thread*</span><span class="p">))</span>
<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*osc-listening-thread*</span><span class="w"> </span><span class="nv">nil</span>
<span class="w">  </span><span class="s">&quot;`bt:thread&#39; to listening OSC control input&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">osc-running-p</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="s">&quot;Status/Control of if running OSC listening server. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="nv">*osc-listening-thread*</span>
<span class="w">       </span><span class="p">(</span><span class="nf">bt:thread-alive-p</span><span class="w"> </span><span class="nv">*osc-listening-thread*</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">osc-running-p</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">status</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">status</span>
<span class="w">      </span><span class="p">(</span><span class="nf">start-osc-listening</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">stop-osc-listening</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">stop-osc-listening</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="s">&quot;Stop OSC listening server. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">osc-running-p</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">bt:destroy-thread</span><span class="w"> </span><span class="nv">*osc-listening-thread*</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">start-osc-listening</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;key</span><span class="w"> </span><span class="p">(</span><span class="nf">port</span><span class="w"> </span><span class="nv">*osc-in-port*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">buffer</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="nb">force</span>
<span class="w">                            </span><span class="nv">&amp;aux</span><span class="w"> </span><span class="p">(</span><span class="nf">force?</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nb">force</span><span class="w"> </span><span class="p">(</span><span class="nf">/=</span><span class="w"> </span><span class="nv">port</span><span class="w"> </span><span class="nv">*osc-in-port*</span><span class="p">))))</span>
<span class="w">  </span><span class="s">&quot;Start a new OSC listening server.</span>

<span class="s">Parameters:</span>
<span class="s">+ PORT: if changed, will update `*osc-in-port*&#39;</span>
<span class="s">+ FORCE: if non-nil, will close existing server</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nf">integer</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="nv">port</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">force?</span><span class="w"> </span><span class="p">(</span><span class="nf">stop-osc-listening</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">*osc-in-port*</span><span class="w"> </span><span class="nv">port</span>
<span class="w">        </span><span class="nv">*osc-listening-thread*</span>
<span class="w">        </span><span class="p">(</span><span class="nf">bt:make-thread</span>
<span class="w">         </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span>
<span class="w">           </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">s</span><span class="w">    </span><span class="p">(</span><span class="nf">usocket:socket-connect</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="nv">nil</span>
<span class="w">                                               </span><span class="nv">:local-port</span><span class="w"> </span><span class="nv">port</span>
<span class="w">                                               </span><span class="nv">:local-host</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="mi">127</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">                                               </span><span class="nv">:protocol</span><span class="w"> </span><span class="nv">:datagram</span>
<span class="w">                                               </span><span class="nv">:element-type</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">unsigned-byte</span><span class="w"> </span><span class="mi">8</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">buff</span><span class="w"> </span><span class="p">(</span><span class="nf">make-sequence</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nb">vector</span><span class="w"> </span><span class="p">(</span><span class="nf">unsigned-byte</span><span class="w"> </span><span class="mi">8</span><span class="p">))</span><span class="w"> </span><span class="nv">buffer</span><span class="p">)))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">unwind-protect</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:for</span><span class="w"> </span><span class="nv">osc-msg</span><span class="w"> </span><span class="nv">:=</span><span class="w"> </span><span class="p">(</span><span class="nf">progn</span>
<span class="w">                                          </span><span class="p">(</span><span class="nf">usocket:socket-receive</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">buff</span><span class="w"> </span><span class="nv">buffer</span><span class="p">)</span>
<span class="w">                                          </span><span class="p">(</span><span class="nf">osc:decode-bundle</span><span class="w"> </span><span class="nv">buff</span><span class="p">))</span>
<span class="w">                        </span><span class="nv">:for</span><span class="w"> </span><span class="nv">name</span><span class="w">  </span><span class="nv">:=</span><span class="w"> </span><span class="p">(</span><span class="nf">osc:command</span><span class="w"> </span><span class="nv">osc-msg</span><span class="p">)</span>
<span class="w">                        </span><span class="nv">:for</span><span class="w"> </span><span class="nv">args</span><span class="w">  </span><span class="nv">:=</span><span class="w"> </span><span class="p">(</span><span class="nf">osc:args</span><span class="w">    </span><span class="nv">osc-msg</span><span class="p">)</span>
<span class="w">                        </span><span class="nv">:for</span><span class="w"> </span><span class="nv">ctrls</span><span class="w"> </span><span class="nv">:=</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">*oscdef-table*</span><span class="p">)</span>
<span class="w">                        </span><span class="c1">;; TODO: log?</span>
<span class="w">                        </span><span class="c1">;; TODO: make ctrl into other thread?</span>
<span class="w">                        </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">*osc-debug*</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~A(~{~A~^, ~})~%&quot;</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">args</span><span class="p">))</span>
<span class="w">                        </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore-errors</span>
<span class="w">                             </span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">ctrls</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nv">ctrl</span><span class="w"> </span><span class="nv">args</span><span class="p">)))</span>
<span class="w">                        </span><span class="nv">:do</span><span class="w"> </span><span class="p">(</span><span class="nb">force-output</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="p">(</span><span class="nf">usocket:socket-close</span><span class="w"> </span><span class="nv">s</span><span class="p">))))))))</span>

<span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">oscdef</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="w"> </span><span class="nv">lambda-list</span><span class="w"> </span><span class="nv">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Define a OSC command of NAME and LAMBDA-LIST.</span>
<span class="s">This would add new method to `*oscdef-table*&#39; of the NAME. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nb">string</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="o">,</span><span class="nv">lambda-list</span><span class="w"> </span><span class="o">,@</span><span class="nv">body</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="nv">*oscdef-table*</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">oscdef-clear</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;optional</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Clear all the previous OSC method of NAME. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">name</span>
<span class="w">      </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">*oscdef-table*</span><span class="p">)</span><span class="w"> </span><span class="p">())</span>
<span class="w">      </span><span class="p">(</span><span class="nf">clrhash</span><span class="w"> </span><span class="nv">*oscdef-table*</span><span class="p">)))</span>
</pre></div>
</details>
<p>实际的使用效果如下:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">start-osc-listening</span><span class="w"> </span><span class="nv">:port</span><span class="w"> </span><span class="mi">2333</span><span class="p">)</span>

<span class="p">(</span><span class="nf">oscdef-clear</span><span class="w"> </span><span class="s">&quot;/test&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="s">&quot;/test&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;rest</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;Got ~{~A~^, ~}~%&quot;</span><span class="w"> </span><span class="nv">args</span><span class="p">))</span>
</pre></div>
<p>那么稍微改变一下:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defsynth</span><span class="w"> </span><span class="nv">sining</span><span class="w"> </span><span class="p">((</span><span class="nf">freq</span><span class="w"> </span><span class="mi">440</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">out</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">amp</span><span class="w"> </span><span class="mf">0.8</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">out</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">amp</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="nv">freq</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">note</span><span class="w"> </span><span class="p">(</span><span class="nf">synth</span><span class="w"> </span><span class="ss">&#39;sining</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="mi">440</span><span class="p">))</span>

<span class="p">(</span><span class="nf">oscdef</span><span class="w"> </span><span class="s">&quot;/freq&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">freq</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">ctrl</span><span class="w"> </span><span class="nv">note</span><span class="w"> </span><span class="nv">:freq</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">freq</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="mi">200</span><span class="p">)))</span>
</pre></div>
<p>于是你就可以用简单的 TouchOSC 来控制你的合成器了呢.
  不错, 这下就没有什么后顾之忧了.
  理论上来说我可以把所有的东西都用 Common Lisp 来做了.</p>
<p>安心です&#8230;</p>
<h1>Misc</h1>
<h2>Some Wired Bugs and Fixs</h2>
<h3>在 <code>(server-boot *s*)</code> 的时候出现 <code>libc++abi: terminating</code></h3>
<p>在 debug 的时候发现了调用的外部程序 (<code>scsynth</code>) 出现的报错:</p>
<pre class="example">
WARNING: Input sample rate is 24000, but output is 48000. Attempting to set input sample rate to match the output.
ERROR: Setting sample rate failed. OSStatus epon
Possible solutions:
- explicitly set the sample rate to one supported by both devices:
    s.options.sampleRate = &lt;rate&gt;;
- or, in your system&#39;s &quot;Audio MIDI Setup&quot;, set sample rate to the same value on both the input and output devices
- or, disable input completely:
    s.options.numInputBusChannels = 0;
could not initialize audio.
libc++abi: terminating
</pre>
<p>嗯, 所以 AirPods 的输入 (Input: 24kHz) 和输出 (Output: 48kHz) 并不匹配.
  只好在 MIDI Setting 里面把 AirPods 的输出降成 (24 kHz) 了.</p>
<p>不过效果并不好, 采样率降了一半了之后有些声音听起来怪怪的.</p>
<p>最终的解决办法是用 Loopback 新建了一个虚拟设备, 强制输入和输出都是
  (48 kHz) 的采样率了, 然后在 MIDI Setting 里面将其设置为输入和输出.</p>
<p>(这样的好处是可以多输入和多输出, 方便用耳机监听的同时给示波器输出了呢)</p>
<h3>在播放的时候发现声音之后单声道</h3>
<p>比如:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">5.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.8</span><span class="p">)))</span>
</pre></div>
<p>的时候, 会发现只有左边的耳机出声 &#8211; 这个时候, 只需要指定参数:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">5.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.8</span><span class="p">))</span><span class="w"> </span><span class="nv">:out-bus</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<p>就可以在右边发声了呢.</p>
<p>注: 这里你可以用 <code>pharse</code> 参数来控制左右声道的波形的同步.
  比如可以试试看:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.8</span><span class="p">))</span><span class="w"> </span><span class="nv">:out-bus</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="mf">0.8</span><span class="p">))</span><span class="w"> </span><span class="nv">:out-bus</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<p>会感觉魔音贯耳, 有一个从左到右 (或者从右到左) 的一个嗡嗡嗡声.</p>
<h3>KR, AR 啥玩意?</h3>
<p>会发现有 <code>sin-osc.ar</code> 和 <code>sin-osc.kr</code> 两种东西, 但是这有什么区别么?</p>
<ul>
  <li><code>ar</code> 代表 *A*​udio Rate, 一般用来生成音频信号, 比如波形之类的</li>
  <li><code>kr</code> 代表 *C*​ontrol Rate, 一半用来生成控制信号, 比如包络之类的</li>
</ul>]]></content><author><name></name></author><category term="lapork" /><summary type="html"><![CDATA[About 有点想把名字改成今日声 (有点神经了) 太长不看版 本期看点: 小伙定义了一个合成器, 竟对波形如此如此, 那般那般 利用 OSC 进行一个赛博音乐会 Synth 正弦波 上期 说到, 可以用波形来描述声音, 比如最简单的正弦波 (sin-osc.ar 440 0.0 0.5) ; (play *) 以及拍频的叠加: (play (sin-osc.ar 440 0 0.5)) (play (sin-osc.ar 442 0 0.5)) 效果如图所示: 即, 通过叠加不同的正弦波信号, 可以产生不同 (波形) 的声音. 于是比较聪明的一个方法就是用一组正弦波去合成一个任意的周期性信号 (可以参考 Mathematica 函数 FourierDST). 一个简单的示例代码 Module[{ n = 10, xg, fg, coef, f = Function[{x}, If[Abs[x] &lt; 0.5, 1, 0]] }, xg = Table[s, {s, 0., 1., 1./n}]; fg = f /@ xg; coef = FourierDST[fg, 1]/Sqrt[n/2]; Show[ { ListPlot[Transpose[{xg, fg}], PlotRange -&gt; All], Plot[Sum[coef[[i]] * Sin[Pi * i * x], {i, n - 1}], {x, -1, 1}, PlotRange -&gt; All] }, PlotRange -&gt; All]] 诶? 那如果我直接输出信号波形岂不是更快? 甚至还能够任意地拟合. 你说的对, 请参考 img2wav.nb 来尝试用声音画图片吧. 那假如把一个正弦波的信号的两个参数 (增幅, 频率) 视为一个可以变化的量, 比如: (play (sin-osc.ar 440.0 0.0 (sin-osc.ar 1.0 0.0 0.2))) 即增幅是一个随时间变化的量, 出来的效果其实和前面的叠拍频的效果差不多: (注: 为了方便打印, 这里用的是 (sin-osc.ar 440.0 0.0 (sin-osc.ar 10.0 0.0 0.2))) 包络 上面的思路相当于给原始的正弦波波形添加了一个正弦波包络, 直接思路打开, 为什么不叠加任意形状的包络呢? 比如一个被蛇吞掉的大象: (play (* (sin-osc.ar 440.0 0.0 0.8) (env-gen.kr (env &#39;(0 0.1 1.0 0.8 0.9 1.0 0.1 0) &#39;( 0.5 0.1 0.1 0.5 0.1 0.1 0.5)) :act :free))) 效果如下: 解释: env 用来构造一个 *Env*​olope (包络) 对象, 其参数如下说明: (env levels times &amp;optional (curve :lin) (release-node -99) (loop-node -99)) 其中: levels 和 times 相当于是描述了一个包络的 XY 图像, 但是用的是一个比较 “别扭的” 的方式进行的 levels: 第一段的幅值 第二段的幅值 ... times: 第一段和第二段之间的时间差 第二段和第三段之间的时间差 ... curves: 第一段和第二段之间变换的波形类型 ... 即, times 是每段 level 之间的事件间隔持续的时间长度 假如你觉得这种方式有点奇奇怪怪的, 不妨看看 LSDj 中对波形的定义吧 curve 和 times 同理, 可以是一个间隔之间的变换方式, 也可以直接是一个全部区间的变形方式, 常见的有: :lin 线性 (默认的) :exp 指数 (幂律) (但是试了之后效果一般) :sin 正弦 (试试看, 会发现波形在抖) 其他的还没试过, 可以自己看 文档 env-gen.kr 根据 env 对象来构造一个控制信号, 这个控制信号就可以像一般的振幅一样来用了 (包络信号嘛) act: 控制在包络结束的时候干什么, 比如: :free 将整个信号清除, 这就会导致上面的信号在播放后不会像之前的 sin-osc 一样一直在吵 :no-action 啥也不干, 一般需要手动 free 掉 其他见 Done 的文档 预制包络 显然, 一个个手动构造包络 (env) 也有点太麻烦了. 并且也有点没必要, 为什么不试试用那些已经构造好的信号形状来去构造包络呢? (play (blip.ar 200 10 (env-gen.kr (sine 1.5 1.0) :act :free))) (我愿称之为饺子音) 解释: (blip.ar &amp;optional freq nharm mul add) 在一个周期里面产生 nharm 个峰, 第 0 个峰为脉冲峰 (sine &amp;optional dur amp) 产生一个持续时间为 dur (s), 幅值为 amp 的一个 \(&pi; / 2\) 波形的包络 那么是否还有其他的包络呢? 也许是有的吧, 但是没有用过. ADSR (*A*​ttack, *D*​ecay, *S*​ustain, *R*​elease) 这个是我在合成器中看到的概念, 大概是早期模拟合成器里面用来描述和控制包络的一种 “语言”. 即: (图片来源于 Wikipedia) 那么来试试吧&#8230; 按照 Wikipedia 上的定义, 并不难给出这样的一个表示: (defun adsr-env (attack decay sustain release &amp;key (sustain-level 0.5) (peak-level 1.0) (curve :lin)) &quot;Create a ADSR envolope. &quot; (let ((sustain* (sc::mul sustain-level peak-level))) (env (list 0 peak-level sustain* sustain* 0) (list attack decay sustain release) curve))) 于是可以测试一下: (play (sin-osc.ar 440 0 (env-gen.kr (adsr-env 0.3 0.2 0.4 0.3)))) 以下是不同的 curve 时的包络的形状: 注: 虽然也有一个函数叫做 =adsr=, 但是其 sustain 的行为是按下后等待一个 release 的信号, 和简单的 ADSR 稍微有一点点区别. (吗? ) All you need is Synth 上面的例子中, 用包络和基底的波形 (sin-osc, blip) 可以构造出比较有趣的声音, 如果习惯编程的话, 应该会下意识地想要用函数来简化声音的构造, 比如: (defun play-note (&amp;key (freq 440.0) (duration 1)) (play (sin-osc.ar freq 0.0 (env-gen.kr (adsr-env 0.2 0.3 (* duration 0.4) 0.6 :curve :sin))))) 于是你就可以用: (loop :for (freq dur sleep) :in &#39;((200 10 5) (210 20 5) (300 10 5)) :do (play-note :freq freq :duration dur) :do (sleep sleep)) 这样的方式来演奏了呢~ 但是如果在合成器的视角来看的话, 其实还有一种方式: 把每个 Lisp 的 S-expression 看作是一个信号单元, 比如 sin-osc 是一个振荡器单元, 它的参数是从其他单元连过来的线, 它的输出是连接到一个 (加法器) 的输出单元 (DSP) 那么把这些单元串在一起, 你就得到了一个 “Synthesizer” (合成器) 啦 比如你可以在播放音乐的时候去改变一些参数, 就像是扭旋钮一样, 去改变这个声音出来的感觉 一些例子 比如我觉得比较帅的 miRack 或者如果你觉得比较贵的话, 可以试试看 VCV Rack 或者你觉得太便宜的话, 可以去试试看实体的 Eurorack Synthesizer 但是毕竟是编程嘛, 咱也并不不需要去扭旋扭和连线, 只需要: (defsynth snake-elemphant ((freq 440) (duration 10) (out 0) (amp 0.5) (attack 0.1) (decay 1.0) (hold 1.0) (curve :lin) (bais 0.05) (sustain 0.95)) (let* ((env (env (list 0 bais 1.0 sustain sustain 1.0 bais 0) (list hold attack attack duration attack attack decay) curve)) (sig (sin-osc.ar freq 0.0 (env-gen.kr env :act :free)))) (out.ar out (* amp sig)))) 解释: defsynth 定义了一个名字叫做 snake-elemphant 的合成器, 默认的参数是用 &amp;key 的形式 out.ar 将输出的信号发送到 out (0 表示左声道, 1 表示右声道, 其他的看你的设备了) 信道的缓冲区 (buffer) 中, 可以想像成把连好的线都接到耳机/音箱上 于是就可以用: (synth &#39;snake-elemphant) 来播放一段声音了. 是不是觉得有点普通? (synth &#39;snake-elemphant :freq 200 :duration 20 :curve :sin) 是不是感觉还是有点普通? (let ((node (synth &#39;snake-elemphant :freq 200 :duration 10))) (loop :for freq :from 100 :upto 400 :by 50 :do (sleep 1) :do (ctrl node :freq freq) :finally (free node))) 相当于是在合成器工作的时候也能扭旋扭改变其参数. OSC Course Specific Softwares 课上用了这样的一个工作流: TouchOSC 用于构建一个虚拟的 “旋钮” 控制板, 用可视化拖拽的方式可以去构建一堆的仪表 (按钮, 滑块等), 然后通过交互仪表的方式, 通过 OSC 协议去向服务器发送控制信号 Protokol 可以看作是一个用于 OSC 协议的 “电流表”, 相当于是本地监听, 然后转发给其他的服务器/端口 SuperCollider OSCDef 用来连接到 OSC 服务器上去接受 OSC 控制信号, 然后通过这个控制信号去 ctrl 合成器的表现 OscGroupClient 一个看起来像是本地端口转发的一个东西, 看了一下 .app 的构成像是一个简单的 Python + Tk 做的软件, 简单逆向了一下好像是用的 Python osc, 具体啥功能暂时没细看 那么实际上上面的这些完全可以 All in Lisp 了呢. Behind The Scene 这里参考 osc-examples.lisp 来做一个简单的说明: OSCDef OSCDef 相当于构建了一个简单 OSC 协议的监听, 然后根据接受到的 OSC 控制信号来控制 synth. 于是可以编写如下的简单控制代码 (defparameter *oscdef-table* (make-hash-table :test &#39;equal) &quot;A rule mapping table of OSC control definition.]]></summary></entry><entry><title type="html">LapTop Ork (01: Introduction)</title><link href="/lapork/lapork-01/" rel="alternate" type="text/html" title="LapTop Ork (01: Introduction)" /><published>2025-09-22T00:00:00+00:00</published><updated>2025-09-22T00:00:00+00:00</updated><id>/lapork/lapork-01</id><content type="html" xml:base="/lapork/lapork-01/"><![CDATA[<h1>About</h1>
<p>选了一门叫做笔记本乐队的音乐课程, 真有意思.
  用博客的方式记录一下, 不然感觉最近的东西都要花好久才能有结果,
  没啥东西好写博客了.</p>
<h2>免责声明</h2>
<p>这里我还是按照自己的 XP, 换上了邪恶括号语言 Lisp (<a href="https://github.com/byulparan/cl-collider">byulparan/cl-collider</a>),
  而不是使用 <a href="https://github.com/supercollider/supercollider">SuperCollider</a> 自己的语言.</p>
<p>不过说实话, 还是想要 <a href="https://opusmodus.com/">Opusmodus</a>, 不知道会不会有什么好心人看到我这句话,
  然后大发善心给我 250 欧让我买教育版.</p>
<p>(嘶&#8230; 明明都是在做天上掉馅饼的美梦了, 竟然还是教育版而不是个人版么</p>
<p>理论上来说, 大致的内容和 SuperCollider 是没啥区别的,
  但是毕竟会写程序加一些奇奇怪怪的个人 XP 进去,
  所以不保证之后完全和课上讲的东西是一致的.</p>
<p>(但是保证会有课上有的所有功能并且会多加入自己的私货</p>
<h1>对这种 Expermental 音乐的个人理解</h1>
<p>根据 Logic of Expermentation 中的描述, 传统的西方音乐往往被认为是:</p>
<blockquote>
  <p>performance is the moment for the concrete sonic representation
    of an already known sound structure</p>
</blockquote>
<p>即是按照曲谱的重现, 而所谓的 expermental 将其视为 problematisation
  (问题的处理? 问题化? )</p>
<p>高情商: 在少量规则制约下由于随机过程自发涌现的秩序感与美感.
  同时表达的媒介并不局限于单一的音频, 而是结合了计算机多媒体技术,
  产生的一种非传统 replay 的音乐范式.</p>
<p>低情商: 看了一圈感觉更像是高级的骰子音乐? 但是我们的骰子比较有意思,
  可能是宇宙线信号, 可能是无意义的生物电动作, 可能是各种奇奇怪怪的东西.
  同时我们的乐器本身也就是 play 的一环. 但是为了防止完全的随机变成噪声,
  通过简单的程序规约的范式来让声音变得好听一点.</p>
<p>一些可能可行的例子:</p>
<ul>
  <li>训练一个马尔可夫链 (MCMC) 去在不同的音符状态之间去跳转,
    然后通过外界的一些东西去加入一个热噪声
    (比如更改每个状态节点之间的概率权重, 或是更容易或更不容易跳转),
    这样就能够实现一个有意思的 automatic compose</li>
  <li>&#8230;</li>
</ul>
<h1>Tools</h1>
<h2>Installation (via homebrew)</h2>
<p>假如你像我一样在使用 macOS, 或是使用带包管理器的 linux (or other
  unix-like system), 你可以使用你的包管理器快速地安装好以下的环境:</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Common_Lisp">Common Lisp</a> (<a href="https://www.sbcl.org/">SBCL</a> with <a href="https://www.quicklisp.org/">Quicklisp</a>)</li>
  <li><a href="https://supercollider.github.io">SuperCollider</a></li>
</ul>
<p>详情请参考 <a href="https://github.com/byulparan/cl-collider">byulparan/cl-collider</a>.</p>
<h2>Server Boot</h2>
<ul>
  <li>新建一个服务器 <code>(make-external-server &quot;name&quot; :host ip-addr :port port)</code></li>
  <li>启动这个服务器 <code>(server-boot *s*)</code></li>
  <li>Common Lisp 通过 OSC (<a href="https://en.wikipedia.org/wiki/Open_Sound_Control">Open Sound Control</a>) 向 SuperCollider
    服务器发送指令, 后者将其渲染成音频信号进行播放</li>
</ul>
<details><summary>折叠了, 有点普通</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">ql:quickload</span><span class="w"> </span><span class="nv">:cl-collider</span><span class="p">)</span>
<span class="p">(</span><span class="nf">in-package</span><span class="w"> </span><span class="nv">:sc-user</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*s*</span>
<span class="w">  </span><span class="p">(</span><span class="nf">make-external-server</span><span class="w"> </span><span class="s">&quot;name-of-server&quot;</span>
<span class="w">                        </span><span class="nv">:host</span><span class="w"> </span><span class="s">&quot;127.0.0.1&quot;</span>
<span class="w">                        </span><span class="nv">:port</span><span class="w"> </span><span class="s">&quot;4444&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;新建一个 SuperCollider 的服务器声明. &quot;</span><span class="p">)</span>

<span class="c1">;; 启动这个 SuperCollider 音频服务器</span>
<span class="p">(</span><span class="nf">server-boot</span><span class="w"> </span><span class="nv">*s*</span><span class="p">)</span>
</pre></div>
</details>
<h2>Play</h2>
<ul>
  <li><code>(sin-osc.ar freq phase mul add)</code>
    <p>创建了一个以 <code>freq</code> 频率振动的正弦波, 其相位为 <code>phase</code>, 增幅为 <code>mul</code>,
      偏移为 <code>add</code>, 使用 <code>play</code> 可以将其在 SuperCollider 服务器上播放.</p>
    <p>用 <code>(stop)</code> 可以停止声音播放.</p>
    <ul>
      <li>拍频的例子 I
        <blockquote>
          <p>两个频率不同的信号进行合波后得到频率为两者之差的新信号.
            cite: <a href="https://zh.wikipedia.org/zh-cn/拍频">Wikipedia</a></p>
        </blockquote>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.2</span><span class="p">))</span>
<span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.5</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="mf">0.2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">sleep</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">stop</span><span class="p">)</span>
</pre></div>
      </li>
    </ul>
  </li>
  <li><code>(white-noise.ar mul add)</code>
    <p>创建一个 <a href="https://en.wikipedia.org/wiki/White_noise">白噪声</a></p>
  </li>
  <li><code>(mouse-x.kr min max warp lag)</code>
    <p>创建一个由鼠标控制的, 其值在 <code>min</code> 到 <code>max</code> 之间,
      由 <code>wrap</code> (默认 <code>:linear</code>) 进行映射, 值变化有一个 <code>lag</code> 的动态变量.</p>
    <ul>
      <li>拍频的例子 II
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="mf">440.0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mf">0.1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">play</span><span class="w"> </span><span class="p">(</span><span class="nf">sin-osc</span><span class="o">.</span><span class="nv">ar</span><span class="w"> </span><span class="p">(</span><span class="nf">mouse-x</span><span class="o">.</span><span class="nv">kr</span><span class="w"> </span><span class="mi">425</span><span class="w"> </span><span class="mi">455</span><span class="w"> </span><span class="nv">:linear</span><span class="w"> </span><span class="mf">0.4</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mf">0.1</span><span class="p">))</span>
</pre></div>
        <p>如上, 就可以实现一个简单控制了.</p>
      </li>
    </ul>
  </li>
</ul>
<h1>Homework</h1>
<p>作业是读一篇 <a href="https://www.cambridge.org/core/journals/organised-sound">Organised Sound</a> 期刊的文章并做一个小小的笔记.
  我选择了一些比较偏游戏和计算机方向的文章 &#8211; 感觉那些哲学性的文章,
  完全符合我对文科的一般刻板印象.</p>
<h2>TAO: a physical modelling system and related issues</h2>
<blockquote>
  <p>TAO consists of two disinct components, a synthesis engine
    based on a new physical modelling technique called
    <b>cellular sound synthesis</b> (CSS) and a text-based interface &#8230;</p>
</blockquote>
<p>这个 Cellular Sound Synthesis 感觉有点意思, 找了一篇别的:
  <a href="https://hal.science/hal-03112191v1/document">Evolving Complex Sounds with Cellular Automata: an Approach to Granular Synthesis</a>.
  里面说的东西大概能够如下解释 (只看第 4 章即可, 其他的都是前摇):</p>
<p>用原胞自动机去生成一个随机状态, 然后用这个随机状态去控制 OSC.</p>
<p>不过原文 (TAO) 里面的这个 CSS, 怎么看都感觉更像是一个
  FEM (<a href="https://en.wikipedia.org/wiki/Finite_element_method">Finite Element Method</a>), 跑了一个声学振动模式的仿真,
  然后用来产生声音. (真的能实时吗? 在当时的计算机条件下? )</p>
<p>doi: <a href="https://doi.org/10.1017/S1355771896000167">https://doi.org/10.1017/S1355771896000167</a></p>
<p>注: 更新的应该是英伟达的那个网格模拟.</p>
<h2>The creation of an audio environment as part of a computer game world: the design for Jurassic Park &#8211; Operation Genesis on the XBOX as a broad concept for surround installation creation</h2>
<p>这个功能像是早期的空间音频, 通过计算观察者 (听者) 距离音源的距离,
  然后去计算一个不同音源的影响成分. 同时考虑一个环境的影响.
  相当于是一个简化计算, 现在游戏里面的大部分是声线追踪.</p>
<p>doi: <a href="https://doi.org/10.1017/S1355771803000074">https://doi.org/10.1017/S1355771803000074</a></p>
<h2>Interactive Interfaces: Installations produced at ZKM | IMA</h2>
<p>感觉像是把电子音乐作为交互装置来做了, 很帅, 虽然那个头有点瘆人就是了.</p>
<p>doi: <a href="https://doi.org/10.1017/S1355771809990100">https://doi.org/10.1017/S1355771809990100</a></p>
<h2>MISC</h2>
<p>感觉早期 (我挑的这几篇都是好早期的文章了) 的上面都是比较有意思的技术分享,
  虽然不一定是啥很尖端的技术, 但是有点像是 &#8211; 欸, 这玩意我可以试试,
  然后往里面加, 做成了, 加一点点升华, 就放进来了.</p>
<p>后面的一些文章就感觉开始上强度了&#8230; 什么哲学的视角,
  教育学的视角 (这个教育学的视角我可有话说了, 之前宇宙线会议那里也有教育的部分,
  本来还以为是啥从小孩开始忽悠进来做研究的课程设计 (类似于逆转裁判,
  琉璃的宝石之类的), 没想到就是一个制作得非常简陋的 Corsika VR 簇射可视化)
  都统统来了, 根本看不懂一点.</p>
<p>不过有几个从结构化的角度来做音乐生成的感觉挺有意思的,
  相当于是把一片音乐片段融进来?</p>
<p>最新那几个好像是从非西方音乐中找灵感.</p>]]></content><author><name></name></author><category term="lapork" /><summary type="html"><![CDATA[About 选了一门叫做笔记本乐队的音乐课程, 真有意思. 用博客的方式记录一下, 不然感觉最近的东西都要花好久才能有结果, 没啥东西好写博客了. 免责声明 这里我还是按照自己的 XP, 换上了邪恶括号语言 Lisp (byulparan/cl-collider), 而不是使用 SuperCollider 自己的语言. 不过说实话, 还是想要 Opusmodus, 不知道会不会有什么好心人看到我这句话, 然后大发善心给我 250 欧让我买教育版. (嘶&#8230; 明明都是在做天上掉馅饼的美梦了, 竟然还是教育版而不是个人版么 理论上来说, 大致的内容和 SuperCollider 是没啥区别的, 但是毕竟会写程序加一些奇奇怪怪的个人 XP 进去, 所以不保证之后完全和课上讲的东西是一致的. (但是保证会有课上有的所有功能并且会多加入自己的私货 对这种 Expermental 音乐的个人理解 根据 Logic of Expermentation 中的描述, 传统的西方音乐往往被认为是: performance is the moment for the concrete sonic representation of an already known sound structure 即是按照曲谱的重现, 而所谓的 expermental 将其视为 problematisation (问题的处理? 问题化? ) 高情商: 在少量规则制约下由于随机过程自发涌现的秩序感与美感. 同时表达的媒介并不局限于单一的音频, 而是结合了计算机多媒体技术, 产生的一种非传统 replay 的音乐范式. 低情商: 看了一圈感觉更像是高级的骰子音乐? 但是我们的骰子比较有意思, 可能是宇宙线信号, 可能是无意义的生物电动作, 可能是各种奇奇怪怪的东西. 同时我们的乐器本身也就是 play 的一环. 但是为了防止完全的随机变成噪声, 通过简单的程序规约的范式来让声音变得好听一点. 一些可能可行的例子: 训练一个马尔可夫链 (MCMC) 去在不同的音符状态之间去跳转, 然后通过外界的一些东西去加入一个热噪声 (比如更改每个状态节点之间的概率权重, 或是更容易或更不容易跳转), 这样就能够实现一个有意思的 automatic compose &#8230; Tools Installation (via homebrew) 假如你像我一样在使用 macOS, 或是使用带包管理器的 linux (or other unix-like system), 你可以使用你的包管理器快速地安装好以下的环境: Common Lisp (SBCL with Quicklisp) SuperCollider 详情请参考 byulparan/cl-collider. Server Boot 新建一个服务器 (make-external-server &quot;name&quot; :host ip-addr :port port) 启动这个服务器 (server-boot *s*) Common Lisp 通过 OSC (Open Sound Control) 向 SuperCollider 服务器发送指令, 后者将其渲染成音频信号进行播放 折叠了, 有点普通 (ql:quickload :cl-collider) (in-package :sc-user)]]></summary></entry><entry><title type="html">[Reading] A CLOS Protocol for Editor Buffers</title><link href="/lisp/cluffer/" rel="alternate" type="text/html" title="[Reading] A CLOS Protocol for Editor Buffers" /><published>2025-08-05T00:00:00+00:00</published><updated>2025-08-05T00:00:00+00:00</updated><id>/lisp/cluffer</id><content type="html" xml:base="/lisp/cluffer/"><![CDATA[<h1>About</h1>
<p>虽然前一篇还是 <a href="/lem/lem-0/">Lem</a> 这样的新生编辑器, 这篇就又回到了想如何去自己来写一个.
  那么具体是为什么呢? 一个是我在魔改 Lem 的代码的时候发现,
  作者真的好喜欢分包&#8230; (感觉是一个文件分一个包 <code>defpackage</code>)
  这样不是很喜欢, 并且做了太多的抽象导致一个 <code>terminal-input</code> 包装了三层.
  虽然维护上来说是好了一些, 但是感觉还是不太习惯.</p>
<p>以及虽然去模仿了 Emacs 的一些设计, 但是自己做了好多 “小巧思”,
  虽然说不上坏, 但是我用下来还是有点不太习惯 (已经成为 Emacs 的形状哩).
  不过最破防的还是没啥文档, 毕竟感觉 Emacs 里面的 <code>C-h f</code>, <code>C-h v</code>
  这些小文档才是一个 “可以编辑” 的编辑器的核心竞争力.</p>
<p>Lem 的缺点 (目前来看) 主要就是缺少文档, 想要魔改的话比较费劲.
  以及 (Emacs 也有), 缺少一个代码设计的说明, 改底层感觉很难.
  不过好处是我可以把 Emacs 的 <a href="https://github.com/larsbrinkhoff/emacs-history">历史版本</a> 的代码拿来抄 (bushi),
  可以大概地了解一些基本的设计思路.</p>
<p>那么还是先搞清楚我想要啥: 一个类似 Emacs 一样 “可以拓展” 的编辑器.</p>
<p>为了可以 <b>拓展</b>, 所以我需要:</p>
<ul>
  <li>很好的文档 (self-documentation)
    <ul>
      <li>每个函数 (尽量) 都需要有: 类型标注 (core and lowlevel), 文档</li>
      <li>代码中需要有注释来标注设计思路</li>
    </ul>
  </li>
  <li>接口设计 (protocol)
    <ul>
      <li>buffer 我需要借鉴 <a href="https://github.com/robert-strandh/Cluffer/">Cluffer</a></li>
      <li>frontend 我需要借鉴 Lem, 将前后端分离,
        但是最好需要将对 buffer 的操作可以视为类似 Emacs 的单线程策略,
        即对于单个 buffer 的一系列操作应当可以被视为一个 queue 队列.
        <p>因为在写 lem 的终端模拟的时候被坑到了, update 的 thread 会让整个编辑器崩掉,
          感觉有点不太合理了.</p>
      </li>
      <li>API 需要尽可能和 Emacs 相同
        (如果能折腾出一套兼容层就好了, 虽然感觉不太现实)</li>
    </ul>
  </li>
  <li>尽可能的代码复用,
    Lem 中频繁的建新包的缺点我觉得就是让代码复用变得比较痛苦
    (也有可能是有一些我不知道的小巧思)</li>
  <li>争取之后可以自举 (自己编辑自己吧)</li>
</ul>
<p>那么这篇文章是阅读 Cluffer 的会议论文: A CLOS Protocol for Editor Buffers
  的一个阅读笔记, 希望能够帮助我更好地抄他的代码 (bushi).</p>
<h1>A CLOS Protocol for Editor Buffers</h1>
<h2>Two Control Loops</h2>
<ul>
  <li><b>innermost loop</b>:
    <ul>
      <li>insert, delete items in buffer</li>
      <li>cursor movement</li>
    </ul>
  </li>
  <li><b>outer loop</b>:
    <ul>
      <li>updating the views of the buffer</li>
      <li>incremental paring
        <p>cite: Incremental Parsing of Common Lisp Code</p>
        <p>这个之后再慢慢看</p>
      </li>
    </ul>
  </li>
</ul>
<h2>Representing items in a buffer</h2>
<p>主要是知道有哪些, 具体的实现详见下文</p>
<ul>
  <li>Line oriented
    <p>将 buffer 看作是 list of vector line.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defclass</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">((</span><span class="nf">buff</span><span class="w"> </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:buff</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">make-line</span><span class="w"> </span><span class="p">(</span><span class="nf">str</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nb">string</span><span class="w"> </span><span class="nv">str</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">make-instance</span><span class="w"> </span><span class="ss">&#39;line</span><span class="w"> </span><span class="nv">:buff</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce</span><span class="w"> </span><span class="nv">str</span><span class="w"> </span><span class="ss">&#39;simple-vector</span><span class="p">)))</span>

<span class="c1">;; lines should be a list of line</span>
<span class="p">(</span><span class="nf">defclass</span><span class="w"> </span><span class="nv">buff</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">((</span><span class="nf">lines</span><span class="w"> </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:lines</span><span class="w"> </span><span class="nv">:initform</span><span class="w"> </span><span class="p">())))</span>
</pre></div>
    <p>也有用 ring of vector line 来做储存的 (方便从尾回到头之类的跳转),
      或者 double linked list (方便上下滚动).</p>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Gap_buffer">Gap buffer</a>
    <p>一种特殊的 vector line 可以如下实现 (<a href="https://en.wikipedia.org/wiki/Dynamic_array">dynamic array</a>):
      把 vector 后面用空空间进行填充, 这样可以方便插入和修改.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">make-line</span><span class="w"> </span><span class="p">(</span><span class="nf">str</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nb">string</span><span class="w"> </span><span class="nv">str</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">len</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="p">(</span><span class="nb">ceiling</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">str</span><span class="p">)</span><span class="w"> </span><span class="nv">+line-size+</span><span class="p">)</span><span class="w"> </span><span class="nv">+line-size+</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce</span><span class="w"> </span><span class="p">(</span><span class="nb">make-array</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="nv">:element-type</span><span class="w"> </span><span class="ss">&#39;character</span><span class="p">)</span>
<span class="w">                      </span><span class="ss">&#39;simple-vector</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">dotimes</span><span class="w"> </span><span class="p">(</span><span class="nf">i</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">svref</span><span class="w"> </span><span class="nv">arr</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">str</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">make-instance</span><span class="w"> </span><span class="ss">&#39;line</span><span class="w"> </span><span class="nv">:buff</span><span class="w"> </span><span class="nv">arr</span><span class="p">)))</span>
</pre></div>
    <p>这样的 vector line 可以看作是一种特殊的 gap buffer (gap 全在后面).
      一般是 gap 在 pointer 的附近 (方便插入).</p>
    <p>不过有意思的是看到了一个叫做 <a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)">Zipper</a> 的数据抽象 (gap buffer),
      估计可以仔细看看.</p>
    <p>cite: <a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">The Zipper</a></p>
  </li>
</ul>
<p>下面是一些论文里面并没有介绍的内容:</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">Rope</a>
    <p>一个二叉树来储存 vector piece.</p>
    <p>cite: <a href="https://www.cs.tufts.edu/comp/150FP/archive/hans-boehm/ropes.pdf">Ropes: an Alternative to Strings</a></p>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Piece_table">Piece Table</a>
    <p>原 buffer 视为 immutable 的 buffer, 修改储存在 piece table 中.</p>
    <p>不过好像缺少很多的说明, 估计只能抄抄别人的代码实现了.</p>
  </li>
  <li>&#8230;</li>
</ul>
<h2>Protocol</h2>
<p>下面这种基本就看代码了, 不一定全, 并且代码里面也没有文档, 难受.</p>
<h3>Inner Protocol</h3>
<p>几个概念:</p>
<ul>
  <li><code>buffer</code>: 嗯, 就叫 buffer (<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Buffers.html">Buffers, Emacs Manual</a>)</li>
  <li><code>line</code>: 行抽象</li>
  <li><code>cursor</code>: 当前编辑的位置</li>
  <li><code>dock</code>: 将 <code>line</code> 和 <code>buffer</code> 连接在一起</li>
</ul>
<h3>Outter Protocol</h3>
<ul>
  <li>Update
    <ul>
      <li><code>(update buffer time sync skip modify create)</code></li>
    </ul>
  </li>
  <li>Edit
    <p>从用户的角度来看, 一个 <code>buffer</code> 由一堆 <code>line</code> 组成,
      一个 <code>line</code> 由一堆 <code>item</code> 组成, <code>cursor</code> 在 <code>line</code> 上编辑.
      这里的 <code>item</code> 算是一个对字符, 图像之类的任意的玩意的一个抽象.</p>
    <p>一些我觉得比较 misc 的设计</p>
    <ul>
      <li><code>(line-count buffer)</code>
        <p>返回 <code>buffer</code> 中的行数</p>
      </li>
      <li><code>(item-count entity)</code>
        <p>计数 <code>entity</code> (<code>buffer</code>, <code>line</code>, <code>cursor</code>) 中的元素</p>
      </li>
      <li><code>(line-number entity)</code>
        <p>得到 <code>entity</code> (<code>line</code>, <code>item</code>, <code>cursor</code>) 所在的行</p>
      </li>
      <li><code>(join-line entity)</code>
        <p>合并行 (感觉这个不知道为啥设计)</p>
      </li>
      <li><code>(items entity &amp;key start end)</code>
        <p>以 <code>vector</code> 的形式返回区域内的内容</p>
      </li>
      <li><code>(buffer entity)</code>
        <p>返回 <code>entity</code> 对应的 <code>buffer</code></p>
      </li>
    </ul>
    <p>在 <code>line</code> 上提供了一些这样的 protocol:</p>
    <ul>
      <li>Position
        <ul>
          <li><code>(first-line-p line)</code></li>
          <li><code>(last-line-p line)</code></li>
        </ul>
      </li>
      <li>Reading
        <ul>
          <li><code>(item-at-position line position)</code></li>
          <li><code>(find-line buffer line-number)</code></li>
        </ul>
      </li>
      <li>Writing
        <ul>
          <li><code>(insert-item-at-position line item position)</code></li>
          <li><code>(delete-item-at-position line position)</code></li>
          <li><code>(split-line-at-position line position)</code></li>
        </ul>
      </li>
    </ul>
    <p><code>cursor</code> 有如下的抽象:</p>
    <ul>
      <li>Position
        <p><code>cursor</code> 应当附在 <code>line</code> 上,
          若没有附在 <code>line</code> 上的 <code>cursor</code> 被执行读写或者其他操作的时候,
          就应当抛出 <code>cursor-detached</code> 信号.</p>
        <ul>
          <li><code>(cursor-attached-p cursor)</code></li>
          <li><code>(attach-cursor cursor line &amp;optional position)</code></li>
          <li><code>(detach-cursor cursor)</code></li>
        </ul>
        <p>位置的判定:</p>
        <ul>
          <li><code>(cursor-position cursor)</code></li>
          <li><code>(beginning-of-line-p cursor)</code></li>
          <li><code>(end-of-line-p cursor)</code></li>
          <li><code>(line cursor)</code></li>
          <li><code>(cursor=/2 cursor1 cursor2)</code></li>
          <li><code>(cursor&lt;/2 cursor1 cursor2)</code></li>
          <li><code>(cursor/= cursor &amp;rest more-cursors)</code></li>
        </ul>
      </li>
      <li>Moving
        <ul>
          <li><code>(beginning-of-line cursor)</code></li>
          <li><code>(end-of-line cursor)</code></li>
          <li><code>(forward-item cursor)</code></li>
          <li><code>(backward-item cursor)</code></li>
        </ul>
      </li>
      <li>Reading
        <ul>
          <li><code>(item-before-cursor cursor)</code></li>
          <li><code>(item-after-cursor cursor)</code></li>
        </ul>
      </li>
      <li>Writing
        <ul>
          <li><code>(insert-item cursor item)</code></li>
          <li><code>(delete-item cursor)</code></li>
          <li><code>(erase-item cursor)</code></li>
          <li><code>(split-line cursor)</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2>Supplied implementations</h2>
<p>具体的实现不太重要, 这里会只挑 Cluffer 中的标准实现,</p>
<h3>Line</h3>
<ul>
  <li>区分 <code>open-line</code> 和 <code>closed-line</code>
    <ul>
      <li><code>open-line</code> 使用 gap buffer 来保证可编辑</li>
      <li><code>closed-line</code> 即为一个 <code>(simple-vector item)</code></li>
      <li>通过 <code>close-line</code> 和 <code>open-line</code> 函数来相互转换</li>
    </ul>
  </li>
</ul>
<h3>Buffer</h3>
<h1>The Zipper</h1>
<h2>TLDR*</h2>
<blockquote>
  <p>the tree is turned inside-out like a returned glove, pointers from the
    root to the current position being reversed in a path structure. The
    current location holds both the downward current subtree and the
    upward path. All navigation and modification primitives operate on the
    location structure. Going up and down in the structure is analogous to
    closing and opening a zipper in a piece of clothing, whence the name.</p>
</blockquote>
<p>可以参考 <a href="https://www.slideshare.net/slideshow/zippers-presentation/28611495">Zippers presentation</a> 这个 Slide 里面的一个演示:</p>
<p>假如有一个 <code>list</code>:</p>
<pre class="example">
(1 2 3 4 5 6 7 8 9 10)
</pre>
<blockquote>
  <p>Zipper is a functional cursor into a data structure.</p>
</blockquote>
<p>即, 当 <code>cursor</code> 在 <code>list</code> 上进行移动的时候:</p>
<div class="highlight"><pre><span></span>1 (2 3 4 5 6 7 8 9 10)    ;; 0
^

(1) 2 (3 4 5 6 7 8 9 10)  ;; 1
    ^

(2 1) 3 (4 5 6 7 8 9 10)  ;; 2
      ^

(3 2 1) 4 (5 6 7 8 9 10)  ;; 3
        ^
</pre></div>
<p>就像是在拉拉链一样进行滑动, 同时在 <code>cursor</code> 处插入和删除的效率是 <code>O(1)</code>.</p>
<p>妙啊, 相当于是一个 gap 无限大的 gap buffer.</p>
<p>(吐槽: 喵的函数式那帮人写代码都跟写数学公式一样,
  简直就是在用一堆不严谨 (indeterminate) 的鬼画符 (数学),
  去描述一个严谨的 (determinate) 的东西&#8230;</p>
<h2>A Trivial Implementation</h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defpackage</span><span class="w"> </span><span class="kd">#:trivial-zipper</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:use</span><span class="w"> </span><span class="nv">:cl</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:export</span>
<span class="w">   </span><span class="kd">#:zipper</span><span class="p">))</span>

<span class="p">(</span><span class="nf">in-package</span><span class="w"> </span><span class="nv">:trivial-zipper</span><span class="p">)</span>
</pre></div>
<h3><code>zipper</code> structure</h3>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defstruct</span><span class="w"> </span><span class="nv">zipper</span>
<span class="w">  </span><span class="s">&quot;The trivial Zipper implementation. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nb">unfold</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="nb">list</span><span class="p">)</span>
<span class="w">  </span><span class="nv">cursor</span>
<span class="w">  </span><span class="p">(</span><span class="nf">folded</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="nb">list</span><span class="p">))</span>
</pre></div>
<p>如上文所说, 将 <code>zipper</code> 的数据结构分为 <code>unfold</code>, <code>cursor</code>, <code>folded</code> 三个部分:</p>
<pre class="example">
(3 2 1)   4     (5 6 7 8 9 10)
unfold  cursor      folded
</pre>
<h3>Allocation and Reading</h3>
<h4><code>(zipper&lt;- sequence)</code> \(&rarr;\) turn <code>sequence</code> to <code>zipper</code></h4>
<p>将 <code>sequence</code> 转换为 <code>zipper</code> 数据结构</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defgeneric</span><span class="w"> </span><span class="nv">zipper&lt;-</span><span class="w"> </span><span class="p">(</span><span class="nf">sequence</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:documentation</span><span class="w"> </span><span class="s">&quot;Turn SEQUENCE to `zipper&#39; structure. &quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="p">((</span><span class="nf">seq</span><span class="w"> </span><span class="nv">sequence</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">seq</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;~A is empty. &quot;</span><span class="w"> </span><span class="nv">seq</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce</span><span class="w"> </span><span class="nv">seq</span><span class="w"> </span><span class="ss">&#39;list</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">make-zipper</span><span class="w"> </span><span class="nv">:folded</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nb">list</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">:cursor</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nb">list</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">:unfold</span><span class="w"> </span><span class="p">()))))</span>
</pre></div>
<h4><code>(print-object zipper stream)</code></h4>
<p>这里用类似 <code>#&lt;unfold cursor folded&gt;</code> 的形式来显示 <code>zipper</code> 数据结构:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defmethod</span><span class="w"> </span><span class="nv">print-object</span><span class="w"> </span><span class="p">((</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="nv">stream</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">print-unreadable-object</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">stream</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">stream</span><span class="w"> </span><span class="s">&quot;~A ~A ~A&quot;</span>
<span class="w">            </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nf">zipper-cursor</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))))</span>
</pre></div>
<p>例:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">zipper&lt;-</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
</pre></div>
<pre class="example">
#&lt;nil H (e l l o   W o r l d)&gt;
</pre>
<h4><code>(zipper-length zipper)</code> \(&rarr;\) length of zipper data</h4>
<p>类似于 <code>length</code> 的一个简单函数:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">zipper-length</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Return ZIPPER length. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">the</span><span class="w"> </span><span class="nv">unsigned-byte</span>
<span class="w">       </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">          </span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
<h4><code>(string&lt;-zipper zipper)</code> \(&rarr;\) turn <code>zipper</code> as <code>string</code></h4>
<p>类似于 <code>print-object</code>, 但是以更加常见的形式去输出这个 <code>zipper</code> 元素:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">string&lt;-zipper</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Return ZIPPER as string. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nb">concatenate</span><span class="w"> </span><span class="ss">&#39;string</span>
<span class="w">               </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-cursor</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
</pre></div>
<p>注: 如果 <code>zipper</code> 中的 <code>element</code> 并非 <code>character</code>,
  我觉得可以做一个简单的预处理之类的.
  这样可以支持更多的 <code>item</code> 类型.</p>
<h4><code>(zipper-cursor-position zipper)</code> \(&rarr;\) return cursor position</h4>
<p>当前 <code>cursor</code> 的位置</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">zipper-cursor-position</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Return ZIPPER cursor position. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
</pre></div>
<h3>Transforming</h3>
<p>这里使用 <code>zipper-forward</code>, <code>zipper-backward</code> 来进行滑移:</p>
<h4><code>(zipper-forward zipper)</code></h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">zipper-forward</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Move ZIPPER cursor forward.</span>
<span class="s">Return t if success, nil otherwise.</span>

<span class="s">Side Effect:</span>
<span class="s">ZIPPER cursor position would be moved. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">the</span><span class="w"> </span><span class="nv">boolean</span>
<span class="w">       </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">(</span><span class="nf">prev</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">shiftf</span><span class="w"> </span><span class="nv">prev</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-cursor</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="nv">prev</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">           </span><span class="nv">t</span><span class="p">))))</span>
</pre></div>
<h4><code>(zipper-backward zipper)</code></h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">zipper-backward</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Move ZIPPER cursor backward.</span>
<span class="s">Return t if success, nil otherwise.</span>

<span class="s">Side Effect:</span>
<span class="s">ZIPPER cursor position would be moved. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">the</span><span class="w"> </span><span class="nv">boolean</span>
<span class="w">       </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">(</span><span class="nf">next</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">shiftf</span><span class="w"> </span><span class="nv">next</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-cursor</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
<span class="w">           </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="nv">next</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">))</span>
<span class="w">           </span><span class="nv">t</span><span class="p">))))</span>
</pre></div>
<h4><code>(zipper-move-cursor zipper position)</code></h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">zipper-cursor-move</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">position</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Move ZIPPER cursor to POSITION.</span>
<span class="s">Return t if moved successfully, nil otherwise. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">unsigned-byte</span><span class="w"> </span><span class="nv">position</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">pos</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-cursor-position</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">position</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:repeat</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">position</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span>
<span class="w">                 </span><span class="nv">:unless</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-forward</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">:return</span><span class="w"> </span><span class="nv">nil</span>
<span class="w">                 </span><span class="nv">:finally</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="nv">t</span><span class="p">)))</span>
<span class="w">          </span><span class="p">((</span><span class="nb">&gt;</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">position</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:repeat</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">position</span><span class="p">)</span>
<span class="w">                 </span><span class="nv">:unless</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-backward</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">                   </span><span class="nv">:return</span><span class="w"> </span><span class="nv">nil</span>
<span class="w">                 </span><span class="nv">:finally</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="nv">t</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">t</span><span class="w"> </span><span class="nv">t</span><span class="p">))))</span>
</pre></div>
<h3>Writing</h3>
<h4><code>(zipper-insert zipper elem)</code></h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defgeneric</span><span class="w"> </span><span class="nv">zipper-insert</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">elem</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:documentation</span>
<span class="w">   </span><span class="s">&quot;Insert ELEM before ZIPPER cursor.</span>
<span class="s">Return ZIPPER. &quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="nv">:around</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">elem</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">call-next-method</span><span class="p">)</span>
<span class="w">    </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="p">((</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">char</span><span class="w"> </span><span class="nv">character</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="p">((</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">seq</span><span class="w"> </span><span class="nv">sequence</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">elem</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-unfold</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span><span class="w"> </span><span class="nv">seq</span><span class="p">)))</span>
</pre></div>
<h4><code>(zipper-insert-after zipper elem)</code></h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defgeneric</span><span class="w"> </span><span class="nv">zipper-insert-after</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">elem</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:documentation</span>
<span class="w">   </span><span class="s">&quot;Insert ELEM after ZIPPER cursor.</span>
<span class="s">Return ZIPPER itself. &quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="nv">:around</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">elem</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">call-next-method</span><span class="p">)</span>
<span class="w">    </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="p">((</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">char</span><span class="w"> </span><span class="nv">character</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="p">((</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">seq</span><span class="w"> </span><span class="nv">sequence</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">concatenate</span><span class="w"> </span><span class="ss">&#39;list</span><span class="w"> </span><span class="nv">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))))</span>
</pre></div>
<h4><code>(zipper-delete zipper &amp;optional repeat)</code></h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defgeneric</span><span class="w"> </span><span class="nv">zipper-delete</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="nv">repeat</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:documentation</span>
<span class="w">   </span><span class="s">&quot;Delete ZIPPER element at cursor REPEAT times.</span>
<span class="s">Return t if success, nil otherwise. &quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="nv">:around</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">repeat</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">unsigned-byte</span><span class="w"> </span><span class="nv">repeat</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">:repeat</span><span class="w"> </span><span class="nv">repeat</span>
<span class="w">          </span><span class="nv">:unless</span><span class="w"> </span><span class="p">(</span><span class="nf">call-next-method</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">            </span><span class="nv">:return</span><span class="w"> </span><span class="nv">nil</span>
<span class="w">          </span><span class="nv">:finally</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="nv">t</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:method</span><span class="w"> </span><span class="p">((</span><span class="nf">zipper</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="nv">repeat</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">repeat</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">shiftf</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-cursor</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">pop</span><span class="w"> </span><span class="p">(</span><span class="nf">zipper-folded</span><span class="w"> </span><span class="nv">zipper</span><span class="p">)))</span>
<span class="w">      </span><span class="nv">t</span><span class="p">)))</span>
</pre></div>
<h4>&#8230;</h4>
<h3>Ending</h3>
<p>其实基本上已经实现了大部分的增删查改了? 也许吧.
  假如不实现嵌套的 (nested) 数据结构的话, 感觉其实非常好实现,
  完全可以作为编程入门课来教学的感觉.</p>
<p>(C 那一套还是害人不浅啊&#8230; )</p>
<p>当然, 你也可以说, 那么代价呢? 用 <code>list</code> 作为数据结构必然要付出相比
  <code>array</code> 这样可以随机寻址的数据结构更多的代价. 这只能说算是一种取舍了吧?</p>]]></content><author><name></name></author><category term="lisp" /><summary type="html"><![CDATA[About 虽然前一篇还是 Lem 这样的新生编辑器, 这篇就又回到了想如何去自己来写一个. 那么具体是为什么呢? 一个是我在魔改 Lem 的代码的时候发现, 作者真的好喜欢分包&#8230; (感觉是一个文件分一个包 defpackage) 这样不是很喜欢, 并且做了太多的抽象导致一个 terminal-input 包装了三层. 虽然维护上来说是好了一些, 但是感觉还是不太习惯. 以及虽然去模仿了 Emacs 的一些设计, 但是自己做了好多 “小巧思”, 虽然说不上坏, 但是我用下来还是有点不太习惯 (已经成为 Emacs 的形状哩). 不过最破防的还是没啥文档, 毕竟感觉 Emacs 里面的 C-h f, C-h v 这些小文档才是一个 “可以编辑” 的编辑器的核心竞争力. Lem 的缺点 (目前来看) 主要就是缺少文档, 想要魔改的话比较费劲. 以及 (Emacs 也有), 缺少一个代码设计的说明, 改底层感觉很难. 不过好处是我可以把 Emacs 的 历史版本 的代码拿来抄 (bushi), 可以大概地了解一些基本的设计思路. 那么还是先搞清楚我想要啥: 一个类似 Emacs 一样 “可以拓展” 的编辑器. 为了可以 拓展, 所以我需要: 很好的文档 (self-documentation) 每个函数 (尽量) 都需要有: 类型标注 (core and lowlevel), 文档 代码中需要有注释来标注设计思路 接口设计 (protocol) buffer 我需要借鉴 Cluffer frontend 我需要借鉴 Lem, 将前后端分离, 但是最好需要将对 buffer 的操作可以视为类似 Emacs 的单线程策略, 即对于单个 buffer 的一系列操作应当可以被视为一个 queue 队列. 因为在写 lem 的终端模拟的时候被坑到了, update 的 thread 会让整个编辑器崩掉, 感觉有点不太合理了. API 需要尽可能和 Emacs 相同 (如果能折腾出一套兼容层就好了, 虽然感觉不太现实) 尽可能的代码复用, Lem 中频繁的建新包的缺点我觉得就是让代码复用变得比较痛苦 (也有可能是有一些我不知道的小巧思) 争取之后可以自举 (自己编辑自己吧) 那么这篇文章是阅读 Cluffer 的会议论文: A CLOS Protocol for Editor Buffers 的一个阅读笔记, 希望能够帮助我更好地抄他的代码 (bushi). A CLOS Protocol for Editor Buffers Two Control Loops innermost loop: insert, delete items in buffer cursor movement outer loop: updating the views of the buffer incremental paring cite: Incremental Parsing of Common Lisp Code 这个之后再慢慢看 Representing items in a buffer 主要是知道有哪些, 具体的实现详见下文 Line oriented 将 buffer 看作是 list of vector line. (defclass line () ((buff :initarg :buff))) (defun make-line (str) (declare (type string str)) (make-instance &#39;line :buff (coerce str &#39;simple-vector)))]]></summary></entry><entry><title type="html">Lem First Experience</title><link href="/lem/lem-0/" rel="alternate" type="text/html" title="Lem First Experience" /><published>2025-08-02T08:04:00+00:00</published><updated>2025-08-02T08:04:00+00:00</updated><id>/lem/lem-0</id><content type="html" xml:base="/lem/lem-0/"><![CDATA[<h1 id="about">About</h1>
<p><a href="https://github.com/lem-project/lem">Lem</a> 
是一个用 Common Lisp 写的模仿 Emacs 的一个编辑器. 
不过目前体验上来说和 Emacs 只能说不太能比, 有许多奇奇妙妙的小 bug (特性?) 
以及一些比较遗憾功能缺失 (比如我现在觉得 <code class="language-plaintext highlighter-rouge">directory-mode</code> 和 Emacs 的 
<code class="language-plaintext highlighter-rouge">dired</code> 完全不能比, 详见 <a href="#一些吐槽">一些吐槽</a>).</p>

<p>不过作为一个用来玩乐的编辑器, 我觉得是挺不错的.</p>

<h1 id="clone-compile-patch-compile-right">Clone, Compile, Patch, Compile… Right?</h1>
<h2 id="clone-and-compile">Clone and Compile</h2>
<p>我不是很喜欢 <a href="https://github.com/fukamachi">fukamachi</a> qlot 那套依赖包管理的做法. 
虽然现在觉得在本地保存所有的项目相关的包确实是一个超级明智的决定 
(尤其是在未来有了一堆的包依赖的时候, 你说是吧 Python, NPM). 
But anyway, 我更喜欢直接用 <a href="https://www.quicklisp.org/">quicklisp</a> 
直接把所有的依赖都装在一起. 这是个人的喜好差异了, 
假如你想要用官方推荐的方式来进行安装的话, 
请参考 <a href="https://lem-project.github.io/installation/ncurses/linux/">Installation (Lem)</a> 
的官方安装指南.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="nv">$HOME</span> <span class="o">&amp;&amp;</span> <span class="nb">mkdir</span> <span class="nt">-pv</span> common-lisp
<span class="nb">cd </span>common-lisp
git clone https://github.com/lem-project/lem.git
</code></pre></div></div>

<p>说明: <code class="language-plaintext highlighter-rouge">~/common-lisp</code> 是一个 lisp 构建系统 (<a href="https://asdf.common-lisp.dev/">ASDF</a>) 
会搜索的地方, 将你的源代码目录置于其下方可以让其知道要如何载入. 
而 quicklisp 的工作是根据在 <code class="language-plaintext highlighter-rouge">asdf</code> 中定义的依赖关系, 帮你从网上把源代码下载下来, 
并放到一个 asdf 知道如何载入的地方.</p>

<details><summary>等下, 假如你没有 Common Lisp 和 quicklisp 环境配置的话...</summary>
1. 安装 SBCL 环境
   + macOS: `brew install sbcl`
   + Ubuntu: `sudo apt install sbcl`
   + Windows: 不熟
2. 下载并配置 quicklisp
   + `curl -L https://beta.quicklisp.org/quicklisp.lisp -o quicklisp.lisp`
   + `sbcl --load quicklisp.lisp --eval "(quicklisp-quickstart:install)" --eval "(ql:add-to-init-file)" --eval "(quit)"`

详见 [Getting started with Common Lisp](https://lispcookbook.github.io/cl-cookbook/getting-started.html). 
</details>

<p>进入到 <code class="language-plaintext highlighter-rouge">lem</code> 项目目录下方, 这里并不使用 Lem 默认的 <code class="language-plaintext highlighter-rouge">Makefile</code> 进行编辑, 而是采用:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>lem
sbcl <span class="nt">--dynamic-space-size</span> 4GiB <span class="nt">--noinform</span> <span class="nt">--nosysinit</span> <span class="se">\</span>
     <span class="nt">--eval</span> <span class="s2">"(ql:quickload :lem-sdl2)"</span> <span class="se">\</span>
     <span class="nt">--eval</span> <span class="s2">"(lem:init-at-build-time)"</span> <span class="se">\</span>
     <span class="nt">--eval</span> <span class="s2">"(sb-ext:save-lisp-and-die </span><span class="se">\"</span><span class="s2">lem</span><span class="se">\"</span><span class="s2"> </span><span class="se">\</span><span class="s2">
                                       :compression t </span><span class="se">\</span><span class="s2">
                                       :toplevel #'lem:main </span><span class="se">\</span><span class="s2">
                                       :executable t </span><span class="se">\</span><span class="s2">
                                       :save-runtime-options t)"</span>
</code></pre></div></div>

<p>手动进行编译.</p>

<p>注: 这里 <code class="language-plaintext highlighter-rouge">:compression</code> 参数设置成了 <code class="language-plaintext highlighter-rouge">t</code>, 可以大幅减少最终二进制文件的大小;
<code class="language-plaintext highlighter-rouge">:save-runtime-options</code> 让 Lem 使用和编译其时相同的运行时参数 
(<code class="language-plaintext highlighter-rouge">--dynamic-space-size 4GiB</code>).</p>

<p>运行 <code class="language-plaintext highlighter-rouge">./lem</code> 即可看到用 SDL2 作为前端显示的 Lem 编辑器了.</p>

<h2 id="来点配置">来点配置</h2>
<p>和 Emacs 的配置类似的, 我们把配置放在 <code class="language-plaintext highlighter-rouge">~/.lem/init.lisp</code> 处. 
在里面你可以写各种各样的 Lisp 代码, 比如可以写一些简单的按键绑定:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">in-package</span> <span class="ss">:lem</span><span class="p">)</span>

<span class="c1">;;; Key binding</span>

<span class="p">(</span><span class="nv">define-key</span> <span class="vg">*global-keymap*</span> <span class="s">"C--"</span> <span class="ss">'undo</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="vg">*global-keymap*</span> <span class="s">"S--"</span> <span class="ss">'font-size-decrease</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="vg">*global-keymap*</span> <span class="s">"S-="</span> <span class="ss">'font-size-increase</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="vg">*global-keymap*</span> <span class="s">"S-+"</span> <span class="ss">'font-size-increase</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="vg">*global-keymap*</span> <span class="s">"S-f"</span> <span class="ss">'lem/isearch:isearch-forward</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="vg">*global-keymap*</span> <span class="s">"S-v"</span> <span class="ss">'yank</span><span class="p">)</span>
<span class="p">(</span><span class="nv">define-key</span> <span class="vg">*global-keymap*</span> <span class="s">"S-c"</span> <span class="ss">'copy-region</span><span class="p">)</span>
</code></pre></div></div>

<p>注: 这里的按键绑定的命名规则同 Emacs. 会发现基本的设计都挺类似的.</p>

<p>注2: 一个小技巧, 在 lisp-mode 中, 在一个 S-expr 上按快捷键 <code class="language-plaintext highlighter-rouge">C-c C-c</code> 可以</p>

<p>注3: 发现用 ncurses 的版本配合 iTerm2 的效果其实也很不错 
(尤其是那个比较炫酷的那个光标特效, 没啥用, 但是很帅).</p>

<h2 id="来点-patch">来点 Patch</h2>
<p>现在你就可以用 Lem 来编辑 Lem 的源代码了. 通常, 
大家会认为改了代码之后我们需要重新编译代码并重启我们的程序… 
但是在 Lisp 世界中, 这并不是必要的 – 你完全可以在运行 Lem 的同时修改其功能:</p>

<p>比如 <code class="language-plaintext highlighter-rouge">M-x start-lisp-repl</code> 可以帮你打开一个 Lisp 的 REPL, 
同时这个 REPL 也是 Lem 当前控制的环境. 你可以使用 <code class="language-plaintext highlighter-rouge">M-h</code> 快捷键来唤起一个小窗口,
在其中有一堆的选项来帮助你了解当前光标下的东西是什么.</p>

<p>比如你可以用 <code class="language-plaintext highlighter-rouge">Describe symbol</code> 来查看当前函数/变量对应的符号的文档, 
或者用 <code class="language-plaintext highlighter-rouge">Find definition</code> 来查看函数的定义等等.</p>

<h1 id="一些吐槽">一些吐槽</h1>
<h2 id="性能和内存占用">性能和内存占用</h2>
<p>貌似在 SBCL 里面的内存占用还是有点大… 
开了几个 buffer 之后 sdl2 版本的内存占用来到了 800MB 左右, 
啥也不开的状态是 290MB. 作为对比的, ncurses 的版本的内存占用大概是 200MB
左右 (不过不清楚多开了几个 buffer 之后会有啥效果). 
所以我感觉还是主要使用 ncurses 的版本会比较好一些.</p>

<p>还没有测试过比较大的文件的编辑性能. 其他需要测试一下.</p>

<p>总体上来说感觉还是挺流畅的, 不过也有一些因为不熟练导致的卡手感, 
然后 sdl2 的版本因为没有平滑滚动 (对应 Emacs 中的 <code class="language-plaintext highlighter-rouge">pixel-scrolling</code>),
感觉还是有点卡顿感.</p>

<p>并且发现用 sdl2 的版本的耗电量还挺高的…</p>

<p>不过 sdl2 的版本, 它可以支持各种图形和富媒体, 感觉还是有很多东西可以玩的.</p>

<h2 id="多窗口">多窗口</h2>
<p>还是很想要多窗口, 不过感觉不是什么大问题, 应该可以用一些别的方法来搞定.</p>

<p>不过奇怪的是 <code class="language-plaintext highlighter-rouge">server</code> 版本的 Lem (用网页作为显示前端) 也是只能支持一个窗口, 
这个就感觉有点搞了…</p>

<h2 id="org-mode">Org-Mode</h2>
<p>是的, 没有 <a href="https://orgmode.org/">Org-Mode</a>. (或者说没有很好的 Org-Mode 的支持), 
所以这个博客也是用回了 Markdown 来做标记语言.</p>

<p>我缺的 <code class="language-plaintext highlighter-rouge">C-c C-c</code> (文学编程) 这块谁来补啊…</p>

<h2 id="directory-mode">Directory-Mode</h2>
<p>感觉也不是很好用, <code class="language-plaintext highlighter-rouge">all-the-icons</code> 感觉虽然好看是好看, 
但是感觉主要还是功能上缺失了好多. 感觉可以有空去 Emacs 那里抄.</p>

<h2 id="compile">Compile</h2>
<p>也是一个最近开始常用的小功能, 感觉配置好就是一个 <code class="language-plaintext highlighter-rouge">C-c C-c</code> 的事, 
写代码快速开发感觉很舒服 – 什么才叫做代码的所见即所得啊 (bushi).</p>

<h2 id="terminal-shell">Terminal, Shell</h2>
<p>不好用就是说, 并且 vterm 貌似在 mac 这边的设置有些问题, 
这个我觉得可以用别的方式去进行, 比如 port 一个 eshell 或者 eat.</p>

<h2 id="tramp">Tramp</h2>
<p>卧槽, 我超想要这个的… 虽然 Emacs 的 Tramp 有点慢… 
但是 Tramp 感觉很爽诶.</p>

<h1 id="other">Other</h1>
<p>嘛, 没法要求一个新生的编辑器 (还是一个小众编程语言 + 没钱宣传) 
和 Emacs OS 比较, 不过感觉有很多东西可以去写.</p>

<p>已经自带的这些, 比如 lsp 或者 <code class="language-plaintext highlighter-rouge">auto-save-mode</code> 感觉还行, 
不知道之后使用的时候会遇到啥或者有啥想法, 
感觉可以之后做一些从 Emacs 那边抄代码和抄插件的一些工作.</p>]]></content><author><name></name></author><category term="lem" /><summary type="html"><![CDATA[About Lem 是一个用 Common Lisp 写的模仿 Emacs 的一个编辑器. 不过目前体验上来说和 Emacs 只能说不太能比, 有许多奇奇妙妙的小 bug (特性?) 以及一些比较遗憾功能缺失 (比如我现在觉得 directory-mode 和 Emacs 的 dired 完全不能比, 详见 一些吐槽).]]></summary></entry><entry><title type="html">Using Tree-sitter in Emacs</title><link href="/emacs/using-tree-sitter/" rel="alternate" type="text/html" title="Using Tree-sitter in Emacs" /><published>2025-06-09T00:00:00+00:00</published><updated>2025-06-09T00:00:00+00:00</updated><id>/emacs/using-tree-sitter</id><content type="html" xml:base="/emacs/using-tree-sitter/"><![CDATA[<h1>About</h1>
<p>在写 <a href="https://cffi.common-lisp.dev/manual/cffi-manual.html">CFFI</a> 的时候手动写一堆的 <code>cffi:defcfun</code> 实在是头痛,
  而使用 <a href="https://github.com/rpav/c2ffi">c2ffi</a> 却并没有那么的省心.</p>
<p>不过话又说回来了, 反正都是从 <code>*.h</code> 文件中读取函数的定义,
  然后按照一定的规则去生成代码 <code>cffi:defcfun</code>.
  一个简单的想法是写一个 parser, 然后把函数名和类型等提取,
  最后根据规则进行代码的生成 &#8211; 但是为什么不直接利用 Emacs
  的 <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> 的集成 (<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Parsing-Program-Source.html">Parsing Program Source</a>) 呢?</p>
<h1>Requirement</h1>
<p>首先需要确保 Tree-sitter 在 Emacs 中是可用的:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">treesit-available-p</span><span class="p">)</span>
</pre></div>
<pre class="example">
t
</pre>
<p>并且 C parser 已经被正确地安装了:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">treesit-install-language-grammar</span><span class="w"> </span><span class="ss">&#39;c</span><span class="p">)</span>
</pre></div>
<p>注: 在 Emacs 29 之后 Tree-sitter 就已经被内置在了 Emacs 中,
  假如你的 Emacs 版本较早, 可以参考 <a href="https://emacs-tree-sitter.github.io/">emacs-tree-sitter</a> 进行配置.</p>
<h1><code>*.h</code> \(&rarr;\) <code>*.lisp</code> via Tree-sitter</h1>
<h2>Parse <code>*.h</code></h2>
<p>假设有一个 <code>foo.h</code> 头文件被打开了 (其 buffer 名称为 <code>foo.h</code>),
  创建一个 Tree-sitter 的 parser:</p>
<details><summary>foo.h</summary>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stdio.h&quot;</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print_help_and_exit</span><span class="p">();</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">some_funcions</span><span class="p">(</span><span class="n">bar</span><span class="w"> </span><span class="o">*</span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</details>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defvar</span><span class="w"> </span><span class="nv">parser</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-parser-create</span><span class="w"> </span><span class="ss">&#39;c</span><span class="w"> </span><span class="p">(</span><span class="nf">get-buffer</span><span class="w"> </span><span class="s">&quot;foo.h&quot;</span><span class="p">)))</span>
</pre></div>
<p>注: 更多请参考 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Using-Parser.html">Using Tree-sitter Parser</a>.</p>
<h2>Extract infomation from Tree</h2>
<p>这里差不多用到了 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Retrieving-Nodes.html">Retrieving Nodes</a> 和 <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Accessing-Node-Information.html">Accessing Node Information</a>
  这两个文档中说明的特性.</p>
<p>使用 <code>treesit-node-children</code> 可以很方便地实现一个 <code>node</code> 的历遍:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">treesit-node-sexp</span><span class="w"> </span><span class="p">(</span><span class="nf">node</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Turn Tree-sitter NODE as S-expression. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">children</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-children</span><span class="w"> </span><span class="nv">node</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">null</span><span class="w"> </span><span class="nv">children</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-type</span><span class="w"> </span><span class="nv">node</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nf">substring-no-properties</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-text</span><span class="w"> </span><span class="nv">node</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-type</span><span class="w"> </span><span class="nv">node</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;treesit-node-sexp</span><span class="w"> </span><span class="nv">children</span><span class="p">)))))</span>
</pre></div>
<details><summary>其效果类似如下</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">treesit-node-sexp</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-parser-root-node</span><span class="w"> </span><span class="nv">parser</span><span class="p">))</span>
</pre></div>
<pre class="example">
(&quot;translation_unit&quot;
 (&quot;preproc_include&quot; (&quot;#include&quot; &quot;#include&quot;)
  (&quot;string_literal&quot; (&quot;\&quot;&quot; &quot;\&quot;&quot;) (&quot;string_content&quot; &quot;stdio.h&quot;)
   (&quot;\&quot;&quot; &quot;\&quot;&quot;)))
 (&quot;type_definition&quot; (&quot;typedef&quot; &quot;typedef&quot;) (&quot;primitive_type&quot; &quot;int&quot;)
  (&quot;type_identifier&quot; &quot;bar&quot;) (&quot;;&quot; &quot;;&quot;))
 (&quot;declaration&quot; (&quot;primitive_type&quot; &quot;void&quot;)
  (&quot;function_declarator&quot; (&quot;identifier&quot; &quot;print_help_and_exit&quot;)
   (&quot;parameter_list&quot; (&quot;(&quot; &quot;(&quot;) (&quot;)&quot; &quot;)&quot;)))
  (&quot;;&quot; &quot;;&quot;))
 (&quot;declaration&quot; (&quot;primitive_type&quot; &quot;int&quot;)
  (&quot;pointer_declarator&quot; (&quot;*&quot; &quot;*&quot;)
   (&quot;function_declarator&quot; (&quot;identifier&quot; &quot;some_funcions&quot;)
    (&quot;parameter_list&quot; (&quot;(&quot; &quot;(&quot;)
     (&quot;parameter_declaration&quot; (&quot;type_identifier&quot; &quot;bar&quot;)
      (&quot;pointer_declarator&quot; (&quot;*&quot; &quot;*&quot;) (&quot;identifier&quot; &quot;foo&quot;)))
     (&quot;,&quot; &quot;,&quot;)
     (&quot;parameter_declaration&quot;
      (&quot;storage_class_specifier&quot; (&quot;static&quot; &quot;static&quot;))
      (&quot;type_qualifier&quot; (&quot;const&quot; &quot;const&quot;)) (&quot;primitive_type&quot; &quot;int&quot;)
      (&quot;identifier&quot; &quot;num&quot;))
     (&quot;)&quot; &quot;)&quot;))))
  (&quot;;&quot; &quot;;&quot;)))
</pre>
</details>
<p>不过其实也可以在 Buffer 中使用 <code>treesit-explore-mode</code> 来进行预览.</p>
<details><summary>效果如下</summary>
<pre class="example">
(translation_unit
 (preproc_include #include
  path: (string_literal &quot; (string_content) &quot;))
 (declaration type: (primitive_type)
  declarator:
   (function_declarator declarator: (identifier)
    parameters: (parameter_list ( )))
  ;)
 (declaration type: (primitive_type)
  declarator:
   (function_declarator declarator: (identifier)
    parameters:
     (parameter_list (
      (parameter_declaration type: (primitive_type)
       declarator: (pointer_declarator * declarator: (identifier)))
      )))
  ;))
</pre>
</details>
<p>但是不经过筛选的 node 的处理有点麻烦, 虽然在前面的历遍函数上面添加一些判断,
  也能够让结果比较好用. 但是考虑到为啥不直接用现成的 <code>treesit-query-capture</code> 呢?</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">query</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">func</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">query</span><span class="p">)))</span>
<span class="w">            </span><span class="p">(</span><span class="nf">substring-no-properties</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-text</span><span class="w"> </span><span class="nv">func</span><span class="p">))))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">treesit-query-capture</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-parser-root-node</span><span class="w"> </span><span class="nv">parser</span><span class="p">)</span>
<span class="w">                               </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">declaration</span><span class="p">)</span><span class="w"> </span><span class="nv">@declaration</span><span class="p">)))</span>
</pre></div>
<pre class="example">
(&quot;void print_help_and_exit();&quot; &quot;int some_funcions(bar *foo);&quot;)
</pre>
<p>现在你已经学会了从最简单的 tree 中提取节点了, 那么使用更加复杂一些的规则:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">treesit-query-capture</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-parser-root-node</span><span class="w"> </span><span class="nv">parser</span><span class="p">)</span>
<span class="w">                       </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">declaration</span>
<span class="w">                          </span><span class="nv">declarator:</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">declarator:</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="p">)))</span>
<span class="w">                         </span><span class="nv">@declaration</span><span class="p">))</span>
</pre></div>
<pre class="example">
((declaration . #&lt;treesit-node declaration in 39-66&gt;)
 (declaration . #&lt;treesit-node declaration in 68-119&gt;))
</pre>
<details><summary>一个小小的 Tip</summary>
<p>可以使用 <code>treesit-query-validate</code> 来对 <code>query</code> 进行合法性进行判断:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">treesit-query-validate</span><span class="w"> </span><span class="ss">&#39;c</span>
<span class="w">                        </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">declaration</span>
<span class="w">                           </span><span class="nv">declarator:</span><span class="w"> </span><span class="p">(</span><span class="nf">function_declarator</span><span class="w"> </span><span class="nv">!body</span><span class="p">))</span>
<span class="w">                          </span><span class="nv">@declaration</span><span class="p">))</span>
</pre></div>
<pre class="example">
QUERY is valid
</pre>
</details>
<p>既然已经能够写出这样稍微复杂一些的 query 规则&#8230;
  于是就可以写一个简单的函数来提取一个头文件中的所有函数定义,
  即对于找到的 <code>declaration</code>, 提取其中的函数返回类型, 函数名称以及函数参数.</p>
<pre class="example">
(type function &amp;rest (type name))
</pre>
<p>这里有一个需要注意的点: 因为 Tree-sitter 会把 <code>*func</code> 变成
  <code>(pointer_declarator * declarator: (_))</code> 的形式,
  所以需要做一个简单的操作来把函数的类型 <code>type</code> 变成 <code>(:pointer type)</code> 这样的形式.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">treesit-c--ptr-type</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">declarator</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Return pointer noted TYPE and DECLARATOR. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">pointer-p</span><span class="w"> </span><span class="p">(</span><span class="nb">string=</span><span class="w"> </span><span class="s">&quot;*&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-text</span>
<span class="w">                                 </span><span class="p">(</span><span class="nf">treesit-node-child</span><span class="w"> </span><span class="nv">declarator</span><span class="w"> </span><span class="mi">0</span><span class="p">)))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">pointer-p</span>
<span class="w">        </span><span class="p">(</span><span class="nf">treesit-c--ptr-type</span>
<span class="w">         </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">:pointer</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">treesit-node-child-by-field-name</span><span class="w"> </span><span class="nv">declarator</span><span class="w"> </span><span class="s">&quot;declarator&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">declarator</span><span class="p">))))</span>
</pre></div>
<p>以及一些信息的提取:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">treesit-node-text-no-property</span><span class="w"> </span><span class="p">(</span><span class="nf">node</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">substring-no-properties</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-text</span><span class="w"> </span><span class="nv">node</span><span class="p">)))</span>
</pre></div>
<p>于是如下实现:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">lexical-let</span><span class="w"> </span><span class="p">((</span><span class="nf">func-query</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-query-compile</span>
<span class="w">                           </span><span class="ss">&#39;c</span>
<span class="w">                           </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">declaration</span>
<span class="w">                              </span><span class="nv">type:</span><span class="w">       </span><span class="p">(</span><span class="k">_</span><span class="p">)</span><span class="w">                 </span><span class="nv">@type</span>
<span class="w">                              </span><span class="nv">declarator:</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="nv">declarator:</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="p">))</span><span class="w"> </span><span class="nv">@declarator</span><span class="p">))))</span>
<span class="w">              </span><span class="p">(</span><span class="nf">para-query</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-query-compile</span><span class="w"> </span><span class="ss">&#39;c</span>
<span class="w">                                                 </span><span class="o">&#39;</span><span class="p">((</span><span class="nf">parameter_declaration</span>
<span class="w">                                                    </span><span class="nv">type:</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="p">)</span><span class="w">       </span><span class="nv">@type</span>
<span class="w">                                                    </span><span class="nv">declarator:</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="p">)</span><span class="w"> </span><span class="nv">@declarator</span><span class="p">)))))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">treesit-c--function-declarations</span><span class="w"> </span><span class="p">(</span><span class="nf">root</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">cl-loop</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">matched</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-query-capture</span><span class="w"> </span><span class="nv">root</span><span class="w"> </span><span class="nv">func-query</span><span class="p">)</span>
<span class="w">             </span><span class="nv">for</span><span class="w"> </span><span class="p">((</span><span class="k">_</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">declarator</span><span class="p">))</span><span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">matched</span><span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;cddr</span>
<span class="w">             </span><span class="nv">for</span><span class="w"> </span><span class="p">(</span><span class="nf">type*</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">declare</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-c--ptr-type</span>
<span class="w">                                      </span><span class="p">(</span><span class="nf">treesit-node-text-no-property</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">                                      </span><span class="nv">declarator</span><span class="p">)</span>
<span class="w">             </span><span class="nv">for</span><span class="w"> </span><span class="nv">name</span><span class="w">  </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-child-by-field-name</span><span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="s">&quot;declarator&quot;</span><span class="p">)</span>
<span class="w">             </span><span class="nv">for</span><span class="w"> </span><span class="nv">params</span><span class="w"> </span><span class="nb">=</span>
<span class="w">             </span><span class="p">(</span><span class="nf">cl-loop</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">p*</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-query-capture</span><span class="w"> </span><span class="nv">declare</span><span class="w"> </span><span class="nv">para-query</span><span class="p">)</span>
<span class="w">                      </span><span class="nv">for</span><span class="w"> </span><span class="p">((</span><span class="k">_</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">_</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">declarator</span><span class="p">))</span><span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">p*</span><span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;cddr</span>
<span class="w">                      </span><span class="nv">for</span><span class="w"> </span><span class="p">(</span><span class="nf">type*</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">declare</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-c--ptr-type</span>
<span class="w">                                               </span><span class="p">(</span><span class="nf">treesit-node-text-no-property</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">                                                </span><span class="nv">declarator</span><span class="p">)</span>
<span class="w">                      </span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">type*</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-node-text-no-property</span><span class="w"> </span><span class="nv">declare</span><span class="p">)))</span>
<span class="w">             </span><span class="nv">collect</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">type*</span>
<span class="w">                       </span><span class="o">,</span><span class="p">(</span><span class="nf">treesit-node-text-no-property</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">                       </span><span class="o">,@</span><span class="nv">params</span><span class="p">))))</span>
</pre></div>
<p>于是最终的效果就如下所示:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">treesit-c--function-declarations</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-parser-root-node</span><span class="w"> </span><span class="nv">parser</span><span class="p">))</span>
</pre></div>
<pre class="example">
((&quot;void&quot; &quot;print_help_and_exit&quot;)
 ((:pointer &quot;int&quot;) &quot;some_funcions&quot; ((:pointer &quot;bar&quot;) &quot;foo&quot;)
  (&quot;int&quot; &quot;num&quot;)))
</pre>
<h2>Tree to <code>cffi:defcfun</code></h2>
<p>于是就可以用这样的规则来生成 <code>cffi:defcfun</code> 的函数定义了:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">mapconcat</span>
<span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">definition</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nf">cl-destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">params</span><span class="p">)</span><span class="w"> </span><span class="nv">definition</span>
<span class="w">     </span><span class="p">(</span><span class="nf">concat</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="s">&quot;(cffi:defcfun (%s %S) %s&quot;</span>
<span class="w">                     </span><span class="p">(</span><span class="nf">string-param-case</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span><span class="w"> </span><span class="nv">name</span>
<span class="w">                     </span><span class="p">(</span><span class="nf">c-type-to-lisp-name</span><span class="w"> </span><span class="nv">type</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">params</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">string-join</span><span class="w"> </span><span class="p">(</span><span class="nf">cl-loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">var</span><span class="p">)</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">params</span>
<span class="w">                                   </span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="s">&quot;  (%s %s)&quot;</span>
<span class="w">                                                   </span><span class="p">(</span><span class="nf">string-param-case</span><span class="w">   </span><span class="nv">var</span><span class="p">)</span>
<span class="w">                                                   </span><span class="p">(</span><span class="nf">c-type-to-lisp-name</span><span class="w"> </span><span class="nv">type</span><span class="p">)))</span>
<span class="w">                          </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="w">             </span><span class="s">&quot;)&quot;</span><span class="p">)))</span>
<span class="w"> </span><span class="nv">definitions</span>
<span class="w"> </span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">print_help_and_exit</span><span class="w"> </span><span class="s">&quot;print_help_and_exit&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:void</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">some_funcions</span><span class="w"> </span><span class="s">&quot;some_funcions&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">foo</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bar</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">num</span><span class="w"> </span><span class="nv">:int</span><span class="p">))</span>
</pre></div>
<details><summary>这里用到的一些其他的函数</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defvar</span><span class="w"> </span><span class="nv">c-type-lisp-name-alist</span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;int&quot;</span><span class="w">   </span><span class="o">.</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;float&quot;</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">:float</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;void&quot;</span><span class="w">  </span><span class="o">.</span><span class="w"> </span><span class="nv">:void</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;char&quot;</span><span class="w">  </span><span class="o">.</span><span class="w"> </span><span class="nv">:char</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;size_t&quot;</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">:size</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">c-type-to-lisp-name</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">c-type-lisp-name-alist</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;string=</span><span class="p">))</span>
<span class="w">          </span><span class="nv">type</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">c-type-to-lisp-name</span><span class="w"> </span><span class="p">(</span><span class="nb">cadr</span><span class="w"> </span><span class="nv">type</span><span class="p">)))))</span>

<span class="c1">;; TODO</span>
<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">string-param-case</span><span class="w"> </span><span class="p">(</span><span class="nb">string</span><span class="p">)</span><span class="w"> </span><span class="nb">string</span><span class="p">)</span>
</pre></div>
<p>注: 这里参考 <a href="https://cffi.common-lisp.dev/manual/cffi-manual.html#Built_002dIn-Types">6.1 Built-In Types</a> 作为 <code>c-type-lisp-name-alist</code> 的定义.</p>
</details>
<p>实际上的效果还行, 如果愿意处理一下更多的边缘条件的话, 感觉可以做得更好一些.</p>
<details><summary>那么挑战一下稍微复杂一些的真实环境中的头文件的解析</summary>
<p>这里用的是苹果的 <a href="https://github.com/ml-explore/mlx-c/blob/main/mlx/c/array.h">MLX</a> (一个接下来想做的东西) 作为测试例子:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">setq</span><span class="w"> </span><span class="nv">parser</span><span class="w"> </span><span class="p">(</span><span class="nf">treesit-parser-create</span><span class="w"> </span><span class="ss">&#39;c</span><span class="w"> </span><span class="p">(</span><span class="nf">get-buffer</span><span class="w"> </span><span class="s">&quot;array.h&quot;</span><span class="p">)))</span>
</pre></div>
<p>最终的效果如下:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_dtype_size</span><span class="w"> </span><span class="s">&quot;mlx_dtype_size&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:size</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dtype</span><span class="w"> </span><span class="nv">mlx_dtype</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_tostring</span><span class="w"> </span><span class="s">&quot;mlx_array_tostring&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">str</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_string</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new</span><span class="w"> </span><span class="s">&quot;mlx_array_new&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_free</span><span class="w"> </span><span class="s">&quot;mlx_array_free&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_bool</span><span class="w"> </span><span class="s">&quot;mlx_array_new_bool&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">bool</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_int</span><span class="w"> </span><span class="s">&quot;mlx_array_new_int&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">:int</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_float32</span><span class="w"> </span><span class="s">&quot;mlx_array_new_float32&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_float</span><span class="w"> </span><span class="s">&quot;mlx_array_new_float&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_float64</span><span class="w"> </span><span class="s">&quot;mlx_array_new_float64&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">double</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_double</span><span class="w"> </span><span class="s">&quot;mlx_array_new_double&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">double</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_complex</span><span class="w"> </span><span class="s">&quot;mlx_array_new_complex&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">real_val</span><span class="w"> </span><span class="nv">:float</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">imag_val</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_new_data</span><span class="w"> </span><span class="s">&quot;mlx_array_new_data&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_array</span>
<span class="w">  </span><span class="p">(</span><span class="nf">data</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:void</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">shape</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:int</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dim</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dtype</span><span class="w"> </span><span class="nv">mlx_dtype</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set</span><span class="w"> </span><span class="s">&quot;mlx_array_set&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">src</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_bool</span><span class="w"> </span><span class="s">&quot;mlx_array_set_bool&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">bool</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_int</span><span class="w"> </span><span class="s">&quot;mlx_array_set_int&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">:int</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_float32</span><span class="w"> </span><span class="s">&quot;mlx_array_set_float32&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_float</span><span class="w"> </span><span class="s">&quot;mlx_array_set_float&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_float64</span><span class="w"> </span><span class="s">&quot;mlx_array_set_float64&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">double</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_double</span><span class="w"> </span><span class="s">&quot;mlx_array_set_double&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">val</span><span class="w"> </span><span class="nv">double</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_complex</span><span class="w"> </span><span class="s">&quot;mlx_array_set_complex&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">real_val</span><span class="w"> </span><span class="nv">:float</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">imag_val</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_set_data</span><span class="w"> </span><span class="s">&quot;mlx_array_set_data&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">data</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:void</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">shape</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:int</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dim</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dtype</span><span class="w"> </span><span class="nv">mlx_dtype</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_itemsize</span><span class="w"> </span><span class="s">&quot;mlx_array_itemsize&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:size</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_size</span><span class="w"> </span><span class="s">&quot;mlx_array_size&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:size</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_nbytes</span><span class="w"> </span><span class="s">&quot;mlx_array_nbytes&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:size</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_ndim</span><span class="w"> </span><span class="s">&quot;mlx_array_ndim&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:size</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_shape</span><span class="w"> </span><span class="s">&quot;mlx_array_shape&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_strides</span><span class="w"> </span><span class="s">&quot;mlx_array_strides&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:size</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_dim</span><span class="w"> </span><span class="s">&quot;mlx_array_dim&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dim</span><span class="w"> </span><span class="nv">:int</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_dtype</span><span class="w"> </span><span class="s">&quot;mlx_array_dtype&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">mlx_dtype</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_eval</span><span class="w"> </span><span class="s">&quot;mlx_array_eval&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_bool</span><span class="w"> </span><span class="s">&quot;mlx_array_item_bool&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bool</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_uint8</span><span class="w"> </span><span class="s">&quot;mlx_array_item_uint8&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint8_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_uint16</span><span class="w"> </span><span class="s">&quot;mlx_array_item_uint16&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint16_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_uint32</span><span class="w"> </span><span class="s">&quot;mlx_array_item_uint32&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint32_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_uint64</span><span class="w"> </span><span class="s">&quot;mlx_array_item_uint64&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint64_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_int8</span><span class="w"> </span><span class="s">&quot;mlx_array_item_int8&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int8_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_int16</span><span class="w"> </span><span class="s">&quot;mlx_array_item_int16&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int16_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_int32</span><span class="w"> </span><span class="s">&quot;mlx_array_item_int32&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int32_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_int64</span><span class="w"> </span><span class="s">&quot;mlx_array_item_int64&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int64_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_float32</span><span class="w"> </span><span class="s">&quot;mlx_array_item_float32&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_float64</span><span class="w"> </span><span class="s">&quot;mlx_array_item_float64&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">double</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_complex64</span><span class="w"> </span><span class="s">&quot;mlx_array_item_complex64&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:float</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_float16</span><span class="w"> </span><span class="s">&quot;mlx_array_item_float16&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">float16_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_item_bfloat16</span><span class="w"> </span><span class="s">&quot;mlx_array_item_bfloat16&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bfloat16_t</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_bool</span><span class="w"> </span><span class="s">&quot;mlx_array_data_bool&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bool</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_uint8</span><span class="w"> </span><span class="s">&quot;mlx_array_data_uint8&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint8_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_uint16</span><span class="w"> </span><span class="s">&quot;mlx_array_data_uint16&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint16_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_uint32</span><span class="w"> </span><span class="s">&quot;mlx_array_data_uint32&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint32_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_uint64</span><span class="w"> </span><span class="s">&quot;mlx_array_data_uint64&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">uint64_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_int8</span><span class="w"> </span><span class="s">&quot;mlx_array_data_int8&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int8_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_int16</span><span class="w"> </span><span class="s">&quot;mlx_array_data_int16&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int16_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_int32</span><span class="w"> </span><span class="s">&quot;mlx_array_data_int32&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int32_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_int64</span><span class="w"> </span><span class="s">&quot;mlx_array_data_int64&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">int64_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_float32</span><span class="w"> </span><span class="s">&quot;mlx_array_data_float32&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:float</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_float64</span><span class="w"> </span><span class="s">&quot;mlx_array_data_float64&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">double</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_complex64</span><span class="w"> </span><span class="s">&quot;mlx_array_data_complex64&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">:float</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_float16</span><span class="w"> </span><span class="s">&quot;mlx_array_data_float16&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">float16_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">mlx_array_data_bfloat16</span><span class="w"> </span><span class="s">&quot;mlx_array_data_bfloat16&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bfloat16_t</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">_mlx_array_is_available</span><span class="w"> </span><span class="s">&quot;_mlx_array_is_available&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bool</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">_mlx_array_wait</span><span class="w"> </span><span class="s">&quot;_mlx_array_wait&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">_mlx_array_is_contiguous</span><span class="w"> </span><span class="s">&quot;_mlx_array_is_contiguous&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bool</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">_mlx_array_is_row_contiguous</span><span class="w"> </span><span class="s">&quot;_mlx_array_is_row_contiguous&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bool</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cffi:defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">_mlx_array_is_col_contiguous</span><span class="w"> </span><span class="s">&quot;_mlx_array_is_col_contiguous&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span>
<span class="w">  </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">:pointer</span><span class="w"> </span><span class="nv">bool</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">arr</span><span class="w"> </span><span class="nv">mlx_array</span><span class="p">))</span>
</pre></div>
<p>感觉挺好的, 这样的话, 只需要进行一些简单的例外处理即可,
  而对应的数据类型 (比如 <code>mlx_array</code>) 可以自己做 wrapping,
  这样的话就会比 c2ffi 多一些自由度了.</p>
</details>
<h1>Ending</h1>
<p>花了一天多才写好的简单小功能, 感觉最近编程的动力极其的弱&#8230; 啥也不想干,
  这毕设真是害人啊, 坏了我的作息也磨灭了我的心情&#8230;</p>]]></content><author><name></name></author><category term="emacs" /><summary type="html"><![CDATA[About 在写 CFFI 的时候手动写一堆的 cffi:defcfun 实在是头痛, 而使用 c2ffi 却并没有那么的省心. 不过话又说回来了, 反正都是从 *.h 文件中读取函数的定义, 然后按照一定的规则去生成代码 cffi:defcfun. 一个简单的想法是写一个 parser, 然后把函数名和类型等提取, 最后根据规则进行代码的生成 &#8211; 但是为什么不直接利用 Emacs 的 Tree-sitter 的集成 (Parsing Program Source) 呢? Requirement 首先需要确保 Tree-sitter 在 Emacs 中是可用的: (treesit-available-p) t 并且 C parser 已经被正确地安装了: (treesit-install-language-grammar &#39;c) 注: 在 Emacs 29 之后 Tree-sitter 就已经被内置在了 Emacs 中, 假如你的 Emacs 版本较早, 可以参考 emacs-tree-sitter 进行配置. *.h \(&rarr;\) *.lisp via Tree-sitter Parse *.h 假设有一个 foo.h 头文件被打开了 (其 buffer 名称为 foo.h), 创建一个 Tree-sitter 的 parser: foo.h #include &quot;stdio.h&quot;]]></summary></entry><entry><title type="html">Data structure: Linked List</title><link href="/ctf/data-structure-linked-list/" rel="alternate" type="text/html" title="Data structure: Linked List" /><published>2025-05-27T00:00:00+00:00</published><updated>2025-05-27T00:00:00+00:00</updated><id>/ctf/data-structure-linked-list</id><content type="html" xml:base="/ctf/data-structure-linked-list/"><![CDATA[<h1>About</h1>
<p>本文是给 <a href="https://github.com/UCAS-CTF">UCAS-CTF</a> C 语言缓速班数据结构中链表一节的讲义.</p>
<h1>Detour: 给我一块内存空间: <code>malloc</code>, <code>free</code></h1>
<p>一个简单的复习: 当我们使用 <code>malloc</code> 的时候, 我们会向系统要一个一定大小的内存空间.
  比如说, 如果我们要申请一个大小是 <code>64</code> 个 <code>float</code> 的空间, 那么我们会使用:</p>
<div class="highlight"><pre><span></span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">farr_64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span>
</pre></div>
<p>而当我们结束了这块内存空间的使用时, 又可以通过 <code>free</code> 的方式释放这块内存空间:</p>
<div class="highlight"><pre><span></span><span class="n">free</span><span class="p">(</span><span class="n">farr_64</span><span class="p">);</span>
</pre></div>
<p>如此这般申请得到的内存空间是一块连续的内存空间, 我们可以用:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="o">*</span><span class="p">(</span><span class="n">farr_64</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">                     </span><span class="c1">// 指针的形式</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">a_simple_function</span><span class="p">(</span><span class="n">farr_64</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"> </span><span class="c1">// 类似数组的形式</span>
</pre></div>
<p>来读写这个内存空间上的数据.</p>
<details><summary>示例代码</summary>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="cp">#define SIZE 5</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">SIZE</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// init arr with random number [0, 1)</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">RAND_MAX</span><span class="p">);</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SIZE</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2f, &quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">));</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<pre class="example">
0.00, 0.13, 0.76, 0.46, 0.53,
</pre>
</details>
<p><b>问题</b>: 你现在需要储存一个用户的名字的数据,
  你认为正常人类的名字应该可以在 <code>80</code> 个字符内搞定,
  所以你 <code>malloc(80 * sizeof(char))</code> 作为了用户的名字的空间,
  然后你得到了这样的名字:</p>
<blockquote>
  <p>寿限无寿限无扔屎机前天小新的内裤新八的人生巴尔蒙克·费扎利昂艾萨克·修奈达
    三分之一纯情的感情的剩下三分之二是在意肉刺的感情我知道无法逃离的背叛其实
    可以逃离离家出游鱿鱼煎鲣鱼鱼子自家粪池鲣鱼……这条鲣鱼跟刚才的不同这条
    是池乃鲣鱼啦辣油雄帝宫王木村皇呸呸呸呸呸呸呸呸呸呸呸呸小屎丸</p>
</blockquote>
<p>emmm&#8230; 好吧, 那么把 <code>SIZE</code> 设为 <code>256</code> 吧, 这下足够大了吧:</p>
<blockquote>
  <p>Adolph Blaine Charles David Earl Frederick Gerald Hubert Irvin John Kenneth
    Lloyd Martin Nero Oliver Paul Quincy Randolph Sherman Thomas Uncas Victor
    William Xerxes Yancy Zeus Wolfeschlegel­steinhausen­bergerdorff­welche­
    vor­altern­waren­gewissenhaft­schafers­wessen­schafe­waren­wohl­
    gepflege­und­sorgfaltigkeit­beschutzen­vor­angreifen­durch­ihr­
    raubgierig­feinde­welche­vor­altern­zwolfhundert­tausend­jahres­
    voran­die­erscheinen­von­der­erste­erdemensch­der­raumschiff­
    genacht­mit­tungstein­und­sieben­iridium­elektrisch­motors­gebrauch­
    licht­als­sein­ursprung­von­kraft­gestart­sein­lange­fahrt­
    hinzwischen­sternartig­raum­auf­der­suchen­nachbarschaft­der­stern­
    welche­gehabt­bewohnbar­planeten­kreise­drehen­sich­und­wohin­der­
    neue­rasse­von­verstandig­menschlichkeit­konnte­fortpflanzen­und­sich­
    erfreuen­an­lebenslanglich­freude­und­ruhe­mit­nicht­ein­furcht­vor­
    angreifen­vor­anderer­intelligent­geschopfs­von­hinzwischen­sternartig­
    raum Sr.</p>
  <p>(<a href="https://zh.wikipedia.org/zh-cn/休伯特·布萊因·沃爾夫什里格爾斯坦霍森伯格多夫">Wikipedia-休伯特·布莱因·沃尔夫什里格尔斯坦霍森伯格多夫</a>)</p>
</blockquote>
<p>emmm&#8230; 那么把 <code>SIZE</code> 设为 <code>1028</code> 吧&#8230;</p>
<p>好像也不太对劲, 当然, 你也不是不能强制用户将自己的名字设定为 <code>3-20</code> 个字符,
  但如果我们想要一个能够支持储存任意长度的输入的数据结构, 这该如何呢?</p>
<details><summary>也不是不能&#8230; </summary>
<p>我们可以做一个数组 <code>append</code> 的操作:</p>
<ol>
  <li>若需要填充的数据大小 <code>&lt; length(arr)</code>, 则将数据写入 <code>arr[fill-pointer]</code></li>
  <li>防止, 新建一个数组, 其大小为 <code>length(arr) + APPEND_SIZE</code>,
    然后将旧数组的所有数据都拷贝进去.</li>
</ol>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="cp">#define DATA_T int</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">appendable_vector_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">fill_pointer</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>

<span class="w">  </span><span class="n">DATA_T</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">AppendableVector</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm">  Return a pointer to allocated `AppendableVector`.</span>
<span class="cm">  If failed to alloc, return NULL;</span>

<span class="cm">  Parameters:</span>
<span class="cm">  + `length`: size of `AppendableVector`</span>

<span class="cm"> */</span>
<span class="n">AppendableVector</span><span class="w"> </span><span class="o">*</span><span class="nf">make_vector</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">AppendableVector</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">AppendableVector</span><span class="p">));</span>
<span class="w">  </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DATA_T</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">  </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">fill_pointer</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm">  Push `element` to the end of `vec`.</span>

<span class="cm">  Parameters:</span>
<span class="cm">  + `vec`: a pointer to `AppendableVector`</span>
<span class="cm">  + `element`: an element as `vec` new element</span>
<span class="cm"> */</span>
<span class="n">AppendableVector</span><span class="w"> </span><span class="o">*</span><span class="nf">vector_push</span><span class="p">(</span><span class="n">AppendableVector</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">element</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// no space to fill</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">fill_pointer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DATA_T</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">fill_pointer</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">element</span><span class="p">;</span>
<span class="w">  </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">fill_pointer</span><span class="o">++</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">vec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Free allocation of AppendableVector `vec`.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">free_vector</span><span class="p">(</span><span class="n">AppendableVector</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">  Print all the data in AppendableVector `vec`.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">print_vector</span><span class="p">(</span><span class="n">AppendableVector</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">fill_pointer</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">AppendableVector</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_vector</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print_vector</span><span class="p">(</span><span class="n">vector_push</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">free_vector</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<pre class="example">
[0, ]
[0, 1, ]
[0, 1, 2, ]
[0, 1, 2, 3, ]
[0, 1, 2, 3, 4, ]
[0, 1, 2, 3, 4, 5, ]
[0, 1, 2, 3, 4, 5, 6, ]
[0, 1, 2, 3, 4, 5, 6, 7, ]
[0, 1, 2, 3, 4, 5, 6, 7, 8, ]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ]
</pre>
</details>
<h1>链表 <code>LinkedList</code></h1>
<h2>一个非常简单的链表的实现</h2>
<p>一个简单的想法就是: 好吧, 如果当前分配的内存不够用了, 就在它后面跟一块补丁.
  类似如下图所示:</p>
<p><img src="/_img/pieces/data-struct/linked-data.svg" alt="/_img/pieces/data-struct/linked-data.svg" /></p>
<p>即, 我们可以把每一份储存的数据片段看作是由两个部分组成的:</p>
<ul>
  <li><code>car</code>: 数据片段本身, 或是一个指向该数据片段的指针</li>
  <li><code>cdr</code>: 一个指向下一段数据片段的指针, 如果其指向 <code>NULL</code>, 则表示没有更多的数据了,
    即数据本身的结束.</li>
</ul>
<details><summary>为什么叫作 car 和 cdr? (一点点的历史)</summary>
<p>在 IBM 的 <a href="https://bitsavers.org/pdf/ibm/704/24-6661-2_704_Manual_1955.pdf">704 机</a> 上, 有一个叫作 Type A 的指令 (page 8), 其由 <code>prefix</code>, <code>decrement</code>,
  <code>tag</code>, <code>address</code> 组成. 早期的 <a href="https://www-formal.stanford.edu/jmc/recursive.html">LISP-1</a> 的实现使用了这样的一个 <code>Word</code> 来表示一个 <code>cons</code>
  数据结构 (有点类似于下面定义的 <code>LinkedString</code>).</p>
<p>所以叫作 *C*​ontent of the *A*​ddress *R*​egister 以及 *C*​ontent of the *D*​ecrement *R*​egister.</p>
<p>那么为什么要用 LISP 里的名字来叫 <code>list</code> 呢? 明明我们可以有其他各种各样的称呼,
  这是因为 LISP (*LIS*​t *P*​rocessing, 列表处理) 差不多可以算是最早的 (仅次于 Fortran)
  的编程语言之一了. 用它来代表一类的编程语言以及其结构, 我觉得并无不可.</p>
<p>我们将会在后面的例子里面看到, 使用列表结构可以如何简单地定义一门编程语言的解释器.</p>
</details>
<p>于是我们可以用这样的方式来实现我们前面的 &#8220;任意长度名称&#8221; 存储的数据结构:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">linked_string_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">chr</span><span class="p">;</span><span class="w">                     </span><span class="c1">// car</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">linked_string_</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">  </span><span class="c1">// cdr</span>
<span class="p">}</span><span class="w"> </span><span class="n">LinkedString</span><span class="p">;</span>
</pre></div>
<p>假如我们有一个函数可以构造这样的数据对 <code>cons_LinkedString(chr, next)</code>,</p>
<details><summary>具体的实现</summary>
<div class="highlight"><pre><span></span><span class="n">LinkedString</span><span class="o">*</span><span class="w"> </span><span class="nf">cons_LinkedString</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">chr</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LinkedString</span><span class="p">));</span>
<span class="w">  </span><span class="n">str</span><span class="o">-&gt;</span><span class="n">chr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">chr</span><span class="p">;</span>
<span class="w">  </span><span class="n">str</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">print_LinkedString</span><span class="p">(</span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">putchar</span><span class="p">(</span><span class="n">str</span><span class="o">-&gt;</span><span class="n">chr</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="n">print_LinkedString</span><span class="p">(</span><span class="n">str</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">free_LinkedString</span><span class="p">(</span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="n">free_LinkedString</span><span class="p">(</span><span class="n">str</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="w">  </span><span class="n">free</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</details>
<p>于是我们就可以把一个字符串 =&#8221;Hello&#8221;= 写作:</p>
<div class="highlight"><pre><span></span><span class="n">cons_LinkedString</span><span class="p">(</span><span class="sc">&#39;H&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">cons_LinkedString</span><span class="p">(</span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="w"> </span>\
<span class="w">  </span><span class="n">cons_LinkedString</span><span class="p">(</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">cons_LinkedString</span><span class="p">(</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="w"> </span>\
<span class="w">    </span><span class="n">cons_LinkedString</span><span class="p">(</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)))));</span>
</pre></div>
<details><summary>一个完整的演示</summary>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">LinkedString</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="o">&lt;&lt;</span><span class="n">cons_LinkedString</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">linked_string_hello</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="n">print_LinkedString</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span>
<span class="w">  </span><span class="n">free_LinkedString</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<pre class="example">
Hello
</pre>
</details>
<h3>对链表的各种操作</h3>
<p>这部分可能有些无趣, 我会尽量用图示, 伪代码算法描述以及折叠的 C 代码进行介绍.</p>
<ul>
  <li>读第 <code>n</code> 个元素的值 <code>nth_LinkedString(n, str)</code>
    <p><img src="/_img/ctf/nth_LinkedString.svg" alt="/_img/ctf/nth_LinkedString.svg" /></p>
    <p><b>Algorithm</b>:</p>
    <ol>
      <li>从 <code>list</code> 头开始, 若 <code>n</code> 为 <code>0</code>, 则返回 <code>first(str)</code></li>
      <li>反之, 若 <code>n &gt; 0</code>, 则返回 <code>nth_LinkedString(n - 1, rest(str))</code></li>
    </ol>
  <details><summary>简单的实现和实现需要注意的问题</summary>
<div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="nf">nth_LinkedString</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">str</span><span class="o">-&gt;</span><span class="n">chr</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w">  </span><span class="mi">0</span><span class="p">)</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">nth_LinkedString</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
    <p>如何处理边界条件 <code>n</code>?</p>
  </details>
  <details><summary>一些有趣的其他的数据结构的模拟</summary>
    <p>这部分不是那么有用, 大家可以看看就好.</p>
    <p>我们可以用 <code>list</code> 去模拟一个表:</p>
<div class="highlight"><pre><span></span><span class="p">((</span><span class="nf">a1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="nf">a2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="w"> </span><span class="o">...</span><span class="p">)</span>
</pre></div>
    <p><img src="/_img/ctf/assoc_LinkedString.svg" alt="/_img/ctf/assoc_LinkedString.svg" /></p>
    <p><b>思考</b>: 大家可以思考一下如何:</p>
    <ul>
      <li>从表里面读取和写入数据</li>
      <li>合并两个表</li>
      <li>&#8230;</li>
    </ul>
  </details>
  </li>
  <li>判断两个链表是否相等 <code>equalp_LinkedString(str1, str2)</code>
    <p><img src="/_img/ctf/equalp_LinkedString.svg" alt="/_img/ctf/equalp_LinkedString.svg" /></p>
    <p><b>Algorithm</b>:</p>
    <ol>
      <li>若 <code>str1</code> 和 <code>str2</code> 都是 <code>NULL</code>, 则相同</li>
      <li>若 <code>car(str1)</code> 和 <code>car(str2)</code> 不相同, 则不同</li>
      <li>比较 <code>equalp(cdr(str1), cdr(str2))</code></li>
    </ol>
  <details><summary>简单的实现</summary>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">equalp_LinkedString</span><span class="p">(</span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">str1</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">str2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">str2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">TRUE</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">chr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">str2</span><span class="o">-&gt;</span><span class="n">chr</span><span class="p">)</span><span class="w">       </span><span class="k">return</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">equalp_LinkedString</span><span class="p">(</span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">str2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
  </details>
  </li>
  <li>删除第 <code>n</code> 个元素 <code>delete_nth_LinkedString(n, str)</code>
    <p><img src="/_img/ctf/delete_LinkedString.svg" alt="/_img/ctf/delete_LinkedString.svg" /></p>
    <p><b>Algorithm</b>:</p>
    <ol>
      <li>找到第 <code>n</code> 个元素的 <code>cons_n</code>, 以及前一个元素的 <code>cons_{n-1}</code>,
        以及后一个元素 <code>cons_{n+1}</code></li>
      <li>将 <code>cons_{n-1}-&gt;next</code> 指向 <code>cons_{n+1}</code></li>
    </ol>
  <details><summary>简单的实现</summary>
<div class="highlight"><pre><span></span><span class="n">LinkedString</span><span class="o">*</span><span class="w"> </span><span class="nf">delete_nth_LinkedString</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedString</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">search</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">search</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="n">search</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">search</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

<span class="w">  </span><span class="n">search</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">search</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </details>
    <p><b>思考</b>: 如果我们不希望删除的操作对 <code>str</code> 本身存在修改的行为 (side-effect),
      我们该如何设计这个算法?</p>
    <p>注: 这个思考题其实包含了一个 <code>immutable</code> (不可变) 对象的处理方法的考虑.</p>
  </li>
  <li>替换链表中的第 <code>n</code> 个元素 <code>set_nth_LinkedString(chr, n, str)</code>
    <p><img src="/_img/ctf/set_nth_LinkedString.svg" alt="/_img/ctf/set_nth_LinkedString.svg" /></p>
    <p><b>思考</b>: 这个算法并不难想, 留作习题.</p>
    <p><b>思考</b>: 同样的, 我们也可以考虑该如何去实现这样的无 side-effect 版本的算法.</p>
  </li>
  <li>合并两个链表 <code>append_LinkedString(str1, str2)</code>
    <p><b>思考</b>: 这个算法并不难想, 看看上面的 <code>set_nth_LinkedString</code>, 留作习题.</p>
    <p><b>思考</b>: 如果我们希望的是 <code>union_LinkedString(str1, str2)</code>, 该如何设计?</p>
    <p><b>思考</b>: 同样的, 如果我们希望实现非 destructive 的算法, 又该如何设计?</p>
  </li>
</ul>
<details><summary>为什么在这里会要求一些无 side-effect 的算法? </summary>
</details>
<details><summary>尾递归</summary>
<p>我们会发现, 前面的算法往往都有如下的形式:</p>
<div class="highlight"><pre><span></span><span class="n">RESULT_T</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">LinkedList</span><span class="w"> </span><span class="o">*</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">continuep</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cdr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cdr</span><span class="p">);</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">process_on</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>即我们通过递归的方式构建我们的算法, 这样的算法写起来和读起来都非常容易,
  只是&#8230; 对于性能敏感肌的同学们往往会问一个问题: 你这递归算法,
  函数调用的开栈过程是不是很影响性能啊?</p>
<p>那么难道没法解决了么? 并非如此, 我们会发现上面的递归算法可以写成循环的形式:</p>
<div class="highlight"><pre><span></span><span class="n">RESULT_T</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">LinkedList</span><span class="w"> </span><span class="o">*</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">continuep</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cdr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="o">-&gt;</span><span class="n">cdr</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">process_on</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>当然, 这个例子还是有点太简单了, 实际上在编译器中这样的替换会被自动执行,
  称为 &#8220;尾递归&#8221; 优化.</p>
<p><b>思考</b>: 请比较下面的同一个函数的两种不同表示, 哪一种会被尾递归优化?</p>
<div class="highlight"><pre><span></span><span class="n">LinkedString</span><span class="o">*</span><span class="w"> </span><span class="nf">str_to_LinkedString</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cons_LinkedString</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">str_to_LinkedString</span><span class="p">(</span><span class="n">str</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>和:</p>
<div class="highlight"><pre><span></span><span class="n">LinkedString</span><span class="o">*</span><span class="w"> </span><span class="nf">str_to_LinkedString_acc</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">LinkedString</span><span class="w"> </span><span class="o">*</span><span class="n">lstr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lstr</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">str_to_LinkedString_acc</span><span class="p">(</span><span class="n">str</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cons_LinkedString</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">lstr</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<details><summary>答案</summary>
<p>后者&#8230; (废话, 选名字长的, bushi)</p>
<p>相当于用函数 <code>argument</code> 作为了循环中的循环变量.</p>
</details>
</details>
<h3>那么古尔丹, 代价是什么呢?</h3>
<ul>
  <li>空间上更占空间
    <p>不难发现, 和数组相比, 链表的每个元素还多了一个指向下一个元素的指针,
      虽然占用的内存不多, 但是总归也算是内存</p>
  </li>
  <li>时间上也没占优势
    <p>比如访问第 <code>n</code> 个元素的时候, 我们总要进行 <code>n</code> 次寻址, 而与之对比的是,
      数组的第 <code>n</code> 个元素的访问快的多了.</p>
  </li>
</ul>
<details><summary>那么难道就完蛋了吗? </summary>
<p>其实也不是不能做一些简单的优化:</p>
<ul>
  <li>比如可以用一个简单的标记来标记数据, 将数据分为 normal cdr 和 compressed cdr:
    <p><img src="/_img/ctf/compressed_list.png" alt="/_img/ctf/compressed_list.png" /></p>
    <p>(Symbolics 3600 Techical Summary)</p>
  </li>
  <li>或者可以用类似于一块数组接另一块数组的形式:
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">linked_string_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buff</span><span class="p">[</span><span class="n">BUFF_SIZE</span><span class="p">];</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">linked_string_</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">LinkedString</span><span class="p">;</span>
</pre></div>
  </li>
  <li>当然, 在硬件层面上的优化也是可以的</li>
  <li>不过问题又回来了, 写得爽不就好了? 嫌跑不快的可以换一个更新的电脑,
    以及尝试并行的算法</li>
</ul>
<p>注: 不过还是建议在使用数据类型的时候还是需要考虑具体的引用场景.</p>
</details>
<h3>既然你已经学会了单向链表, 那么双向链表和环链表估计也不是问题了吧</h3>
<p>因为我们暂时用不到这两个, 所以只会非常简单地进行一个介绍.</p>
<ul>
  <li>双向链表
    <p><img src="/_img/ctf/DoubleLinkedString.svg" alt="/_img/ctf/DoubleLinkedString.svg" /></p>
  </li>
  <li>环链表
    <p><img src="/_img/ctf/RingLinkedString.svg" alt="/_img/ctf/RingLinkedString.svg" /></p>
  </li>
</ul>
<h1>用链表实现一些有趣的东西</h1>
<h2>用链表实现逆波兰表达式的计算</h2>
<h3>读逆波兰表达式 <code>read_from_string(str)</code></h3>
<p>总的代码有点长, 这里直接给一个能用的代码了 (<a href="/_img/ctf/foo.c">foo.c</a>).</p>
<p>运行的效果类似于:</p>
<pre class="example">
&gt; (hello world)
(hello . (world . nil))
</pre>
<ol>
  <li>读取输入行</li>
  <li>然后打印出来</li>
  <li>循环上面的步骤</li>
</ol>
<details><summary>一点点的解释</summary>
<ul>
  <li>定义数据结构
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cons_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Object</span><span class="o">*</span><span class="w"> </span><span class="n">car</span><span class="p">;</span>
<span class="w">  </span><span class="n">Object</span><span class="o">*</span><span class="w"> </span><span class="n">cdr</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Cons</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">object_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">CONS</span><span class="p">,</span><span class="w"> </span><span class="n">SYMBOL</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">tag</span><span class="p">;</span>

<span class="w">  </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Cons</span><span class="w">        </span><span class="o">*</span><span class="n">cons</span><span class="p">;</span>
<span class="w">    </span><span class="n">SymbolName</span><span class="w">  </span><span class="o">*</span><span class="n">symbol</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
    <p>这里用 <code>tag</code> 的形式标记了数据结构使得其能够更好地支持不同的数据类型,
      在这里, 只有 <code>SYMBOL</code> 和 <code>CONS</code> 两种数据类型.</p>
  </li>
  <li>其实最麻烦的部分就是读取了
<div class="highlight"><pre><span></span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="nf">read_from_string_</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FUNC_CALL</span><span class="p">(</span><span class="s">&quot;read_from_string_&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">;</span>

<span class="w">  </span><span class="n">SKIP_WHITESPACE</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">));</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="o">*</span><span class="n">pos</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="n">DEBUG</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;read_from_string_&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;End of input line. &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">    </span><span class="n">FUNC_RET</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="sc">&#39;(&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="n">DEBUG1</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;read_from_string_&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;read list cons mark ( </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// skip (</span>
<span class="w">    </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_cons_from_string_</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>

<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Object</span><span class="p">));</span>
<span class="w">    </span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SYMBOL</span><span class="p">;</span>
<span class="w">    </span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">symbol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_SymbolName_from_string_</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// failed to read SymbolNames</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">symbol</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="w">      </span><span class="n">FUNC_RET</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">FUNC_RET</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
    <p>用的是非常简单粗暴的读取方法.</p>
  </li>
</ul>
</details>
<h3>请阅读代码, 然后拓展代码使得能够支持 <code>NUMBER</code> 类型的数</h3>
<ol>
  <li>第一个函数: 让我们历遍 <code>SymbolName</code> 以判断其是否是一个 <code>NUMBER</code>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">SymbolName_numberp</span><span class="p">(</span><span class="n">SymbolName</span><span class="w"> </span><span class="o">*</span><span class="n">sym</span><span class="p">);</span><span class="w"> </span><span class="c1">// -&gt; TRUE or FALSE</span>
</pre></div>
  </li>
  <li>第二个函数: 让我们将 <code>SymbolName</code> 变成数
<div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SymbolName_numberp</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">symbol</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUMBER</span><span class="p">;</span>
<span class="w">  </span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SymbolName2number</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">symbol</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
  </li>
  <li>第 n 个函数: 大家写点四则运算之类的函数吧
    <p>比如, 举个例子:</p>
<div class="highlight"><pre><span></span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="nf">op2_add</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span>
<span class="w">      </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NUMBER</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NUMBER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cannot add &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">print_object</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; and &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">print_object</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; together. &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Object</span><span class="p">));</span>
<span class="w">  </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUMBER</span><span class="p">;</span>
<span class="w">  </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
    <p>大家可以实现一些简单的函数来自己玩一下. 然后用:</p>
<div class="highlight"><pre><span></span><span class="n">op2_add</span><span class="p">(</span><span class="n">read_from_string</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">read_from_string</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">));</span>
</pre></div>
    <p>这样的简单函数测试一下.</p>
   <details><summary>那么我们的内存要在什么时候回收呢? </summary>
    <p>你说的对, 我们的内存确实完全没有回收, 这会导致随着计算的增加,
      我们的程序的内存占用会越来越大. 这非常的坏.</p>
    <p>我们会在后面有空的时候介绍一下简单的 GC (垃圾回收).</p>
   </details>
  </li>
</ol>
<h3><code>eval</code>: 让我们计算一下表达式的值</h3>
<p>假如我们现在希望能够计算 <code>(+ 1 2 3)</code> 这样的表达式的值, 我们需要?</p>
<ol>
  <li>对于读到的表达式 <code>expr</code>, 我们取其 <code>car(expr)</code> 元素, 若其为
    <ul>
      <li><code>+</code>: 则将 <code>cdr(expr)</code> 元素全部加在一起</li>
      <li><code>-</code>: 则将 <code>car(cdr(expr))</code> 用剩余的其他 <code>cdr(cdr(expr))</code> 元素相减</li>
      <li>&#8230;</li>
    </ul>
    <p>于是我们可以写这样的一个函数 <code>eval</code>:</p>
<div class="highlight"><pre><span></span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="nf">eval</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">expr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">expr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CONS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Don&#39;t know how to eval(&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">print_object</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">cmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="n">Sadd</span><span class="p">))</span><span class="w">          </span><span class="c1">// Object *Sadd = read_from_string(&quot;+&quot;);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">op_add</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">eq</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="n">Ssub</span><span class="p">))</span><span class="w">     </span><span class="c1">// Object *Ssub = read_from_string(&quot;-&quot;);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">op_sub</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">expr</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// add more commands ...</span>

<span class="w">  </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Unknown command &quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">print_object</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">  </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </li>
  <li>不难发现, 如果把这样的表达式用 C 语言一般的函数调用来写
    <ul>
      <li><code>(func arg1 arg2 arg3 ...)</code></li>
      <li><code>func(arg1, arg2, arg3, ...)</code></li>
    </ul>
    <p>两者是等价的</p>
  </li>
</ol>
<h3>一些补注: 这里提供一些辅助函数的实现</h3>
<ul>
  <li><code>car(cons)</code>
    <p>Return <code>car</code> of <code>cons</code>.</p>
<div class="highlight"><pre><span></span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="nf">car</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">cons</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cons</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CONS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print_object</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is not cons. &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">car</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </li>
  <li><code>cdr(cons)</code>
    <p>Return <code>cdr</code> of <code>cons</code>.</p>
<div class="highlight"><pre><span></span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="nf">cdr</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="o">*</span><span class="n">cons</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cons</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">tag</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CONS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">print_object</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span><span class="w"> </span><span class="n">stderr</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; is not cons. &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">.</span><span class="n">cons</span><span class="o">-&gt;</span><span class="n">cdr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </li>
  <li><code>cons(car, cdr)</code>
    <p>Make <code>cons</code> of <code>car</code> and <code>cdr</code>.</p>
  </li>
  <li><code>eq(a, b)</code>
    <p>Test if two symbol <code>a</code> and <code>b</code> is equal (literally).
      Return <code>t</code> if true, <code>nil</code> if not.</p>
  </li>
  <li><code>cond((condition . exprs) ...)</code>
    <p>If <code>condition</code> is non <code>nil</code>, eval <code>exprs</code>.
      Otherwise, test on other <code>(condition . exprs)</code> pairs.
      If non of the <code>(condition . exprs)</code> pairs works, return <code>nil</code>.</p>
  </li>
  <li><code>atom(expr)</code>
    <p>Test if <code>expr</code> is <b>not</b> <code>cons</code>.</p>
  </li>
</ul>
<h3>补注的补注: 既然我们已经实现了这么多的函数&#8230;</h3>
<p>其实可以考虑参考:</p>
<ul>
  <li><a href="/lisp/from-linked-list-to-the-old-yet-modern-computer/">From Linked List to the Old Yet Modern Computer (1)</a></li>
  <li><a href="/lisp/from-linked-list-to-the-old-yet-modern-computer-2/">From Linked List to the Old Yet Modern Computer (2)</a></li>
</ul>
<p>来只用上面的几个 <code>car</code>, <code>cdr</code>, <code>cons</code>, <code>atom</code>, <code>eq</code>, <code>cond</code>
  来实现一个简单的编程语言解释器.</p>
<details><summary>一些更多的乐子</summary>
<ul>
  <li><b>内存回收</b>: 前面我们已经指出了貌似我们好像缺少一些内存回收的机制,
    会导致内存爆炸的危机&#8230; 这非常的坏. 那么我们该如何解决这个问题呢?</li>
  <li><b>宏</b>: 既然我们的表达式 (代码) 都是和数据一样的列表,
    那么为啥不能用代码生成代码呢?</li>
  <li><b>自举</b>: 既然是图灵完备的编程语言解释器, 所以为何不妨试试让其自举呢?</li>
  <li><b>JIT</b>: 既然能自举了, 为啥不试试 JIT 呢? 这里我们的 JIT 同样可以使用链表,
    同时配合内存回收机制, 这样就能实现许多好玩的特性了.</li>
</ul>
</details>
<p>不过太麻烦了, 跳过.</p>
<h2>用链表实现一个 <code>ed</code> (略)</h2>
<h3>行储存</h3>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">line_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">line_size</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w">   </span><span class="n">buff</span><span class="p">[</span><span class="n">LINE_BUFF_SIZE</span><span class="p">];</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">line_</span><span class="w"> </span><span class="o">*</span><span class="n">rest</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Line</span><span class="p">;</span>
</pre></div>
<p>我们可以用一个 linked-trunk 来表示行这个数据结构.</p>
<h3>文件 buffer 的储存</h3>
<div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_lines_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">line_number</span><span class="p">;</span>
<span class="w">  </span><span class="n">Line</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_lines_</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_lines_</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">BufferLines</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">;</span>

<span class="w">  </span><span class="n">BufferLines</span><span class="o">*</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="n">BufferLines</span><span class="o">*</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>
<span class="w">  </span><span class="n">BufferLines</span><span class="o">*</span><span class="w"> </span><span class="n">curr</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Buffer</span><span class="p">;</span>
</pre></div>
<p>可以用一个双向链表实现的环来储存文件 buffer.</p>
<h3>一些操作</h3>
<ul>
  <li><code>append_line_(BufferLines *pos, BufferLines *line)</code>
    <p>Insert <code>line</code> after <code>pos</code>.</p>
  </li>
  <li><code>read_BufferLines_(char *str, size_t *pos)</code>
    <p>Return <code>Bufferlines</code> from <code>str</code>, increasing <code>pos</code>.</p>
  </li>
  <li><code>append_line(BufferLines *pos, char *line)</code>
    <p>Insert <code>line</code> after <code>pos</code>.</p>
  </li>
  <li><code>delete_line(BufferLines *pos)</code>
    <p>Delete line at <code>pos</code>.</p>
  </li>
  <li><code>read_Buffer(char *file)</code>
    <p>Read and return <code>Buffer</code> from <code>file</code>.</p>
  </li>
  <li><code>write_Buffer(char *file, Buffer *buffer)</code>
    <p>Write <code>buffer</code> to <code>file</code>.</p>
  </li>
</ul>
<p>注: 假如课上有时间的话, 我们可以尝试实现一下.</p>
<h3>注: 比较困难的部分是指令的读取</h3>
<p>大家可以参考 <a href="https://pubs.opengroup.org/onlinepubs/9799919799/utilities/ed.html">ed</a> 的官方文档来实现指令读取和操作功能. 这里就略过了.</p>]]></content><author><name></name></author><category term="ctf" /><summary type="html"><![CDATA[About 本文是给 UCAS-CTF C 语言缓速班数据结构中链表一节的讲义. Detour: 给我一块内存空间: malloc, free 一个简单的复习: 当我们使用 malloc 的时候, 我们会向系统要一个一定大小的内存空间. 比如说, 如果我们要申请一个大小是 64 个 float 的空间, 那么我们会使用: float* farr_64 = malloc(sizeof(float) * 64); 而当我们结束了这块内存空间的使用时, 又可以通过 free 的方式释放这块内存空间: free(farr_64); 如此这般申请得到的内存空间是一块连续的内存空间, 我们可以用: for (size_t i = 0; i &lt; 64; i++) *(farr_64 + i) // 指针的形式 = a_simple_function(farr_64[i]); // 类似数组的形式 来读写这个内存空间上的数据. 示例代码 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt;]]></summary></entry><entry><title type="html">ObjC 1: Basic Objective-C Programming</title><link href="/lisp/objc1-basic-objc/" rel="alternate" type="text/html" title="ObjC 1: Basic Objective-C Programming" /><published>2025-04-05T00:00:00+00:00</published><updated>2025-04-05T00:00:00+00:00</updated><id>/lisp/objc1-basic-objc</id><content type="html" xml:base="/lisp/objc1-basic-objc/"><![CDATA[<h1>About</h1>
<p>之前的活 (<a href="/lisp/objc-0-webdriver-download-objc-doc/">ObjC 0: WebDriver Download ObjC Runtime Documentation</a>) 的下
  一部分就该轮到写一些简单的 Objective-C 的代码了. 但是问题是: 我好像从
  来没有写过 ObjC 的代码&#8230;</p>
<p>所以这里会参考 <a href="https://github.com/EimaMei/Silicon/">Silicon.h</a> 和 <a href="https://dev.to/colleagueriley/rgfw-under-the-hood-cocoa-in-pure-c-1c7j">RGFW Under the Hood: Cocoa in Pure C</a> 中的
  方案尝试只使用 C-side (即 ObjC Runtime) 来调用 Objective-C 的部分. 同
  时借鉴 <a href="https://fullonrager.github.io/rys-objective-c-tutorial-archive/">Ry’s Objective-C Tutorial</a> 用于测试 ObjC Runtime 的 binding 是否
  可用.</p>
<h1>ObjC to C, then, CFFI, to Lisp</h1>
<h2>Simple <code>main()</code></h2>
<p>示例代码来自 <a href="https://fullonrager.github.io/rys-objective-c-tutorial-archive/introduction.html">Ry's Objective-C</a>:</p>
<div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">@autoreleasepool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;ObjC Test&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>使用 <code>clang -o &lt;out&gt; &lt;src&gt; -ObjC -framework Foundation</code> 进行编译. 效果如
  下:</p>
<pre class="example">
~/Buff
[੧ᐛ੭] &gt; clang -o objc objc.m -ObjC -framework Foundation
~/Buff
[੧ᐛ੭] &gt; ./objc
2025-04-02 02:12:45.622 objc[75447:24806460] ObjC Test
</pre>
<p>嘛, 至少能动了.</p>
<h3>The <code>@</code> mark</h3>
<p>询问 DeepSeek 可以得知, <code>@</code> 表示这后面跟着的东西是 ObjC 的东西, 比如
  <code>@&quot;balabala&quot;= 表示 =NSString</code> 的字面量, <code>@[...]</code>, <code>@{...}</code> 分别表示 <code>NSArray</code> 和
  <code>NSDictionary</code>, 之类的. 那么差不多就需要一个 C literal value 转换为 ObjC
  量的操作.</p>
<p>比如可以用 <code>[NSString stringWithUTF8String:&quot;ObjC Test&quot;]</code> 的方式来表示这
  个字面量. 区别就是 <code>@&quot;&quot;= 会在编译的时候被当作常量储存, 而 =[]</code> 的形式会让
  字符串在运行时被转换.</p>
<p>比如可以用 Clang 将 ObjC 代码 transcompile 到 C++ 代码:</p>
<div class="highlight"><pre><span></span>clang<span class="w"> </span>-rewrite-objc<span class="w"> </span>objc.m<span class="w"> </span>-o<span class="w"> </span>objc.c<span class="w"> </span>-Wno-everything<span class="w"> </span>-fno-ms-extensions
</pre></div>
<ul>
  <li>=@&#8221;&#8220;= 形式:
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/* @autoreleasepool */</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">__AtAutoreleasePool</span><span class="w"> </span><span class="n">__autoreleasepool</span><span class="p">;</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">((</span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_rm_bjy42f597pjbncssb6l_766m0000gn_T_objc_1497c2_mi_0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
    <p>会编成常量形式进行储存:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">__NSConstantStringImpl</span><span class="w"> </span><span class="n">__NSConstantStringImpl__var_folders_rm_bjy42f597pjbncssb6l_766m0000gn_T_objc_1497c2_mi_0</span><span class="w"> </span><span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">section</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;__DATA, __cfstring&quot;</span><span class="p">)))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">__CFConstantStringClassReference</span><span class="p">,</span><span class="mh">0x000007c8</span><span class="p">,</span><span class="s">&quot;ObjC Test&quot;</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
</pre></div>
    <p>不过考虑到从 Lisp 侧调用的时候应该没法通过这种方式进行调用, 所以估计
      得通过 Runtime <code>[]</code> 的形式调用.</p>
  </li>
  <li><code>[]</code> 形式:
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/* @autoreleasepool */</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">__AtAutoreleasePool</span><span class="w"> </span><span class="n">__autoreleasepool</span><span class="p">;</span>
<span class="w">    </span><span class="n">NSLog</span><span class="p">(((</span><span class="n">NSString</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_Nullable</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_Nonnull</span><span class="p">))(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="n">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSString&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="s">&quot;ObjC Test&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </li>
</ul>
<h3>The <code>[]</code> square</h3>
<p>这里参考 <a href="https://github.com/EimaMei/Silicon/blob/a64f695f00fe589fa3a20ad8df508487a023f2f4/silicon.h#L3495">Silicon.h</a> 的实现:</p>
<div class="highlight"><pre><span></span><span class="n">NSString</span><span class="o">*</span><span class="w"> </span><span class="nf">NSString_stringWithUTF8String</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">	</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SI_NS_FUNCTIONS</span><span class="p">[</span><span class="n">NS_STRING_WIDTH_UTF8_STRING_CODE</span><span class="p">];</span>
<span class="w">	</span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)</span>
<span class="w">				</span><span class="p">(</span><span class="n">SI_NS_CLASSES</span><span class="p">[</span><span class="n">NS_STRING_CODE</span><span class="p">],</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>其中 <code>SI_NS_FUNCTIONS[NS_STRING_WIDTH_UTF8_STRING_CODE]</code> 和
  <code>SI_NS_CLASSES[NS_STRING_CODE]</code> 为缓存机制:</p>
<div class="highlight"><pre><span></span><span class="n">SI_NS_CLASSES</span><span class="p">[</span><span class="n">NS_STRING_CODE</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSString&quot;</span><span class="p">);</span>
<span class="n">SI_NS_FUNCTIONS</span><span class="p">[</span><span class="n">NS_STRING_WIDTH_UTF8_STRING_CODE</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="p">);</span>
</pre></div>
<p>于是应当可以改写 <code>main</code>:</p>
<div class="highlight"><pre><span></span><span class="n">NSLog</span><span class="p">(</span><span class="n">NSString_stringWithUTF8String</span><span class="p">(</span><span class="s">&quot;ObjC Test&quot;</span><span class="p">));</span>
</pre></div>
<p>其中对应的 <code>NSString_stringWithUTF8String</code> 的实现如下:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nf">NSString_stringWithUTF8String</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">id</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">SEL</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSString&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>同样的, 可以学习 <code>SI_NS_FUNCTIONS</code> 和 <code>SI_NS_CLASSES</code>, 通过对 ObjC 的对象
  访问添加 <code>cache</code> 来减少重复查询的开销.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun-cached</span><span class="w"> </span><span class="nv">coerce-to-objc-class</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="p">)</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="p">(</span><span class="nf">objc-get-class</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>

<span class="p">(</span><span class="nf">defun-cached</span><span class="w"> </span><span class="nv">coerce-to-selector</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="p">)</span><span class="w"> </span><span class="nv">name</span>
<span class="w">  </span><span class="p">(</span><span class="nf">sel-register-name</span><span class="w"> </span><span class="nv">name</span><span class="p">))</span>
</pre></div>
<details><summary>defun-cached 的实现</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">defun-cached</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="w"> </span><span class="nv">lambda-list</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">cache</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="w"> </span><span class="s">&quot;CACHE&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">keyv</span><span class="w">  </span><span class="p">(</span><span class="nb">gensym</span><span class="w"> </span><span class="s">&quot;KEY&quot;</span><span class="p">)))</span>
<span class="w">    </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="o">,</span><span class="nv">cache</span><span class="w"> </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="ss">&#39;equal</span><span class="p">)))</span>
<span class="w">       </span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="o">,</span><span class="nv">name</span><span class="w"> </span><span class="o">,</span><span class="nv">lambda-list</span>
<span class="w">         </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="o">,</span><span class="nv">keyv</span><span class="w"> </span><span class="o">,</span><span class="nv">key</span><span class="p">))</span>
<span class="w">           </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="o">,</span><span class="nv">keyv</span><span class="w"> </span><span class="o">,</span><span class="nv">cache</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="o">,</span><span class="nv">keyv</span><span class="w"> </span><span class="o">,</span><span class="nv">cache</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">progn</span><span class="w"> </span><span class="o">,@</span><span class="nv">body</span><span class="p">))))))))</span>
</pre></div>
</details>
<h3>The <code>@autorealeasepool</code></h3>
<p>根据 <a href="https://stackoverflow.com/a/10290255">stackoverflow</a> 上的这个帖子, 可以参考 <a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool">文档</a>, 会发现用
  <code>[[NSAutoreleasePool alloc] init]</code> 不如 <code>@autoreleasepool</code>.</p>
<p>通过 Clang transcompile 的结果里面, 可以发现:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">__AtAutoreleasePool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">__AtAutoreleasePool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="n">atautoreleasepoolobj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">objc_autoreleasePoolPush</span><span class="p">();}</span>
<span class="w">  </span><span class="o">~</span><span class="n">__AtAutoreleasePool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">atautoreleasepoolobj</span><span class="p">);}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">atautoreleasepoolobj</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>于是可以通过直接调用 <code>objc_autoreleasePoolPush()</code> 以及
  <code>objc_autorelasePoolPop()</code> 来解决这个问题.</p>
<p>于是可以尝试:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">with-autorelease-pool</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">autorelease-pool-obj</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-autorelease-pool-push</span><span class="p">)))</span>
<span class="w">     </span><span class="p">(</span><span class="nf">unwind-protect</span><span class="w"> </span><span class="p">(</span><span class="nf">progn</span><span class="w"> </span><span class="o">,@</span><span class="nv">body</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nf">objc-autorelease-pool-pop</span><span class="w"> </span><span class="nv">autorelease-pool-obj</span><span class="p">))))</span>
</pre></div>
<details><summary>对自动生成的 binding 的 patch</summary>
<p>这里发现在原本自动生成的绑定里面缺少了 <code>objc_autoreleasePoolPush</code> 和
  <code>objc_autoreleasePoolPop</code> 这两个函数, 一开始以为是被移除的 API, 但是发现
  貌似在我的电脑上也不是不能直接调用, 于是就直接进行一个的引用:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-autorelease-pool-push</span><span class="w"> </span><span class="s">&quot;objc_autoreleasePoolPush&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:pointer</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-autorelease-pool-pop</span><span class="w"> </span><span class="s">&quot;objc_autoreleasePoolPop&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:void</span>
<span class="w">  </span><span class="p">(</span><span class="nf">autorelease-pool-obj</span><span class="w"> </span><span class="nv">:pointer</span><span class="p">))</span>
</pre></div>
</details>
<p>当然, 在 LispWorks 里面的写法应该是这样的 (类似如此):</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">with-autorelease-pool</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="nf">ns-log</span><span class="w"> </span><span class="p">(</span><span class="nf">invoke</span><span class="w"> </span><span class="s">&quot;NSString&quot;</span><span class="w"> </span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="w"> </span><span class="s">&quot;ObjC Test&quot;</span><span class="p">)))</span>
</pre></div>
<p>我的目标就是去模拟这个表示方式&#8230; 可以如下地实现:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">with-autorelease-pool</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="nf">ns-log</span>
<span class="w">   </span><span class="p">(</span><span class="nf">foreign-funcall</span><span class="w"> </span><span class="s">&quot;objc_msgSend&quot;</span>
<span class="w">                    </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce-to-objc-class</span><span class="w"> </span><span class="s">&quot;NSString&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce-to-selector</span><span class="w"> </span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="p">)</span>
<span class="w">                    </span><span class="nv">:string</span><span class="w">  </span><span class="s">&quot;OBJC Test&quot;</span>
<span class="w">                    </span><span class="nv">:pointer</span><span class="p">)))</span>
</pre></div>
<details><summary>这里为什么不用绑定的函数? </summary>
<p>因为自动生成的的绑定是这样的:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-msg-send</span><span class="w"> </span><span class="s">&quot;objc_msgSend&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:void</span>
<span class="w">  </span><span class="p">(</span><span class="nf">self</span><span class="w"> </span><span class="nv">objc-id</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">op</span><span class="w">   </span><span class="nv">objc-sel</span><span class="p">)</span>
<span class="w">  </span><span class="nv">&amp;rest</span><span class="p">)</span>
</pre></div>
<p>由于其是 <code>:void</code> 返回值, 其没法传值给 <code>ns-log</code>. 其中 <code>ns-log</code> 定义如下:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defcfun</span><span class="w"> </span><span class="p">(</span><span class="nf">ns-log</span><span class="w"> </span><span class="s">&quot;NSLog&quot;</span><span class="p">)</span><span class="w"> </span><span class="nv">:void</span>
<span class="w">  </span><span class="p">(</span><span class="nf">formatter</span><span class="w"> </span><span class="nv">:pointer</span><span class="p">)</span>
<span class="w">  </span><span class="nv">&amp;rest</span><span class="p">)</span>
</pre></div>
</details>
<h2>Simulate LispWorks API</h2>
<p>于是接下来的目标就是去模拟 LispWorks 的 API? 这里的困难在于缺少测试集,
  只能根据其 API 文档和 LispWorks Personal Edition 来进行一个黑箱逆向了.
  不过逆向这种事情, 我熟啊 (并没有).</p>
<details><summary>科技靠考古 (bushi)</summary>
<p>很多东西都留到了历史书里面去了. 然而历史书往往不过只是短短的一句话, 可
  能这一句话里面就有好几百人数十年的努力&#8230; 但是随着潮流和发展方向的转变,
  可能这些技术就会被慢慢地淡忘甚至无人维护导致成为 &#8220;失传&#8221; 技术了.</p>
<p>这有点像是非物质文化遗产, 因为没有人去维护于是就最后消失了, 只能等待后
  来的有志考古的人们去重新实现. 不过在计算机领域, 因为技术发展迭代速度实
  在是太快了, 可能十几年就是一个新的潮流了&#8230; 就比如最近老是刷到华为三进
  制, 虽然感觉媒体的宣传有点过分抽象了, 但是能有维护或者探索这些技术的尝
  试感觉其实也挺不错的.</p>
<p>所以搞逆向还是有点用处的 (bushi).</p>
</details>
<h3>Lisp Machine 方向的逆向</h3>
<p>在 Lisp 的世界里面, 你就是神. 理论上你可以干各种事情&#8230; 只是可能没有源
  代码在手里&#8230; 所以只能通过检查 symbols, lambda list, documentation 之
  类的方式进行检查了.</p>
<p>以下是一些我使用的简单的 Lisp Image 检查函数:</p>
<ul>
  <li><code>function-lambda-list</code>
<div class="highlight"><pre><span></span><span class="o">#</span><span class="nv">+sbcl</span>
<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">function-lambda-list</span><span class="w"> </span><span class="p">(</span><span class="nf">function</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">errorp</span><span class="w"> </span><span class="nv">t</span><span class="p">))</span>
<span class="w">  </span><span class="s">&quot;Given a function, return its lambda list.</span>
<span class="s">If given a symbol, use the `symbol-function&#39;. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="nb">symbol</span><span class="p">)</span><span class="w"> </span><span class="nv">function</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">errorp</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">functionp</span><span class="w"> </span><span class="nv">function</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">sb-introspect:function-lambda-list</span><span class="w"> </span><span class="nv">function</span><span class="p">))</span>
<span class="w">        </span><span class="p">((</span><span class="nf">symbolp</span><span class="w">   </span><span class="nv">function</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nf">sb-introspect:function-lambda-list</span><span class="w"> </span><span class="p">(</span><span class="nf">symbol-function</span><span class="w"> </span><span class="nv">function</span><span class="p">)))))</span>
</pre></div>
  </li>
  <li><code>sym-in-package-p</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">sym-in-package-p</span><span class="w"> </span><span class="p">(</span><span class="nf">sym</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">package</span><span class="w"> </span><span class="nv">*package*</span><span class="p">))</span>
<span class="w">  </span><span class="s">&quot;Test if `sym&#39; is intern `package&#39;. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nb">symbol</span><span class="w"> </span><span class="nv">sym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nv">package</span><span class="w"> </span><span class="nb">symbol</span><span class="w"> </span><span class="nb">string</span><span class="p">)</span><span class="w"> </span><span class="nv">package</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">equal</span><span class="w"> </span><span class="p">(</span><span class="nf">symbol-package</span><span class="w"> </span><span class="nv">sym</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-package</span><span class="w"> </span><span class="nv">package</span><span class="p">)))</span>
</pre></div>
  </li>
  <li><code>sym-match-regexp-p</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">sym-match-regexp-p</span><span class="w"> </span><span class="p">(</span><span class="nf">regexp</span><span class="w"> </span><span class="nv">sym</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Test if `sym&#39; matches `regexp&#39;. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nb">symbol</span><span class="w"> </span><span class="nv">sym</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nf">ppcre:scan</span><span class="w"> </span><span class="nv">regexp</span><span class="w"> </span><span class="p">(</span><span class="nf">symbol-name</span><span class="w"> </span><span class="nv">sym</span><span class="p">))</span><span class="w"> </span><span class="nv">t</span><span class="p">))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">find-package-symbols</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;key</span><span class="w"> </span><span class="p">(</span><span class="nf">package</span><span class="w"> </span><span class="nv">*package*</span><span class="p">)</span>
<span class="w">                               </span><span class="p">(</span><span class="nf">no-other-package</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span>
<span class="w">                               </span><span class="p">(</span><span class="nf">external-only</span><span class="w"> </span><span class="nv">nil</span><span class="p">)</span>
<span class="w">                               </span><span class="p">(</span><span class="nf">regexp</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="nb">regexp?</span><span class="p">)</span>
<span class="w">                               </span><span class="p">(</span><span class="nf">test</span><span class="w"> </span><span class="p">(</span><span class="nf">constantly</span><span class="w"> </span><span class="nv">t</span><span class="p">)))</span>
<span class="w">  </span><span class="s">&quot;Find symbols in package as list. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">symbols</span><span class="w"> </span><span class="p">())</span>
<span class="w">        </span><span class="p">(</span><span class="nf">regexp</span><span class="w">  </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nb">regexp?</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">ppcre:create-scanner</span><span class="w"> </span><span class="nv">regexp</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">external-only</span>
<span class="w">        </span><span class="p">(</span><span class="nf">do-external-symbols</span><span class="w"> </span><span class="p">(</span><span class="nf">sym</span><span class="w"> </span><span class="nv">package</span><span class="w"> </span><span class="nv">symbols</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">regexp?</span><span class="w"> </span><span class="p">(</span><span class="nf">sym-match-regexp-p</span><span class="w"> </span><span class="nv">regexp</span><span class="w"> </span><span class="nv">sym</span><span class="p">)</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="nf">funcall</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">sym</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="nv">symbols</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">do-symbols</span><span class="w"> </span><span class="p">(</span><span class="nf">sym</span><span class="w"> </span><span class="nv">package</span><span class="w"> </span><span class="nv">symbols</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">no-other-package</span><span class="w"> </span><span class="p">(</span><span class="nf">sym-in-package-p</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="nv">package</span><span class="p">)</span><span class="w">  </span><span class="nv">t</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">regexp?</span><span class="w">          </span><span class="p">(</span><span class="nf">sym-match-regexp-p</span><span class="w"> </span><span class="nv">regexp</span><span class="w"> </span><span class="nv">sym</span><span class="p">)</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="nf">funcall</span><span class="w"> </span><span class="nv">test</span><span class="w"> </span><span class="nv">sym</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="nv">symbols</span><span class="p">))))))</span>
</pre></div>
  <details><summary>于是可以去寻找函数</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">find-package-symbols</span><span class="w"> </span><span class="nv">:package</span><span class="w"> </span><span class="nv">:objc</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;fboundp</span><span class="p">)</span>
</pre></div>
    <p>可以发现函数名称类似于:</p>
<div class="highlight"><pre><span></span><span class="nv">OBJC::|invoke</span><span class="w"> </span><span class="p">(</span><span class="nf">FUNCTION</span><span class="w"> </span><span class="p">(</span><span class="nf">OBJC-OBJECT-POINTER</span><span class="w"> </span><span class="nv">SEL</span><span class="p">)</span><span class="w"> </span><span class="nv">INT</span><span class="p">)</span><span class="nv">|</span>
<span class="nv">OBJC::|invoke</span><span class="w"> </span><span class="p">(</span><span class="nf">FUNCTION</span><span class="w"> </span><span class="p">(</span><span class="nf">OBJC-OBJECT-POINTER</span><span class="w"> </span><span class="nv">SEL</span><span class="w"> </span><span class="nv">INT</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">SIGNED</span><span class="w"> </span><span class="nv">CHAR</span><span class="p">))</span><span class="nv">|</span>
<span class="nv">OBJC::|invoke</span><span class="w"> </span><span class="p">(</span><span class="nf">FUNCTION</span><span class="w"> </span><span class="p">(</span><span class="nf">OBJC-OBJECT-POINTER</span><span class="w"> </span><span class="nv">SEL</span><span class="w"> </span><span class="nv">SEL</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">SIGNED</span><span class="w"> </span><span class="nv">CHAR</span><span class="p">))</span><span class="nv">|</span>
</pre></div>
    <p>这样的看起来就是程序自动化生成的函数, 以及:</p>
<div class="highlight"><pre><span></span><span class="nv">OBJC::OBJECT_SETIVAR</span>
<span class="nv">OBJC::CLASS_GETCLASSMETHOD</span>
<span class="nv">OBJC::METHOD_GETNUMBEROFARGUMENTS</span>
<span class="nv">OBJC::CLASS_GETINSTANCEMETHOD</span>
<span class="nv">OBJC::OBJECT_GETIVAR</span>
</pre></div>
    <p>这样的看起来就是 FFI 绑定的函数, 以及:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">find-package-symbols</span><span class="w"> </span><span class="nv">:package</span><span class="w"> </span><span class="nv">:objc</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;boundp</span><span class="p">)</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="nv">OBJC::*METHOD-SIGNATURE-TABLE*</span>
<span class="nv">OBJC::*OBJC-LIBRARY-PATH*</span>
<span class="nv">OBJC::*POINTER-OBJC-OBJECTS*</span>
<span class="nv">OBJC::*ALLOW-NULL-POINTER-INVOKE*</span>
</pre></div>
    <p>这样看起来就是 cache table 之类的东西, 以及:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">find-package-symbols</span><span class="w"> </span><span class="nv">:package</span><span class="w"> </span><span class="nv">:objc</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">sym</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-class</span><span class="w"> </span><span class="nv">sym</span><span class="w"> </span><span class="nv">nil</span><span class="p">)))</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="nv">OBJC:STANDARD-OBJC-OBJECT</span>
<span class="nv">OBJC::OBJC-CLASS-INFO</span>
<span class="nv">OBJC::INTERNED-METHOD-SIGNATURE</span>
<span class="nv">OBJC::STRUCT-CONVERTER</span>
</pre></div>
    <p>这样类似 CLASS 的符号.</p>
  </details>
  </li>
  <li><code>func-disassemble-comments</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">func-disassemble-comments</span><span class="w"> </span><span class="p">(</span><span class="nf">function</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">capture</span><span class="w"> </span><span class="s">&quot;.*&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="s">&quot;Get a list of disassmble comments. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="nv">function</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="nv">line</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="p">(</span><span class="nf">str:lines</span><span class="w"> </span><span class="p">(</span><span class="nb">with-output-to-string</span><span class="w"> </span><span class="p">(</span><span class="nf">*standard-output*</span><span class="p">)</span>
<span class="w">                                 </span><span class="p">(</span><span class="nf">disassemble</span><span class="w"> </span><span class="nv">function</span><span class="p">)))</span>
<span class="w">        </span><span class="nv">for</span><span class="w"> </span><span class="nv">cmt</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">ppcre:register-groups-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">cmt</span><span class="p">)</span>
<span class="w">                      </span><span class="p">((</span><span class="nb">format</span><span class="w"> </span><span class="nv">nil</span>
<span class="w">                               </span><span class="o">#</span><span class="nv">+lispworks</span><span class="w"> </span><span class="s">&quot;;</span><span class="se">\\</span><span class="s">s*(~A)</span><span class="se">\\</span><span class="s">s*&quot;</span>
<span class="w">                               </span><span class="o">#</span><span class="nv">+sbcl</span><span class="w"> </span><span class="s">&quot;;[^;]*;</span><span class="se">\\</span><span class="s">s*(~A)</span><span class="se">\\</span><span class="s">s*&quot;</span>
<span class="w">                               </span><span class="nv">capture</span><span class="p">)</span>
<span class="w">                       </span><span class="nv">line</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nf">str:trim</span><span class="w"> </span><span class="nv">cmt</span><span class="p">))</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nv">cmt</span><span class="w"> </span><span class="nv">collect</span><span class="w"> </span><span class="nv">cmt</span><span class="p">))</span>
</pre></div>
  <details><summary>注: 为啥有这个函数</summary>
    <p>理论上你可以通过 <code>disassemble</code> 来看看 Lisp 函数的具体实现, 不过那也太
      麻烦了点&#8230; 毕竟没有人会喜欢阅读没有 <code>F5</code> 的汇编代码吧&#8230; 并且在
      LispWorks 中貌似并非直接编译到机器码? 也有可能是机器码, 但是我不是很
      熟就是了. 不过通过读 <code>;</code> 后面的注释文本倒是感觉有点可行性.</p>
    <p>比如对于 <code>objc:invoke</code> 函数, 可以看到其 commet 中包含
      <code>objc::invoke-into*</code>, 于是可以大胆猜测调用 <code>invoke</code> 过程中调用了
      <code>invoke-into*</code> 的函数 (也可以通过添加 <code>trace</code> 进一步确认).</p>
    <p>并且也可以用来确定 <code>objc::objc_getclass</code> 函数中有调用
      <code>#&lt;FLI::EXTERNAL-SYMBOL &quot;objc_getClass&quot; : addr = #x199F15EFC&gt;</code>,
      可以猜测其等效为 CFFI 中调用 <code>objc_getClass</code>.</p>
  </details>
  </li>
</ul>
<p>嗯, 有了这些简单的根据, 配合 LispWorks 的神一样的 Class Browser 和
  General Method Browser, 应该是比较容易进行分析逆向的. 同时也可以使用
  <code>disassemble</code>, <code>documentation</code> 配合分析, 这样的话会轻松一些&#8230;</p>
<details><summary>笑, 这让我想到了 IDA Pro&#8230; </summary>
<p>著名的逆向工具, IDA Pro, 据说每次破解版的释出都是被自己 (IDA Pro) 给逆
  向破解的. 笑. 虽然 LispWorks 的 Personal Edition 并没有携带很多的函数
  (估计是给 tree-shake 掉了, 比如 <code>deliver</code> 之类的). 但是携带的一些功能和
  模块, 比如 ObjC-bridge 和 CAPI 我觉得就可以通过这种方式来进行逆向尝试
  做兼容模拟.</p>
</details>
<details><summary>一些可视化的分析 CAPI 函数</summary>
<p>首先可以从 <code>disassemble</code> 的注释中找到所有类似于 symbol 形式的字符串, 然
  后把它们当作符号读进一个列表:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">func-disassemble-symbols</span><span class="w"> </span><span class="p">(</span><span class="nf">function</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">push</span><span class="w"> </span><span class="ss">&#39;pushnew</span><span class="p">))</span>
<span class="w">  </span><span class="s">&quot;Get a list of disassemble comments symbols. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">symbols</span><span class="w"> </span><span class="p">()))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">sym</span>
<span class="w">             </span><span class="p">(</span><span class="nf">func-disassemble-comments</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="s">&quot;[a-zA-Z]+:{1,2}[a-zA-Z%</span><span class="se">\\</span><span class="s">*</span><span class="se">\\</span><span class="s">-</span><span class="se">\\</span><span class="s">_]+&quot;</span><span class="p">)</span>
<span class="w">             </span><span class="nv">symbols</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">ignore-errors</span>
<span class="w">        </span><span class="p">(</span><span class="k">case</span><span class="w"> </span><span class="nv">push</span>
<span class="w">          </span><span class="p">(</span><span class="nf">push</span><span class="w">    </span><span class="p">(</span><span class="nf">push</span><span class="w">    </span><span class="p">(</span><span class="nf">read-from-string</span><span class="w"> </span><span class="nv">sym</span><span class="p">)</span><span class="w"> </span><span class="nv">symbols</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">pushnew</span><span class="w"> </span><span class="p">(</span><span class="nf">pushnew</span><span class="w"> </span><span class="p">(</span><span class="nf">read-from-string</span><span class="w"> </span><span class="nv">sym</span><span class="p">)</span><span class="w"> </span><span class="nv">symbols</span><span class="p">)))))))</span>
</pre></div>
<p>于是可以定义一个简单的 CAPI interface:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">capi:define-interface</span><span class="w"> </span><span class="nv">disassemble-comment-tree</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">((</span><span class="nf">root-func</span><span class="w"> </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:root-func</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nf">all-nodes</span><span class="w"> </span><span class="nv">:initform</span><span class="w"> </span><span class="p">())</span>
<span class="w">   </span><span class="p">(</span><span class="nf">pkgs</span><span class="w">      </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:pkgs</span><span class="w"> </span><span class="nv">:initform</span><span class="w"> </span><span class="p">()))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:panes</span>
<span class="w">   </span><span class="p">(</span><span class="nf">tree</span><span class="w"> </span><span class="nv">capi:graph-pane</span>
<span class="w">         </span><span class="nv">:roots</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">listp</span><span class="w"> </span><span class="nv">root-func</span><span class="p">)</span><span class="w"> </span><span class="nv">root-func</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">root-func</span><span class="p">))</span>
<span class="w">         </span><span class="nv">:font</span><span class="w"> </span><span class="p">(</span><span class="nf">gp:make-font-description</span><span class="w"> </span><span class="nv">:size</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span>
<span class="w">         </span><span class="nv">:children-function</span>
<span class="w">         </span><span class="o">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nf">fboundp</span><span class="w"> </span><span class="nv">func</span><span class="p">)</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">find</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">all-nodes</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">find-if</span><span class="w"> </span><span class="o">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">pkg</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">sym-in-package-p</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">pkg</span><span class="p">))</span><span class="w"> </span><span class="nv">pkgs</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="nf">pushnew</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">all-nodes</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nf">func-disassemble-symbols</span><span class="w"> </span><span class="p">(</span><span class="nf">symbol-function</span><span class="w"> </span><span class="nv">func</span><span class="p">))))</span>
<span class="w">         </span><span class="nv">:print-function</span><span class="w"> </span><span class="o">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">func</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="s">&quot;~S&quot;</span><span class="w"> </span><span class="nv">func</span><span class="p">))))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:layouts</span>
<span class="w">   </span><span class="p">(</span><span class="nf">default-layout</span><span class="w"> </span><span class="nv">capi:simple-layout</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">tree</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:default-initargs</span>
<span class="w">   </span><span class="nv">:title</span><span class="w"> </span><span class="s">&quot;Disassemble Comment Tree&quot;</span><span class="p">))</span>
</pre></div>
<p>于是可以有:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">analyze-disassmble-func-comments</span><span class="w"> </span><span class="p">(</span><span class="nf">func</span><span class="w"> </span><span class="nv">&amp;key</span><span class="w"> </span><span class="p">(</span><span class="nf">pkgs</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">:objc</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nb">symbol</span><span class="w"> </span><span class="nv">func</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">capi:display</span><span class="w"> </span><span class="p">(</span><span class="nf">make-instance</span><span class="w"> </span><span class="ss">&#39;disassemble-comment-tree</span><span class="w"> </span><span class="nv">:root-func</span><span class="w"> </span><span class="nv">func</span><span class="w"> </span><span class="nv">:pkgs</span><span class="w"> </span><span class="nv">pkgs</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">analyze-disassmble-func-comments</span>
<span class="w"> </span><span class="o">&#39;</span><span class="p">(</span>
<span class="w">   </span><span class="nv">objc:coerce-to-objc-class</span>
<span class="w">   </span><span class="nv">objc:coerce-to-selector</span>
<span class="w">   </span><span class="p">))</span>
</pre></div>
<p>这样的可以绘制出调用树, 于是可以适当折叠, 类似如下效果:</p>
<p><img src="/_img/lisp/objc/analyze-disassmble-func-comments.png" alt="/_img/lisp/objc/analyze-disassmble-func-comments.png" /></p>
</details>
<h3>一些函数的 Wrapping</h3>
<ul>
  <li><code>coerce-to-objc-class</code>
    <p>使用 <code>func-disassemble-comments</code> 可以得知其包含如下的 comments:</p>
    <pre class="example">
OBJC::INTERNED-OBJC-CLASS-P
OBJC::RESOLVE-CLASS
SYSTEM::*%WRONG-NUMBER-OF-ARGUMENTS-STUB
OBJC::INTERN-CLASS
OBJC::RESOLVE-CLASS
FLI:POINTER-POINTER-TYPE
OBJC:OBJC-CLASS
:POINTER-TYPE
OBJC:OBJC-CLASS
FLI:COPY-POINTER
    </pre>
    <p>其中 <code>OBJC::INTERN-CLASS</code> 的 comments 如下:</p>
    <pre class="example">
OBJC::*CLASS-TABLE*
OBJC::*CLASS-TABLE*
#&lt;structure descriptor: INTERNED-OBJC-CLASS&gt;
SYSTEM::%STRUCTURE-ALLOCATE
    </pre>
    <p>这里猜测和之前我的 <code>defun-cached</code> 的想法应该是一样的, 用
      <code>OBJC::*CLASS-TABLE*</code> 来实现 cache.</p>
    <p>继续跟踪会发现 <code>objc::objc_getclass</code> 是在 <code>objc::resolve-class</code> 中调用的.
      (或者可以通过 <code>(trace objc::objc_getclass)</code> 然后调用
      <code>(objc:coerce-to-objc-class &quot;NSString&quot;)</code> 来进行跟踪.</p>
  <details><summary>我的实现</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*class-table*</span><span class="w"> </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="ss">&#39;equal</span><span class="p">))</span>

<span class="p">(</span><span class="nf">defstruct</span><span class="w"> </span><span class="p">(</span><span class="nf">interned-objc-class</span><span class="w"> </span><span class="p">(</span><span class="nf">:conc-name</span><span class="w"> </span><span class="nv">interned-objc-class-</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">name</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="nb">string</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">obj</span><span class="w">  </span><span class="nv">nil</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="nv">objc-pointer</span><span class="p">))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">intern-class</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">*class-table*</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">*class-table*</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">ptr</span><span class="w"> </span><span class="p">(</span><span class="nf">objc_getclass</span><span class="w"> </span><span class="nv">name</span><span class="p">)))</span>
<span class="w">              </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">null-objc-pointer-p</span><span class="w"> </span><span class="nv">ptr</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Cannot find class ~S. &quot;</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">make-interned-objc-class</span><span class="w"> </span><span class="nv">:name</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">:obj</span><span class="w"> </span><span class="nv">ptr</span><span class="p">))))))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">coerce-to-objc-class</span><span class="w"> </span><span class="p">(</span><span class="nf">class</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">interned-objc-class-p</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">interned-objc-class-obj</span><span class="w"> </span><span class="nv">class</span><span class="p">))</span>
<span class="w">        </span><span class="p">((</span><span class="nf">stringp</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span><span class="w">               </span><span class="p">(</span><span class="nf">interned-objc-class-obj</span><span class="w"> </span><span class="p">(</span><span class="nf">intern-class</span><span class="w"> </span><span class="nv">class</span><span class="p">)))</span>
<span class="w">        </span><span class="p">((</span><span class="nf">objc-class-pointer-p</span><span class="w">  </span><span class="nv">class</span><span class="p">)</span><span class="w"> </span><span class="nv">class</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">T</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Cannot coerce ~S to ~S with type ~S. &quot;</span>
<span class="w">                  </span><span class="nv">class</span><span class="w"> </span><span class="ss">&#39;objc-pointer</span><span class="w"> </span><span class="ss">&#39;objc-class</span><span class="p">))))</span>
</pre></div>
    <p>这里我没有使用 <code>resolve-class</code> (在 LispWorks 中有这个函数). 目前并没有
      看出 <code>resolve-class</code> 的用处是啥.</p>
    <p>以及为啥不直接使用 <code>objc-pointer</code> 来作为 <code>*class-table*</code> 的值, 而是需要
      用一个 <code>interned-objc-class</code> 结构做储存? 我觉得可以&#8230;</p>
  </details>
  </li>
  <li><code>objc:coerce-to-selector</code> 实现同上</li>
</ul>
<p>既然都知道了 <code>[]</code> 就是 <code>obj_msgSend(*, SEL, ...)</code>, 所以可以做一个非常简单
  的操作:</p>
<div class="highlight"><pre><span></span><span class="c1">;; [NSString stringWithUTF8String: &quot;测试&quot;]</span>
<span class="p">(</span><span class="nf">cffi:foreign-funcall</span><span class="w"> </span><span class="s">&quot;objc_msgSend&quot;</span>
<span class="w">                      </span><span class="nv">objc-class</span><span class="w"> </span><span class="p">(</span><span class="nf">objc:coerce-to-objc-class</span><span class="w"> </span><span class="s">&quot;NSString&quot;</span><span class="p">)</span>
<span class="w">                      </span><span class="nv">sel</span><span class="w">        </span><span class="p">(</span><span class="nf">objc:coerce-to-objc-class</span><span class="w"> </span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="p">)</span>
<span class="w">                      </span><span class="nv">:string</span><span class="w">    </span><span class="s">&quot;测试&quot;</span>
<span class="w">                      </span><span class="nv">objc-object-pointer</span><span class="p">)</span>
</pre></div>
<p>目标是实现类似于: <code>(invoke &quot;NSString&quot; &quot;stringWithUTF8String:&quot; &quot;测试&quot;)</code>
  这样的功能. 为了实现这个目标, 只有两个 <code>coerce-to-*</code> 函数还是不够的&#8230;
  不过思路是这样的: 通过 <code>receiver</code> 和 <code>sel</code> 来确定函数的入参和返回值, 然后
  自动生成 <code>cffi:foreign-funcall</code> 的结构, 最后实现 <code>invoke</code>.</p>
<h3>Detour: Method Signature</h3>
<p>即如何自动确定函数的入参和返回值? 答案是通过 <code>method_getTypeEncoding</code> 得
  到类似于 =&#8221;@24@0:8r*16&#8221;= 这样的表示. 其结构在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">官方文档 Type Encoding</a> 中
  亦有记载. 我写了一个比较丑陋的 parser 来处理这个, 将其映射成一个 CFFI
  type list, 类似如下:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">objc-object-pointer</span><span class="w"> </span><span class="nv">objc-object-pointer</span><span class="w"> </span><span class="nv">sel</span><span class="w"> </span><span class="p">(</span><span class="nf">:const</span><span class="w"> </span><span class="nv">:string</span><span class="p">))</span>
</pre></div>
<details><summary>我的丑陋 parser</summary>
<p>至少我让 DeepSeek 给我生成了几个测试用的 type encoding 都没有什么问题,
  可以正常解析. (不过发现 DeepSeek 的括号闭合能力其实并不是很强, 有些时
  候会生成不闭合的括号对. )</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">decode-encoded-type</span><span class="w"> </span><span class="p">(</span><span class="nf">encoding</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nb">string</span><span class="w"> </span><span class="nv">encoding</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">encoding</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">pos</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">labels</span><span class="w"> </span><span class="p">((</span><span class="nf">parse-num</span><span class="w"> </span><span class="p">()</span>
<span class="w">               </span><span class="p">(</span><span class="nf">multiple-value-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">num</span><span class="w"> </span><span class="nv">next-pos</span><span class="p">)</span>
<span class="w">                   </span><span class="p">(</span><span class="nf">parse-integer</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">:start</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">:junk-allowed</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">num</span><span class="w"> </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">next-pos</span><span class="p">)</span><span class="w"> </span><span class="nv">num</span><span class="p">)))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">parse-name</span><span class="w"> </span><span class="p">()</span>
<span class="w">               </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span>
<span class="w">                     </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">                                </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">char</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">)))</span>
<span class="w">                                  </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nf">char/=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\=</span><span class="p">)</span>
<span class="w">                                       </span><span class="p">(</span><span class="nf">char/=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\)</span><span class="p">)</span>
<span class="w">                                       </span><span class="p">(</span><span class="nf">char/=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="o">#</span><span class="err">\}</span><span class="p">))))</span>
<span class="w">                     </span><span class="nv">finally</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="p">(</span><span class="nf">subseq</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">pos</span><span class="p">))))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">parse-method-type</span><span class="w"> </span><span class="p">()</span>
<span class="w">               </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">char</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\r</span><span class="p">)</span><span class="w"> </span><span class="nv">:const</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\n</span><span class="p">)</span><span class="w"> </span><span class="nv">:in</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\N</span><span class="p">)</span><span class="w"> </span><span class="nv">:inout</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\o</span><span class="p">)</span><span class="w"> </span><span class="nv">:out</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\O</span><span class="p">)</span><span class="w"> </span><span class="nv">:bycopy</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\R</span><span class="p">)</span><span class="w"> </span><span class="nv">:byref</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">char</span><span class="w"> </span><span class="sc">#\V</span><span class="p">)</span><span class="w"> </span><span class="nv">:oneway</span><span class="p">)))</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">val</span><span class="w">  </span><span class="p">(</span><span class="nf">progn</span><span class="w"> </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-type</span><span class="p">))))</span>
<span class="w">                   </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">val</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="nv">val</span><span class="p">)))))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">parse-type</span><span class="w"> </span><span class="p">()</span>
<span class="w">               </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">char</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\c</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:char</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\i</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\s</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:short</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\l</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:long</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\q</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:long-long</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\C</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:unsigned-char</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\I</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:unsigned-int</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\S</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:unsigned-short</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\L</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:unsigned-long</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\Q</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:unsigned-long-long</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\f</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:float</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\d</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:double</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\B</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:bool</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\v</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:void</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\</span><span class="nb">*</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:string</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\</span><span class="k">@</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;objc-object-pointer</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\</span><span class="o">#</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;objc-class</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\</span><span class="nv">:</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="ss">&#39;sel</span><span class="p">)</span>
<span class="w">                                    </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\?</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="nv">:objc-unknown</span><span class="p">))))</span>
<span class="w">                   </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w">             </span><span class="c1">;; parse simple type</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-num</span><span class="p">)</span><span class="w"> </span><span class="c1">;; trim tailing number</span>
<span class="w">                          </span><span class="nv">type</span><span class="p">)</span>
<span class="w">                         </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\</span><span class="p">[</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="c1">;; parse array</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span>
<span class="w">                          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">size</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-num</span><span class="p">))</span>
<span class="w">                                </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-type</span><span class="p">)))</span>
<span class="w">                            </span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="p">(</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Malfromed type encoding: ~S, missing `]&#39; at index ~D. &quot;</span>
<span class="w">                                     </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                            </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-num</span><span class="p">)</span><span class="w"> </span><span class="c1">;; trim tailing number</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;objc-array</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="nv">type</span><span class="p">)))</span>
<span class="w">                         </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\{</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="c1">;; parse struct</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span>
<span class="w">                          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">name</span><span class="w">  </span><span class="p">(</span><span class="nf">parse-name</span><span class="p">))</span>
<span class="w">                                </span><span class="p">(</span><span class="nf">types</span><span class="w"> </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\=</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                                              </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-type*</span><span class="p">))</span>
<span class="w">                                             </span><span class="p">(</span><span class="nf">T</span><span class="w"> </span><span class="nv">nil</span><span class="p">))))</span>
<span class="w">                            </span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="p">(</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\}</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Malfromed type encoding: ~S, missing `}&#39; at index ~D. &quot;</span>
<span class="w">                                     </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                            </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-num</span><span class="p">)</span><span class="w"> </span><span class="c1">;; trim tailing number</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;objc-struct</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">types</span><span class="p">)))</span>
<span class="w">                         </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\(</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="c1">;; parse union</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span>
<span class="w">                          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">name</span><span class="w">  </span><span class="p">(</span><span class="nf">parse-name</span><span class="p">))</span>
<span class="w">                                </span><span class="p">(</span><span class="nf">types</span><span class="w"> </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\=</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                                              </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-type*</span><span class="p">))</span>
<span class="w">                                             </span><span class="p">(</span><span class="nf">T</span><span class="w"> </span><span class="nv">nil</span><span class="p">))))</span>
<span class="w">                            </span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="p">(</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\)</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Malfromed type encoding: ~S, missing `)&#39; at index ~D. &quot;</span>
<span class="w">                                     </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                            </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-num</span><span class="p">)</span><span class="w"> </span><span class="c1">;; trim tailing number</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;objc-union</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">types</span><span class="p">)))</span>
<span class="w">                         </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="sc">#\b</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="c1">;; parse bitfield</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span>
<span class="w">                          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">num</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-num</span><span class="p">)))</span>
<span class="w">                            </span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="nv">num</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Malfromed type encoding: ~S, missing bitfield number at index ~D. &quot;</span>
<span class="w">                                     </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">&#39;objc-bitfield</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-num</span><span class="p">))))</span>
<span class="w">                         </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="o">#</span><span class="err">\</span><span class="nv">^</span><span class="w"> </span><span class="nv">char</span><span class="p">)</span><span class="w"> </span><span class="c1">;; parse pointer</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">incf</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span>
<span class="w">                          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-type</span><span class="p">)))</span>
<span class="w">                            </span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="nv">type</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Malfromed type encoding: ~S, missing pointer type at index ~D. &quot;</span>
<span class="w">                                     </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">                            </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-type</span><span class="p">))))))))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">parse-method-type*</span><span class="w"> </span><span class="p">()</span>
<span class="w">               </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-method-type</span><span class="p">)</span>
<span class="w">                     </span><span class="k">while</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">collect</span><span class="w"> </span><span class="nv">type</span><span class="p">))</span>
<span class="w">             </span><span class="p">(</span><span class="nf">parse-type*</span><span class="w"> </span><span class="p">()</span>
<span class="w">               </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-type</span><span class="p">)</span>
<span class="w">                     </span><span class="k">while</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">collect</span><span class="w"> </span><span class="nv">type</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-method-type*</span><span class="p">)))</span>
<span class="w">        </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">pos</span><span class="w"> </span><span class="nv">len</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Unknown encoding ~S character `~C&#39; at index ~D. &quot;</span>
<span class="w">                 </span><span class="nv">encoding</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">encoding</span><span class="w"> </span><span class="nv">pos</span><span class="p">)</span><span class="w"> </span><span class="nv">pos</span><span class="p">))</span>
<span class="w">        </span><span class="nb">list</span><span class="p">))))</span>
</pre></div>
</details>
<h3>Detour: CFFI types</h3>
<p>即如何拓展 CFFI 的标准类型来支持类似于 <code>objc-object-pointer</code> 这样的类型.
  在 LispWorks 的 FLI:Pointer 里面有类型的提示 (不知道是不是自动推断的).
  不过要模拟也非常容易:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defstruct</span><span class="w"> </span><span class="nv">objc-pointer</span>
<span class="w">  </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="nb">symbol</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">ptr</span><span class="w">  </span><span class="nv">nil</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="nv">foreign-pointer</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-foreign-type</span><span class="w"> </span><span class="nv">%objc-pointer</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">((</span><span class="nf">type</span><span class="w"> </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:type</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:actual-type</span><span class="w"> </span><span class="nv">:pointer</span><span class="p">))</span>

<span class="p">(</span><span class="nf">define-parse-method</span><span class="w"> </span><span class="nv">objc-pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;optional</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">make-instance</span><span class="w"> </span><span class="ss">&#39;%objc-pointer</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="nv">type</span><span class="p">))</span>

<span class="p">(</span><span class="nf">defmethod</span><span class="w"> </span><span class="nv">translate-to-foreign</span><span class="w"> </span><span class="p">(</span><span class="nf">pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">%objc-pointer</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">objc-pointer-ptr</span><span class="w"> </span><span class="nv">pointer</span><span class="p">))</span>

<span class="p">(</span><span class="nf">defmethod</span><span class="w"> </span><span class="nv">translate-from-foreign</span><span class="w"> </span><span class="p">(</span><span class="nf">pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">%objc-pointer</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">make-objc-pointer</span><span class="w"> </span><span class="nv">:type</span><span class="w"> </span><span class="p">(</span><span class="nf">slot-value</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="ss">&#39;type</span><span class="p">)</span><span class="w"> </span><span class="nv">:ptr</span><span class="w"> </span><span class="nv">pointer</span><span class="p">))</span>
</pre></div>
<p>就是这么简单喵.</p>
<details><summary>如果我用这种方式来构造 wrapper? </summary>
<p>这里有一个想法, 如果我给 <code>translate-to-foreign</code> 同样来点类似于
  <code>coerce-to-objc-class</code> 这样的判断, 会不会更好玩一些?</p>
</details>
<h3>Invoke</h3>
<p>这里做了一个我觉得挺有意思的操作, 就是根据 signature 自动生成
  <code>CFFI:FOREIGN-FUNCALL</code> 表达式:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">cffi-lambda-form-from-method-signature</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span><span class="w"> </span><span class="nv">arg-types</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Generate CFFI lambda form from given ObjC signature. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">arg-types</span>
<span class="w">        </span><span class="nv">for</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nf">listp</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">                </span><span class="c1">;; Note: not knowing what to do with ObjC method description</span>
<span class="w">                </span><span class="p">(</span><span class="nb">member</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">:const</span><span class="w"> </span><span class="nv">:in</span><span class="w"> </span><span class="nv">:out</span><span class="w"> </span><span class="nv">:inout</span><span class="w"> </span><span class="nv">:out</span>
<span class="w">                                       </span><span class="nv">:bycopy</span><span class="w"> </span><span class="nv">:byref</span><span class="w"> </span><span class="nv">:oneway</span><span class="p">)))</span>
<span class="w">          </span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">call-args</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nv">collect</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">call-args</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">          </span><span class="nv">collect</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">call-args</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="nv">collect</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">call-args</span>
<span class="w">        </span><span class="nv">collect</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">args</span>
<span class="w">        </span><span class="nv">finally</span><span class="w"> </span><span class="p">(</span><span class="nf">return</span>
<span class="w">                  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">receiver</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nf">sel</span><span class="w">      </span><span class="p">(</span><span class="nb">gensym</span><span class="p">)))</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">eval</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nv">receiver</span><span class="w"> </span><span class="o">,</span><span class="nv">sel</span><span class="w"> </span><span class="o">,@</span><span class="nv">args</span><span class="p">)</span>
<span class="w">                             </span><span class="p">(</span><span class="nf">foreign-funcall</span><span class="w"> </span><span class="s">&quot;objc_msgSend&quot;</span>
<span class="w">                                              </span><span class="nv">objc-pointer</span><span class="w"> </span><span class="o">,</span><span class="nv">receiver</span>
<span class="w">                                              </span><span class="nv">sel</span><span class="w">          </span><span class="o">,</span><span class="nv">sel</span>
<span class="w">                                              </span><span class="o">,@</span><span class="nv">call-args</span>
<span class="w">                                              </span><span class="o">,</span><span class="nv">return</span><span class="p">)))))))</span>
</pre></div>
<p>于是 <code>invoke-into*</code> 的实现即可如下:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">invoke-into*</span><span class="w"> </span><span class="p">(</span><span class="nf">result</span><span class="w"> </span><span class="nv">pointer-or-class-name</span><span class="w"> </span><span class="nv">method</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nb">string</span><span class="w"> </span><span class="nv">objc-pointer</span><span class="p">)</span><span class="w"> </span><span class="nv">pointer-or-class-name</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nb">string</span><span class="w"> </span><span class="nb">list</span><span class="p">)</span><span class="w"> </span><span class="nv">method</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">selector</span><span class="w"> </span><span class="p">(</span><span class="nf">coerce-to-selector</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">listp</span><span class="w"> </span><span class="nv">method</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">method</span><span class="p">)</span><span class="w"> </span><span class="nv">method</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">receiver</span><span class="w"> </span><span class="p">(</span><span class="nf">etypecase</span><span class="w"> </span><span class="nv">pointer-or-class-name</span>
<span class="w">                     </span><span class="p">(</span><span class="nb">string</span><span class="w">       </span><span class="p">(</span><span class="nf">intern-class</span><span class="w"> </span><span class="nv">pointer-or-class-name</span><span class="p">))</span>
<span class="w">                     </span><span class="p">(</span><span class="nf">objc-pointer</span><span class="w"> </span><span class="nv">pointer-or-class-name</span><span class="p">)))</span>
<span class="w">         </span><span class="p">(</span><span class="nf">method*</span><span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-class-pointer-p</span><span class="w"> </span><span class="nv">receiver</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="nf">class_getClassMethod</span><span class="w"> </span><span class="nv">receiver</span><span class="w"> </span><span class="nv">selector</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="nf">class_getInstanceMethod</span><span class="w"> </span><span class="p">(</span><span class="nf">object_getClass</span><span class="w"> </span><span class="nv">receiver</span><span class="p">)</span><span class="w"> </span><span class="nv">selector</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">null-objc-pointer-p</span><span class="w"> </span><span class="nv">method*</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Cannot invoke method ~S on ~S. &quot;</span>
<span class="w">             </span><span class="nv">method</span><span class="w"> </span><span class="nv">pointer-or-class-name</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">signature</span><span class="w"> </span><span class="p">(</span><span class="nf">intern-method-signature</span><span class="w"> </span><span class="nv">method*</span><span class="p">)))</span>
<span class="w">      </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">listp</span><span class="w"> </span><span class="nv">method</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Not imeplement yet... &quot;</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nf">result</span>
<span class="w">             </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="nf">cffi-lambda-form-from-method-signature</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="p">(</span><span class="nb">cdddr</span><span class="w"> </span><span class="nv">signature</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">receiver</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">selector</span><span class="w"> </span><span class="nv">args</span><span class="p">))))</span>
<span class="w">            </span><span class="p">(</span><span class="nf">T</span>
<span class="w">             </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-pointer-addr</span><span class="w"> </span><span class="nv">method*</span><span class="p">)</span><span class="w"> </span><span class="nv">*invoke-fuction-table*</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">receiver</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">selector</span><span class="w"> </span><span class="nv">args</span><span class="p">))))))))</span>
</pre></div>
<h1>The End</h1>
<p>不多说了:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">foreign-funcall</span><span class="w"> </span><span class="s">&quot;NSLog&quot;</span>
<span class="w">                 </span><span class="nv">objc-pointer</span><span class="w"> </span><span class="p">(</span><span class="nf">invoke</span><span class="w"> </span><span class="s">&quot;NSString&quot;</span><span class="w"> </span><span class="s">&quot;stringWithUTF8String:&quot;</span><span class="w"> </span><span class="s">&quot;测试&quot;</span><span class="p">)</span>
<span class="w">                 </span><span class="nv">:void</span><span class="p">)</span>
</pre></div>
<p>你在 <code>*sly-inferior-lisp for sbcl*</code> buffer 中应当能看到:</p>
<pre class="example">
2025-04-05 02:47:39.644 sbcl[75196:28411918] 测试
</pre>
<p>类似的效果.</p>
<p>接下来要做的估计就是 CFFI type 的 wrapping 以及错误处理等故障的解决了.</p>]]></content><author><name></name></author><category term="lisp" /><summary type="html"><![CDATA[About 之前的活 (ObjC 0: WebDriver Download ObjC Runtime Documentation) 的下 一部分就该轮到写一些简单的 Objective-C 的代码了. 但是问题是: 我好像从 来没有写过 ObjC 的代码&#8230; 所以这里会参考 Silicon.h 和 RGFW Under the Hood: Cocoa in Pure C 中的 方案尝试只使用 C-side (即 ObjC Runtime) 来调用 Objective-C 的部分. 同 时借鉴 Ry’s Objective-C Tutorial 用于测试 ObjC Runtime 的 binding 是否 可用. ObjC to C, then, CFFI, to Lisp Simple main() 示例代码来自 Ry's Objective-C: #import &lt;Foundation/Foundation.h&gt;]]></summary></entry><entry><title type="html">ObjC 0: WebDriver Download ObjC Runtime Documentation</title><link href="/lisp/objc-0-webdriver-download-objc-doc/" rel="alternate" type="text/html" title="ObjC 0: WebDriver Download ObjC Runtime Documentation" /><published>2025-03-31T00:00:00+00:00</published><updated>2025-03-31T00:00:00+00:00</updated><id>/lisp/objc-0-webdriver-download-objc-doc</id><content type="html" xml:base="/lisp/objc-0-webdriver-download-objc-doc/"><![CDATA[<h1>About</h1>
<p>记录一下我尝试复刻 objectvie-c-bridge (参考的是 LispWorks 的 <a href="https://www.lispworks.com/documentation/pdf/lw80/objc-8-0.pdf">API</a>,
  CCL 也有一个 <a href="https://ccl.clozure.com/manual/chapter14.html#The-Objective-C-Bridge">objective-c-bridge</a>, 但是因为 CCL arm port 目前是缺失的,
  所以我没法在我的电脑上面测试其表现, 我不是一个善于读文档的人).</p>
<p>注: 因为我做这个的目标完全只是为了不花钱去买 LispWorks 的 Licence,
  以及给比较无聊的生活加点乐子和非游戏的打发时间的事做. 所以该项目在我能
  被批准用学校的钱去购买 Licence 或者很忙的情况下就会被中断.</p>
<p>目前我的计划是这样的:</p>
<ol>
  <li>用 CFFI 建立 Objcective-C Runtime 的一个绑定</li>
  <li>去了解一下 Objective-C Runtime 该怎么 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">编写</a></li>
  <li>去模拟 LispWorks 的 ObjC 的函数</li>
  <li>去添加其他的库, 或者做一些高层的 wrapping 之类的</li>
  <li>去尝试实现 CLIM 的 backend 或者模拟 CAPI 的 API?</li>
</ol>
<p>这估计会是一个跨越时间非常长的项目了&#8230;</p>
<p>不过这个 post 的主要内容是如何从苹果的官网上把文档给爬下来, 并解析成
  CFFI 可以使用的形式. 其中使用了我对之前 <a href="/lisp/lisp-webdriver-macros/">WebDriver</a> 协议的一个小小改进
  版本的代码 (<a href="https://gist.github.com/li-yiyang/e777ea711e39c554703f520ff7c75f34">gist</a>).</p>
<details><summary>一些基于 WebDriver 库的小小 wrapper</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">map-find-elems</span><span class="w"> </span><span class="p">((</span><span class="nf">elem</span><span class="w"> </span><span class="nv">selector</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">node</span><span class="w"> </span><span class="ss">&#39;*session*</span><span class="p">))</span>
<span class="w">                          </span><span class="nv">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="o">,</span><span class="nv">elem</span><span class="p">)</span><span class="w"> </span><span class="o">,@</span><span class="nv">body</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:find-elems</span><span class="w"> </span><span class="o">,</span><span class="nv">node</span><span class="w"> </span><span class="o">,</span><span class="nv">selector</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">find-text</span><span class="w"> </span><span class="p">(</span><span class="nf">selector</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">node</span><span class="w"> </span><span class="nv">*session*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">retry</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wait</span><span class="w"> </span><span class="mf">1.0</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">handler-case</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:text</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:find-elem</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">selector</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">wd::webdriver-error</span><span class="w"> </span><span class="p">(</span><span class="nf">err</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">&gt;</span><span class="w"> </span><span class="nv">retry</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">sleep</span><span class="w"> </span><span class="nv">wait</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nf">find-text</span><span class="w"> </span><span class="nv">selector</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">retry</span><span class="p">)</span><span class="w"> </span><span class="nv">wait</span><span class="p">))</span>
<span class="w">            </span><span class="p">(</span><span class="nf">T</span>
<span class="w">             </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="nv">err</span><span class="p">))))))</span>
</pre></div>
</details>
<h1>Objective-C 文档的读取</h1>
<p>新建一个 WebDriver Session:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*session*</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:make-webdriver-session</span><span class="p">))</span>
</pre></div>
<p>然后访问苹果 Objective-C Runtime 的网页:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">wd:navigate</span><span class="w"> </span><span class="nv">*session*</span><span class="w"> </span><span class="s">&quot;https://developer.apple.com/documentation/objectivec/objective-c-runtime?language=objc&quot;</span><span class="p">)</span>
</pre></div>
<h2>Section</h2>
<p>其被分隔成多个 section, 于是可以提取到 <code>sections</code> 中, 并提取每章的子文档
  的链接用于之后分章节进行实现:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">sections</span>
<span class="w">  </span><span class="p">(</span><span class="nf">map-find-elems</span><span class="w"> </span><span class="p">(</span><span class="nf">section</span><span class="w"> </span><span class="s">&quot;div.contenttable-section&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nf">find-text</span><span class="w"> </span><span class="s">&quot;h3.contenttable-title&quot;</span><span class="w"> </span><span class="nv">section</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nf">map-find-elems</span><span class="w"> </span><span class="p">(</span><span class="nb">link</span><span class="w"> </span><span class="s">&quot;a:not(.deprecated):has(code)&quot;</span><span class="w"> </span><span class="nv">section</span><span class="p">)</span>
<span class="w">            </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:text</span><span class="w"> </span><span class="nb">link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:property</span><span class="w"> </span><span class="nb">link</span><span class="w"> </span><span class="s">&quot;href&quot;</span><span class="p">))))))</span>
</pre></div>
<p>注: 这里用 <code>:has(code)</code> 的 CSS selector 来选择是子节点 <code>code</code> 类型的链接而
  不是链接到其他的说明文档去.</p>
<p>类似如下:</p>
<table>
  <tr><td>Section</td><td>Links Counts</td></tr>
  <tr><td>Working with Classes</td><td>30</td></tr>
  <tr><td>Adding Classes</td><td>5</td></tr>
  <tr><td>Instantiating Classes</td><td>3</td></tr>
  <tr><td>Working with Instances</td><td>10</td></tr>
  <tr><td>Obtaining Class Definitions</td><td>6</td></tr>
  <tr><td>Working with Instance Variables</td><td>3</td></tr>
  <tr><td>Associative References</td><td>3</td></tr>
  <tr><td>Sending Messages</td><td>5</td></tr>
  <tr><td>Working with Methods</td><td>13</td></tr>
  <tr><td>Working with Libraries</td><td>3</td></tr>
  <tr><td>Working with Selectors</td><td>4</td></tr>
  <tr><td>Working with Protocols</td><td>15</td></tr>
  <tr><td>Working with Properties</td><td>4</td></tr>
  <tr><td>Using Objective-C Language Features</td><td>9</td></tr>
  <tr><td>Class-Definition Data Structures</td><td>9</td></tr>
  <tr><td>Instance Data Types</td><td>3</td></tr>
  <tr><td>Boolean Value</td><td>1</td></tr>
  <tr><td>Associative References</td><td>1</td></tr>
  <tr><td>Constants</td><td>0</td></tr>
  <tr><td>Related Documentation</td><td>0</td></tr>
  <tr><td>Reference</td><td>0</td></tr>
</table>
<h2>Function, Type Alias, Structure</h2>
<p>对于单个文档, 例:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nb">link</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">section</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">sections</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">title</span><span class="w"> </span><span class="p">(</span><span class="nf">code</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">rest</span><span class="p">))</span><span class="w"> </span><span class="nv">section</span>
<span class="w">      </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">rest</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;;;; ~A~%&quot;</span><span class="w"> </span><span class="nv">title</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~A~%~A~%&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nv">code</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">code</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nv">code</span><span class="p">))))</span>
</pre></div>
<pre class="example">
;;; Working with Classes
class_getName
https://developer.apple.com/documentation/objectivec/class_getname(_:)?language=objc
</pre>
<p>其有一些比较有用的信息:</p>
<ul>
  <li><code>div.topictitle</code>: 类别和简要文档说明 <code>objc-doc-type</code>, <code>objc-doc-short</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-type</span><span class="w">  </span><span class="p">(</span><span class="nf">session</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-text</span><span class="w"> </span><span class="s">&quot;div.topictitle &gt; span&quot;</span><span class="w"> </span><span class="nv">session</span><span class="p">))</span>
<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-short</span><span class="w"> </span><span class="p">(</span><span class="nf">session</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-text</span><span class="w"> </span><span class="s">&quot;div.abstract&quot;</span><span class="w"> </span><span class="nv">session</span><span class="p">))</span>
</pre></div>
  </li>
  <li><code>pre.source &gt; code</code>: lambda list <code>objc-doc-lambda</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">session</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-text</span><span class="w"> </span><span class="s">&quot;pre.source &gt; code&quot;</span><span class="w"> </span><span class="nv">session</span><span class="p">))</span>
</pre></div>
    <p>例:</p>
    <pre class="example">
extern const char * class_getName(Class cls);
    </pre>
    <p>这里有一个比较有趣的事情是如何解析这个 <code>objc-lambda</code>.</p>
  </li>
  <li><code>#parameters</code>: 参数说明 <code>objc-doc-params</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-params</span><span class="w"> </span><span class="p">(</span><span class="nf">session</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">param</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:find-elems</span><span class="w"> </span><span class="nv">session</span><span class="w"> </span><span class="s">&quot;#parameters + dl&quot;</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">param</span>
<span class="w">      </span><span class="p">(</span><span class="nf">mapcar</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;cons</span>
<span class="w">              </span><span class="p">(</span><span class="nf">map-find-elems</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="w"> </span><span class="s">&quot;dt&quot;</span><span class="w"> </span><span class="nv">param</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nf">get-nickname</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:text</span><span class="w"> </span><span class="nv">name</span><span class="p">)))</span>
<span class="w">              </span><span class="p">(</span><span class="nf">map-find-elems</span><span class="w"> </span><span class="p">(</span><span class="nf">doc-paras</span><span class="w"> </span><span class="s">&quot;dd&quot;</span><span class="w"> </span><span class="nv">param</span><span class="p">)</span>
<span class="w">                </span><span class="p">(</span><span class="nf">map-find-elems</span><span class="w"> </span><span class="p">(</span><span class="nf">para</span><span class="w"> </span><span class="s">&quot;p&quot;</span><span class="w"> </span><span class="nv">doc-paras</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="nf">objc-doc-text</span><span class="w"> </span><span class="nv">para</span><span class="p">)))))))</span>
</pre></div>
    <p>例:</p>
    <table>
      <tr><td>class</td><td>A class object.</td></tr>
    </table>
  <details><summary>objc-doc-text 的一个说明</summary>
    <p>用于将 HTML 转换为可读的 Lisp 文档:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*objc-nickname-alist*</span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;cls&quot;</span><span class="w">      </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;class&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="w">       </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;objc-id&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;objc_property_t&quot;</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;objc-property&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;Class&quot;</span><span class="w">    </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;objc-class&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;Method&quot;</span><span class="w">   </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;objc-method&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;IMP&quot;</span><span class="w">      </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;objc-imp&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;SEL&quot;</span><span class="w">      </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;objc-sel&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;Protocol&quot;</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="s">&quot;objc-protocol&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">get-nickname</span><span class="w"> </span><span class="p">(</span><span class="nf">key</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="nv">*objc-nickname-alist*</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;equal</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nb">cons</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">str:param-case</span><span class="w"> </span><span class="nv">key</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-text</span><span class="w"> </span><span class="p">(</span><span class="nf">node</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">dom</span><span class="w"> </span><span class="p">(</span><span class="nf">plump:parse</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:property</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="s">&quot;innerHTML&quot;</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">flet</span><span class="w"> </span><span class="p">((</span><span class="nf">parse</span><span class="w"> </span><span class="p">(</span><span class="nf">node</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nf">plump:text-node-p</span><span class="w"> </span><span class="nv">node</span><span class="p">)</span>
<span class="w">                     </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">string=</span><span class="w"> </span><span class="p">(</span><span class="nf">plump:tag-name</span><span class="w"> </span><span class="nv">node</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;code&quot;</span><span class="p">)</span>
<span class="w">                          </span><span class="p">(</span><span class="nf">/=</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="p">(</span><span class="nf">plump:children</span><span class="w"> </span><span class="nv">node</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">plump:text</span><span class="w"> </span><span class="nv">node</span><span class="p">)</span>
<span class="w">                 </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="s">&quot;`~A&#39;&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">get-nickname</span><span class="w"> </span><span class="p">(</span><span class="nf">plump:text</span><span class="w"> </span><span class="nv">node</span><span class="p">))))))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">str:join</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="ss">&#39;list</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;parse</span><span class="w"> </span><span class="p">(</span><span class="nf">plump:children</span><span class="w"> </span><span class="nv">dom</span><span class="p">))))))</span>
</pre></div>
  </details>
  </li>
  <li><code>#return-value</code>: 返回值 <code>objc-doc-return-value</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-return-value</span><span class="w"> </span><span class="p">(</span><span class="nf">session</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">map-find-elems</span><span class="w"> </span><span class="p">(</span><span class="nf">elem</span><span class="w"> </span><span class="s">&quot;#return-value ~ p&quot;</span><span class="w"> </span><span class="nv">session</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">objc-doc-text</span><span class="w"> </span><span class="nv">elem</span><span class="p">)))</span>
</pre></div>
    <p>例:</p>
    <table>
      <tr><td>The name of the class, or the empty string if class is nil.</td></tr>
    </table>
  </li>
  <li><code>#Discussion</code>: 一些额外的说明 <code>objc-doc-discussion</code>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-discussion</span><span class="w"> </span><span class="p">(</span><span class="nf">session</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">map-find-elems</span><span class="w"> </span><span class="p">(</span><span class="nf">elem</span><span class="w"> </span><span class="s">&quot;#Discussion ~ p&quot;</span><span class="w"> </span><span class="nv">session</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">objc-doc-text</span><span class="w"> </span><span class="nv">elem</span><span class="p">)))</span>
</pre></div>
  </li>
</ul>
<p>于是可以实现 <code>objc-doc-parse-url</code> 的功能:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-doc-parse-name-url-cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">name</span><span class="w"> </span><span class="p">(</span><span class="nb">car</span><span class="w"> </span><span class="nb">cons</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">url</span><span class="w">  </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="nb">cons</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="p">(</span><span class="nb">string=</span><span class="w"> </span><span class="p">(</span><span class="nf">wd:url</span><span class="w"> </span><span class="nv">*session*</span><span class="p">)</span><span class="w"> </span><span class="nv">url</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">wd:navigate</span><span class="w"> </span><span class="nv">*session*</span><span class="w"> </span><span class="nv">url</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">:name</span><span class="w">   </span><span class="nv">name</span>
<span class="w">          </span><span class="nv">:type</span><span class="w">   </span><span class="p">(</span><span class="nf">objc-doc-type</span><span class="w">   </span><span class="nv">*session*</span><span class="p">)</span>
<span class="w">          </span><span class="nv">:doc</span><span class="w">    </span><span class="p">(</span><span class="nf">objc-doc-short</span><span class="w">  </span><span class="nv">*session*</span><span class="p">)</span>
<span class="w">          </span><span class="nv">:lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-doc-lambda</span><span class="w"> </span><span class="nv">*session*</span><span class="p">)</span>
<span class="w">          </span><span class="nv">:params</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-doc-params</span><span class="w"> </span><span class="nv">*session*</span><span class="p">)</span>
<span class="w">          </span><span class="nv">:return</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-doc-return-value</span><span class="w"> </span><span class="nv">*session*</span><span class="p">)</span>
<span class="w">          </span><span class="nv">:discussion</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-doc-discussion</span><span class="w"> </span><span class="nv">*session*</span><span class="p">))))</span>
</pre></div>
<p>例:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">objc-doc-parse-name-url-cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">sections</span><span class="p">))))</span>
</pre></div>
<pre class="example">
(:name &quot;class_getName&quot; :type &quot;Function&quot; :doc &quot;Returns the name of a class.&quot;
 :lambda &quot;extern const char * class_getName(Class cls);&quot; :params
 ((&quot;class&quot; &quot;A class object.&quot;)) :return
 (&quot;The name of the class, or the empty string if `class&#39; is `nil&#39;.&quot;)
 :discussion nil)
</pre>
<h2>Parse Function Lambda</h2>
<h3>Tokenrize</h3>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*objc-keywords-alist*</span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;extern&quot;</span><span class="w">   </span><span class="o">.</span><span class="w"> </span><span class="nv">:extern</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;struct&quot;</span><span class="w">   </span><span class="o">.</span><span class="w"> </span><span class="nv">:struct</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;unsigned&quot;</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">:unsigned</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;const&quot;</span><span class="w">    </span><span class="o">.</span><span class="w"> </span><span class="nv">:const</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*objc-type-alist*</span>
<span class="w">  </span><span class="o">&#39;</span><span class="p">((</span><span class="s">&quot;char&quot;</span><span class="w">     </span><span class="o">.</span><span class="w"> </span><span class="nv">:char</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="w">      </span><span class="o">.</span><span class="w"> </span><span class="nv">:int</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;void&quot;</span><span class="w">     </span><span class="o">.</span><span class="w"> </span><span class="nv">:void</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;uint8_t&quot;</span><span class="w">  </span><span class="o">.</span><span class="w"> </span><span class="nv">:uint8</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;size_t&quot;</span><span class="w">   </span><span class="o">.</span><span class="w"> </span><span class="nv">:size</span><span class="p">)</span>
<span class="w">    </span><span class="c1">;; 注: 这里开了一个 parser 的洞</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;void (*)(id)&quot;</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="p">(</span><span class="nf">:function</span><span class="w"> </span><span class="nv">objc-id</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-token-regexp</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="s">&quot;void </span><span class="se">\\</span><span class="s">(</span><span class="se">\\</span><span class="s">*</span><span class="se">\\</span><span class="s">)</span><span class="se">\\</span><span class="s">(id</span><span class="se">\\</span><span class="s">)|[a-zA-Z][a-zA-Z0-9_]*|</span><span class="se">\\</span><span class="s">(|</span><span class="se">\\</span><span class="s">)|</span><span class="se">\\</span><span class="s">;|</span><span class="se">\\</span><span class="s">,|</span><span class="se">\\</span><span class="s">*&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-lexer</span><span class="w"> </span><span class="p">(</span><span class="nf">str</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">flet</span><span class="w"> </span><span class="p">((</span><span class="nf">tokenrize</span><span class="w"> </span><span class="p">(</span><span class="nf">token</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">string=</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="s">&quot;;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="nv">:eol</span><span class="w">        </span><span class="nv">:eol</span><span class="p">))</span>
<span class="w">                 </span><span class="p">((</span><span class="nb">string=</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="s">&quot;*&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="nv">:pointer</span><span class="w">    </span><span class="nv">:pointer</span><span class="p">))</span>
<span class="w">                 </span><span class="p">((</span><span class="nb">string=</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="nv">:args-start</span><span class="w"> </span><span class="nv">:args-start</span><span class="p">))</span>
<span class="w">                 </span><span class="p">((</span><span class="nb">string=</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="nv">:args-end</span><span class="w">   </span><span class="nv">:args-end</span><span class="p">))</span>
<span class="w">                 </span><span class="p">((</span><span class="nb">string=</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="nv">:comma</span><span class="w">      </span><span class="nv">:comma</span><span class="p">))</span>
<span class="w">                 </span><span class="p">((</span><span class="nb">assoc</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="nv">*objc-keywords-alist*</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;equal</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">token</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="nv">*objc-keywords-alist*</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;equal</span><span class="p">))))</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="nv">token</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">((</span><span class="nb">assoc</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="nv">*objc-type-alist*</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;equal</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">token</span><span class="w"> </span><span class="p">(</span><span class="nb">cdr</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="nv">token</span><span class="w"> </span><span class="nv">*objc-type-alist*</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="o">#</span><span class="ss">&#39;equal</span><span class="p">))))</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="ss">&#39;type</span><span class="w"> </span><span class="nv">token</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="nf">T</span><span class="w"> </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="ss">&#39;name</span><span class="w"> </span><span class="p">(</span><span class="nf">intern</span><span class="w"> </span><span class="p">(</span><span class="nf">str:upcase</span><span class="w"> </span><span class="p">(</span><span class="nf">get-nickname</span><span class="w"> </span><span class="nv">token</span><span class="p">))))))))</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">search</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nf">regexp</span><span class="w"> </span><span class="p">(</span><span class="nf">ppcre:create-scanner</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-token-regexp</span><span class="p">))))</span>
<span class="w">      </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">()</span>
<span class="w">        </span><span class="p">(</span><span class="nf">multiple-value-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">start</span><span class="w"> </span><span class="nv">end</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">ppcre:scan</span><span class="w"> </span><span class="nv">regexp</span><span class="w"> </span><span class="nv">str</span><span class="w"> </span><span class="nv">:start</span><span class="w"> </span><span class="nv">search</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">end</span><span class="w"> </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">search</span><span class="w"> </span><span class="nv">end</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">start</span>
<span class="w">              </span><span class="p">(</span><span class="nf">tokenrize</span><span class="w"> </span><span class="p">(</span><span class="nf">str:substring</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="nv">end</span><span class="w"> </span><span class="nv">str</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">values</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="nv">nil</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-tokenrize</span><span class="w"> </span><span class="p">(</span><span class="nf">str</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">lexer</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-lexer</span><span class="w"> </span><span class="nv">str</span><span class="p">)))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="p">(</span><span class="nf">terminal</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">multiple-value-list</span><span class="w"> </span><span class="p">(</span><span class="nf">funcall</span><span class="w"> </span><span class="nv">lexer</span><span class="p">))</span>
<span class="w">          </span><span class="k">while</span><span class="w"> </span><span class="nv">terminal</span><span class="w"> </span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">terminal</span><span class="w"> </span><span class="nv">value</span><span class="p">))))</span>
</pre></div>
<p>这个 tokenizer 的实现还是挺 trivial 的, 毕竟需要处理的问题有限,
  可以进行一个肮脏的开洞.</p>
<p>例:</p>
<table>
  <tr><td>:extern</td><td>:extern</td></tr>
  <tr><td>name</td><td>ivar</td></tr>
  <tr><td>name</td><td>class-get-instance-variable</td></tr>
  <tr><td>:args-start</td><td>:args-start</td></tr>
  <tr><td>name</td><td>objc-class</td></tr>
  <tr><td>name</td><td>class</td></tr>
  <tr><td>:comma</td><td>:comma</td></tr>
  <tr><td>:const</td><td>:const</td></tr>
  <tr><td>type</td><td>:char</td></tr>
  <tr><td>:pointer</td><td>:pointer</td></tr>
  <tr><td>name</td><td>name</td></tr>
  <tr><td>:args-end</td><td>:args-end</td></tr>
  <tr><td>:eol</td><td>:eol</td></tr>
</table>
<h3>Grammer Parser</h3>
<p>使用 <a href="https://www.irif.fr/~jch/software/cl-yacc/">cl-yacc</a> 作为 parser generator:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">yacc:define-parser</span><span class="w"> </span><span class="nv">*objc-lambda-parser*</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:start-symbol</span><span class="w"> </span><span class="nv">objc-lambda</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">:terminals</span><span class="w"> </span><span class="p">(</span><span class="nf">name</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">:comma</span><span class="w"> </span><span class="nv">:extern</span><span class="w"> </span><span class="nv">:const</span><span class="w"> </span><span class="nv">:struct</span><span class="w"> </span><span class="nv">:unsigned</span>
<span class="w">                         </span><span class="nv">:pointer</span><span class="w"> </span><span class="nv">:args-start</span><span class="w"> </span><span class="nv">:args-end</span><span class="w"> </span><span class="nv">:eol</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">objc-lambda</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:extern</span><span class="w"> </span><span class="nv">types</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">args</span><span class="w"> </span><span class="nv">:eol</span>
<span class="w">            </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">extern</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">args</span><span class="w"> </span><span class="nv">eol</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">extern</span><span class="w"> </span><span class="nv">eol</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="nv">args</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nf">types</span>
<span class="w">   </span><span class="nv">type</span>
<span class="w">   </span><span class="nv">name</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:const</span><span class="w">    </span><span class="nv">types</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nb">const</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nb">const</span><span class="p">))</span>
<span class="w">                      </span><span class="nv">type</span><span class="p">))</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:unsigned</span><span class="w"> </span><span class="nv">types</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">unsigned</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">unsigned</span><span class="w"> </span><span class="nv">type</span><span class="p">)))</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:struct</span><span class="w">   </span><span class="nv">name</span><span class="w">  </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">struct</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">struct</span><span class="w"> </span><span class="nv">name</span><span class="p">)))</span>
<span class="w">   </span><span class="p">(</span><span class="nf">types</span><span class="w">  </span><span class="nv">:pointer</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">pointer</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">pointer</span><span class="w"> </span><span class="nv">type</span><span class="p">))))</span>

<span class="w">  </span><span class="p">(</span><span class="nf">args</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:args-start</span><span class="w"> </span><span class="nv">pair*</span><span class="w"> </span><span class="nv">:args-end</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">a</span><span class="w"> </span><span class="nv">pairs</span><span class="w"> </span><span class="nv">c</span><span class="p">)</span>
<span class="w">                                  </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">c</span><span class="p">))</span>
<span class="w">                                  </span><span class="nv">pairs</span><span class="p">))</span>
<span class="w">   </span><span class="p">(</span><span class="nf">:args-start</span><span class="w"> </span><span class="nv">:args-end</span><span class="w">       </span><span class="p">(</span><span class="nf">constantly</span><span class="w"> </span><span class="nv">nil</span><span class="p">)))</span>

<span class="w">  </span><span class="p">(</span><span class="nf">pair*</span>
<span class="w">   </span><span class="p">(</span><span class="nf">types</span><span class="w"> </span><span class="nv">name</span><span class="w">              </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">name</span><span class="p">)</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">type</span><span class="p">))))</span>
<span class="w">   </span><span class="p">(</span><span class="nf">types</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">:comma</span><span class="w"> </span><span class="nv">pair*</span><span class="w"> </span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">type</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">comma</span><span class="w"> </span><span class="nv">pairs</span><span class="p">)</span>
<span class="w">                              </span><span class="p">(</span><span class="nf">declare</span><span class="w"> </span><span class="p">(</span><span class="nf">ignore</span><span class="w"> </span><span class="nv">comma</span><span class="p">))</span>
<span class="w">                              </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">name</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="nv">pairs</span><span class="p">)))))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">objc-parse-lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-lambda</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">yacc:parse-with-lexer</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-lexer</span><span class="w"> </span><span class="nv">objc-lambda</span><span class="p">)</span><span class="w"> </span><span class="nv">*objc-lambda-parser*</span><span class="p">))</span>
</pre></div>
<details><summary>语法的设计的问题</summary>
<p>这里有个小问题就是在 <code>types</code> 节点的 <code>types :pointer</code> 的语法, 这可能会导致
  parser 陷入无限循环的 bug 中. 但是能跑就行了?</p>
</details>
<p>例:</p>
<pre class="example">
((class-get-name :char) ((class objc-class)))
</pre>
<h2>Lisp-Spider, Go!</h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defparameter</span><span class="w"> </span><span class="nv">*objc-runtime-doc*</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dolist-bind-collect</span><span class="w"> </span><span class="p">((</span><span class="nf">title</span><span class="w"> </span><span class="nv">elem</span><span class="p">)</span><span class="w"> </span><span class="nv">sections</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">title</span><span class="w"> </span><span class="p">(</span><span class="nf">dolist-bind-collect</span><span class="w"> </span><span class="p">((</span><span class="nf">method</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">url</span><span class="p">)</span><span class="w"> </span><span class="nv">elem</span><span class="p">)</span>
<span class="w">                  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">property</span><span class="w"> </span><span class="p">(</span><span class="nf">objc-doc-parse-name-url-cons</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">method</span><span class="w"> </span><span class="nv">url</span><span class="p">))))</span>
<span class="w">                    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nb">string=</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">property</span><span class="w"> </span><span class="nv">:type</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;Function&quot;</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">property</span><span class="w"> </span><span class="nv">:cffi</span><span class="p">)</span>
<span class="w">                            </span><span class="p">(</span><span class="nf">objc-parse-lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">property</span><span class="w"> </span><span class="nv">:lambda</span><span class="p">))))</span>
<span class="w">                    </span><span class="nv">property</span><span class="p">)))))</span>
</pre></div>
<h1>End</h1>
<p>最终处理结束的结果可以见 <a href="https://gist.github.com/li-yiyang/468b042bdf399435d0c5f561dba0d279">gist</a>, 理论上来说通过一些简单的 <code>format</code> 操作就
  能够生成 CFFI 的 bindings 了. 不过考虑到自动生成的 bingdings 可能并不
  是那么的可用 (不知道正确性, 毕竟不太会 CFFI 和 ObjC Runtime), 所以我决
  定先去看看 ObjC Runtime 的一些 Hello World 的例子, 然后去尝试构建模拟
  兼容 LispWorks 的 ObjC-Bridge API.</p>
<details><summary>输出 format</summary>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">section</span><span class="w"> </span><span class="nv">*objc-runtime-doc*</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">(</span><span class="nf">title</span><span class="w"> </span><span class="nv">elems</span><span class="p">)</span><span class="w"> </span><span class="nv">section</span>
<span class="w">    </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;;;; ~A~%~%&quot;</span><span class="w"> </span><span class="nv">title</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">elem</span><span class="w"> </span><span class="nv">elems</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:cffi</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">destructuring-bind</span><span class="w"> </span><span class="p">((</span><span class="nf">lisp-name</span><span class="w"> </span><span class="nv">type</span><span class="p">)</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:cffi</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;(defcfun (~A ~S)~%    &quot;</span>
<span class="w">                  </span><span class="nv">lisp-name</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:name</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">write</span><span class="w"> </span><span class="nv">type</span><span class="w"> </span><span class="nv">:stream</span><span class="w"> </span><span class="nv">*standard-output*</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~%  ~S&quot;</span>
<span class="w">                  </span><span class="p">(</span><span class="nb">with-output-to-string</span><span class="w"> </span><span class="p">(</span><span class="nf">*standard-output*</span><span class="p">)</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~A~%&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">split-long-lines</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:doc</span><span class="p">)))</span>
<span class="w">                    </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~%    ~A~%&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:lambda</span><span class="p">))</span>
<span class="w">                    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:params</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~%Parameters:~%&quot;</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">dolist-bind-collect</span><span class="w"> </span><span class="p">((</span><span class="nf">para</span><span class="w"> </span><span class="nv">doc</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:params</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;+ `~A&#39;: ~A~%&quot;</span><span class="w"> </span><span class="nv">para</span>
<span class="w">                                </span><span class="p">(</span><span class="nf">split-long-lines</span><span class="w"> </span><span class="nv">doc</span>
<span class="w">                                                  </span><span class="nv">:indent</span><span class="w"> </span><span class="mi">2</span>
<span class="w">                                                  </span><span class="nv">:start</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">para</span><span class="p">))))))</span>
<span class="w">                    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:return</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~%Return Values:~%&quot;</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">para</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:return</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~A~%&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">split-long-lines</span><span class="w"> </span><span class="nv">para</span><span class="p">))))</span>
<span class="w">                    </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:discussion</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~%Discussion:~%&quot;</span><span class="p">)</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">para</span><span class="w"> </span><span class="p">(</span><span class="nf">getf</span><span class="w"> </span><span class="nv">elem</span><span class="w"> </span><span class="nv">:discussion</span><span class="p">))</span>
<span class="w">                        </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~A~%&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">split-long-lines</span><span class="w"> </span><span class="nv">para</span><span class="p">))))))</span>
<span class="w">          </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">args</span>
<span class="w">            </span><span class="p">(</span><span class="nf">dolist</span><span class="w"> </span><span class="p">(</span><span class="nf">arg</span><span class="w"> </span><span class="nv">args</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~%  &quot;</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="nb">write</span><span class="w"> </span><span class="nv">arg</span><span class="w"> </span><span class="nv">:stream</span><span class="w"> </span><span class="nv">*standard-output*</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;)~%~%&quot;</span><span class="p">))))))</span>
</pre></div>
</details>]]></content><author><name></name></author><category term="lisp" /><summary type="html"><![CDATA[About 记录一下我尝试复刻 objectvie-c-bridge (参考的是 LispWorks 的 API, CCL 也有一个 objective-c-bridge, 但是因为 CCL arm port 目前是缺失的, 所以我没法在我的电脑上面测试其表现, 我不是一个善于读文档的人). 注: 因为我做这个的目标完全只是为了不花钱去买 LispWorks 的 Licence, 以及给比较无聊的生活加点乐子和非游戏的打发时间的事做. 所以该项目在我能 被批准用学校的钱去购买 Licence 或者很忙的情况下就会被中断. 目前我的计划是这样的: 用 CFFI 建立 Objcective-C Runtime 的一个绑定 去了解一下 Objective-C Runtime 该怎么 编写 去模拟 LispWorks 的 ObjC 的函数 去添加其他的库, 或者做一些高层的 wrapping 之类的 去尝试实现 CLIM 的 backend 或者模拟 CAPI 的 API? 这估计会是一个跨越时间非常长的项目了&#8230; 不过这个 post 的主要内容是如何从苹果的官网上把文档给爬下来, 并解析成 CFFI 可以使用的形式. 其中使用了我对之前 WebDriver 协议的一个小小改进 版本的代码 (gist). 一些基于 WebDriver 库的小小 wrapper (defmacro map-find-elems ((elem selector &amp;optional (node &#39;*session*)) &amp;body body) `(mapcar (lambda (,elem) ,@body) (wd:find-elems ,node ,selector)))]]></summary></entry><entry><title type="html">澡堂密码的 “解压缩”</title><link href="/misc/showering/" rel="alternate" type="text/html" title="澡堂密码的 “解压缩”" /><published>2025-03-27T00:00:00+00:00</published><updated>2025-03-27T00:00:00+00:00</updated><id>/misc/showering</id><content type="html" xml:base="/misc/showering/"><![CDATA[<h1>About</h1>
<p>洗澡的时候想到的, 假如把洗澡的时候的口令密码 (一个 6 位数字)
  用一个简单的算法进行压缩:</p>
<p>对于连续重复的 <code>m</code> 部分, 若其长度 <code>n</code> 大于等于 <code>3</code>, 则记为 <code>nm</code></p>
<p>例: <code>822232</code> 就变成 <code>83232</code>, 那么是否有一个简单的还原算法呢?
  以及如此简单的算法是否会有歧义呢? (显然, 比如 <code>833323</code> 会变成
  <code>83323</code>, 此时可能是 <code>33</code> 也可能是 <code>32</code>).</p>
<h1>压缩</h1>
<p>对于重复 <code>n</code> 次的数字 <code>m</code>, 其应输出为:</p>
<ul>
  <li>若 <code>n &gt; 2</code>, 则输出 <code>nm</code></li>
  <li>若 <code>n = 2</code>, 则输出 <code>mm</code></li>
  <li>若 <code>n = 1</code>, 则输出 <code>m</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">write-nm</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="nv">m</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">&gt;</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~D~C&quot;</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">m</span><span class="p">))</span>
<span class="w">        </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~C~C&quot;</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">m</span><span class="p">))</span>
<span class="w">        </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~C&quot;</span><span class="w"> </span><span class="nv">m</span><span class="p">))))</span>
</pre></div>
<p>对于一组洗澡口令, 历遍其每个元素 <code>i</code> 及其前一个元素 <code>(1- i)</code>,
  同时记录前一个元素的重复次数 <code>n</code>, 若:</p>
<ul>
  <li>到达口令末尾 (<code>i = 6</code>), 则输出 <code>nm</code></li>
  <li>两者相等: 增加当前元素的重复次数 <code>(incf n)</code>, 即计数当前元素重复了几次;</li>
  <li>两者不同: 输出 <code>nm</code>, 并移动到下一个元素, 记 <code>n</code> 为 <code>1</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">scan-passwd</span><span class="w"> </span><span class="p">(</span><span class="nf">passwd</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">m</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">passwd</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">i</span><span class="p">))))</span><span class="w"> </span><span class="c1">;; m  为前一个元素</span>
<span class="w">    </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">write-nm</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">m</span><span class="p">))</span>
<span class="w">          </span><span class="p">((</span><span class="nf">char=</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">passwd</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span><span class="w"> </span><span class="c1">;; (aref passwd i) 为当前元素o</span>
<span class="w">           </span><span class="p">(</span><span class="nf">scan-passwd</span><span class="w"> </span><span class="nv">passwd</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">n</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">T</span>
<span class="w">           </span><span class="p">(</span><span class="nf">write-nm</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">m</span><span class="p">)</span>
<span class="w">           </span><span class="p">(</span><span class="nf">scan-passwd</span><span class="w"> </span><span class="nv">passwd</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))</span>
</pre></div>
<details><summary>有点不太懂? 对它使用 trace 吧!</summary>
<div class="highlight"><pre><span></span><span class="c1">;; scan:</span>
<span class="c1">;; 8 3 3 3 2 3    | passwd</span>
<span class="c1">;;   ^ ^ ^ ^ ^ ^  | 当前 scan 到的地方</span>
<span class="c1">;; 0 1 2 3 4 5 6  | i</span>
<span class="c1">;;   1 1 2 3 1 1  | n</span>
<span class="nv">cl-user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">scan-passwd</span><span class="w"> </span><span class="s">&quot;833323&quot;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nv">0:</span><span class="w"> </span><span class="p">(</span><span class="nf">SCAN-PASSWD</span><span class="w"> </span><span class="s">&quot;833323&quot;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">               </span><span class="c1">;; 因为 8 3 不同, 所以输出</span>
<span class="mi">8</span><span class="w">    </span><span class="nv">1:</span><span class="w"> </span><span class="p">(</span><span class="nf">SCAN-PASSWD</span><span class="w"> </span><span class="s">&quot;833323&quot;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="nv">2:</span><span class="w"> </span><span class="p">(</span><span class="nf">SCAN-PASSWD</span><span class="w"> </span><span class="s">&quot;833323&quot;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="nv">3:</span><span class="w"> </span><span class="p">(</span><span class="nf">SCAN-PASSWD</span><span class="w"> </span><span class="s">&quot;833323&quot;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">       </span><span class="c1">;; 因为 3 2 不同, 所以输出</span>
<span class="mi">33</span><span class="w">          </span><span class="nv">4:</span><span class="w"> </span><span class="p">(</span><span class="nf">SCAN-PASSWD</span><span class="w"> </span><span class="s">&quot;833323&quot;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">   </span><span class="c1">;; 因为 2 3 不同, 所以输出</span>
<span class="mi">2</span><span class="w">            </span><span class="nv">5:</span><span class="w"> </span><span class="p">(</span><span class="nf">SCAN-PASSWD</span><span class="w"> </span><span class="s">&quot;833323&quot;</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="c1">;; 因为结束所以输出</span>
<span class="mi">3</span><span class="w">            </span><span class="nv">5:</span><span class="w"> </span><span class="nv">scan-passwd</span><span class="w"> </span><span class="nv">returned</span><span class="w"> </span><span class="nv">nil</span>
</pre></div>
</details>
<p>于是压缩函数即:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">encode</span><span class="w"> </span><span class="p">(</span><span class="nf">passwd</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">with-output-to-string</span><span class="w"> </span><span class="p">(</span><span class="nf">*standard-output*</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">scan-passwd</span><span class="w"> </span><span class="nv">passwd</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
<h1>解压缩</h1>
<p>对于两隔壁的数 <code>lnm</code>, 若:</p>
<ul>
  <li><code>n &lt; 3</code> 或者 <code>n &gt; 6</code>, 则不认为是可展开的数</li>
  <li><code>nm</code> 相等, 则不认为是可展开的数</li>
  <li>其他情况都尝试去展开它们, 若:
    <ul>
      <li>展开后长度为 <code>6</code>, 则使用</li>
      <li>长度不足 <code>6</code>, 则在其之后继续扫描, 从 <code>i + n</code> 开始扫描</li>
      <li>长度超过 <code>6</code>, 则退出 (太长了)</li>
    </ul>
  </li>
</ul>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">get-num</span><span class="w"> </span><span class="p">(</span><span class="nb">string</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;得到字符串 `string&#39; 第 `i&#39; 位上的数.</span>
<span class="s">返回一个整形. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nf">char-code</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nb">string</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">char-code</span><span class="w"> </span><span class="sc">#\0</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">try-expand</span><span class="w"> </span><span class="p">(</span><span class="nf">compressed</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;尝试把 `compressed&#39; 字符串的第 i 处做为 n, i+1 处作为字符 m, 展开 nm.</span>
<span class="s">返回展开后的字符串. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">n</span><span class="w"> </span><span class="p">(</span><span class="nf">get-num</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">        </span><span class="p">(</span><span class="nf">m</span><span class="w"> </span><span class="p">(</span><span class="nf">aref</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">i</span><span class="p">))))</span>
<span class="w">    </span><span class="p">(</span><span class="nb">with-output-to-string</span><span class="w"> </span><span class="p">(</span><span class="nf">expanded</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">write-string</span><span class="w"> </span><span class="p">(</span><span class="nf">subseq</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="nv">expanded</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">dotimes</span><span class="w"> </span><span class="p">(</span><span class="nf">i</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">write-char</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">expanded</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">write-string</span><span class="w"> </span><span class="p">(</span><span class="nf">subseq</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="mi">2</span><span class="p">))</span><span class="w"> </span><span class="nv">expanded</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">scan-compressed</span><span class="w"> </span><span class="p">(</span><span class="nf">compressed</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">len</span><span class="w"> </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">compressed</span><span class="p">)))</span>
<span class="w">  </span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">len</span><span class="p">))</span>
<span class="w">    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">l</span><span class="w"> </span><span class="p">(</span><span class="nf">get-num</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">i</span><span class="p">)))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="p">(</span><span class="nf">get-num</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">m</span><span class="w"> </span><span class="p">(</span><span class="nf">get-num</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">i</span><span class="p">))))</span>
<span class="w">      </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="nf">/=</span><span class="w"> </span><span class="nv">m</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">expanded</span><span class="w"> </span><span class="p">(</span><span class="nf">try-expand</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span>
<span class="w">                      </span><span class="p">(</span><span class="nf">len</span><span class="w">      </span><span class="p">(</span><span class="nb">length</span><span class="w"> </span><span class="nv">expanded</span><span class="p">)))</span>
<span class="w">                 </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="nv">expanded</span><span class="p">)</span>
<span class="w">                       </span><span class="p">((</span><span class="nb">&lt;</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">scan-compressed</span><span class="w"> </span><span class="nv">expanded</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="nv">len</span><span class="p">)))))</span>
<span class="w">          </span><span class="p">(</span><span class="nf">scan-compressed</span><span class="w"> </span><span class="nv">compressed</span><span class="w"> </span><span class="p">(</span><span class="nb">1+</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="nv">len</span><span class="p">)))))</span>
</pre></div>
<h1>End</h1>
<p>大概就这样, 一个小品例子, 算是写论文发神经的中间结果吧&#8230;
  (也许有问题就是了, 不保熟, <del>毕竟洗澡的时候容易脑子进水</del> bushi)</p>]]></content><author><name></name></author><category term="misc" /><summary type="html"><![CDATA[About 洗澡的时候想到的, 假如把洗澡的时候的口令密码 (一个 6 位数字) 用一个简单的算法进行压缩: 对于连续重复的 m 部分, 若其长度 n 大于等于 3, 则记为 nm 例: 822232 就变成 83232, 那么是否有一个简单的还原算法呢? 以及如此简单的算法是否会有歧义呢? (显然, 比如 833323 会变成 83323, 此时可能是 33 也可能是 32). 压缩 对于重复 n 次的数字 m, 其应输出为: 若 n &gt; 2, 则输出 nm 若 n = 2, 则输出 mm 若 n = 1, 则输出 m (defun write-nm (n m) (cond ((&gt; n 2) (format t &quot;~D~C&quot; n m)) ((= n 2) (format t &quot;~C~C&quot; m m)) ((= n 1) (format t &quot;~C&quot; m)))) 对于一组洗澡口令, 历遍其每个元素 i 及其前一个元素 (1- i), 同时记录前一个元素的重复次数 n, 若: 到达口令末尾 (i = 6), 则输出 nm 两者相等: 增加当前元素的重复次数 (incf n), 即计数当前元素重复了几次; 两者不同: 输出 nm, 并移动到下一个元素, 记 n 为 1 (defun scan-passwd (passwd i &amp;optional (n 1)) (let ((m (aref passwd (1- i)))) ;; m 为前一个元素 (cond ((= i 6) (write-nm n m)) ((char= m (aref passwd i)) ;; (aref passwd i) 为当前元素o (scan-passwd passwd (1+ i) (1+ n))) (T (write-nm n m) (scan-passwd passwd (1+ i) 1))))) 有点不太懂? 对它使用 trace 吧! ;; scan: ;; 8 3 3 3 2 3 | passwd ;; ^ ^ ^ ^ ^ ^ | 当前 scan 到的地方 ;; 0 1 2 3 4 5 6 | i ;; 1 1 2 3 1 1 | n cl-user&gt; (scan-passwd &quot;833323&quot; 1) 0: (SCAN-PASSWD &quot;833323&quot; 1) ;; 因为 8 3 不同, 所以输出 8 1: (SCAN-PASSWD &quot;833323&quot; 2 1) 2: (SCAN-PASSWD &quot;833323&quot; 3 2) 3: (SCAN-PASSWD &quot;833323&quot; 4 3) ;; 因为 3 2 不同, 所以输出 33 4: (SCAN-PASSWD &quot;833323&quot; 5 1) ;; 因为 2 3 不同, 所以输出 2 5: (SCAN-PASSWD &quot;833323&quot; 6 1) ;; 因为结束所以输出 3 5: scan-passwd returned nil 于是压缩函数即: (defun encode (passwd) (with-output-to-string (*standard-output*) (scan-passwd passwd 1 1))) 解压缩 对于两隔壁的数 lnm, 若: n &lt; 3 或者 n &gt; 6, 则不认为是可展开的数 nm 相等, 则不认为是可展开的数 其他情况都尝试去展开它们, 若: 展开后长度为 6, 则使用 长度不足 6, 则在其之后继续扫描, 从 i + n 开始扫描 长度超过 6, 则退出 (太长了) (defun get-num (string i) &quot;得到字符串 `string&#39; 第 `i&#39; 位上的数. 返回一个整形. &quot; (- (char-code (aref string i)) (char-code #\0)))]]></summary></entry></feed>