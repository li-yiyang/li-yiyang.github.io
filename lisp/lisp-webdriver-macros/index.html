<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Lisp WebDriver Macros | My Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Lisp WebDriver Macros" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="About 我想要在 Lisp 中实现类似于 Ruby 中 watir 类似的功能: 即控制一个游览器, 这样就可以作为一个简单的, 但是高级的爬虫来爬取网站了. 仔细阅读代码, 并往上找依赖, 可以发现原理是 WebDriver 这个协议. 那么问题就变成了该怎么实现这个协议了. 协议省流版 以我用的游览器 Safari (&gt; 10.1) 为例, 其在后端会开一个 WebDriver 服务: (defun run-webdriver-server (&amp;optional (port *webdriver-default-port*)) (uiop:launch-program `(&quot;safaridriver&quot; &quot;-p&quot; ,(format nil &quot;~D&quot; port)))) 根据 Protocol | Endpoints 中的说明, WebDriver 和 Client 之间通过 HTTP 进行通信, 然后根据不同的方法 (method) 执行动作, 并返回对应的结果. 这里会以 JSON 进行传值. 比如参考 New Session, 这里可以做一个非常简单的 Client 的创建: (let ((json (make-hash-table :test &#39;equal)) (capabilities (make-hash-table :test &#39;equal))) ;; 这里构建的是一个 JSON Object: ;; { ;; &quot;capabilities&quot;: { &quot;browserName&quot;: &quot;safari&quot; } ;; } ;; 使用 shasht 库进行 JSON 序列化 (setf (gethash &quot;browserName&quot; capabilities) &quot;safari&quot;) (setf (gethash &quot;capabilities&quot; json) capabilities) ;; 使用 dexador 库进行 HTTP 请求 (dex:post (quri:make-uri-http :host *webdriver-default-address* :port *webdriver-default-port* :path &quot;/session&quot;) ;; 发送的 POST 内容为 JSON Object :content (shasht:write-json json nil))) 其返回的结果是一个 JSON Object: 大概的形式类似于: { &quot;value&quot;: { &quot;sessionId&quot;: &quot;一个 session id&quot;, &quot;capabilities&quot;: { ... } } } 基本上所有的方法的返回值都是一个 JSON Object, 通过 value 项来得到具体的结果. 那么接下来具体有啥方法, 该如何调用, 请看 Endpoint Table. 程序化地调用 method 不难发现, 这些 method 的调用都几乎是一个套路: POST 方法构建调用所需要的 JSON, GET 和 DELETE 则不需要; 请求对应的方法, 然后解析返回值; 注: 这里暂时略去对于错误的处理 (详见 Errors 一节), 后文中将会进行考虑. 处理返回的 JSON Object. 那么完全可以将这个步骤变成一个固定的程序: POST 构建 JSON 输入 构建一个输入的 List 到 Hash Table 再到 JSON 的快速输入: (defmacro make-hash (&amp;body bindings) &quot;Make a hash table from `bindings&#39;." />
<meta property="og:description" content="About 我想要在 Lisp 中实现类似于 Ruby 中 watir 类似的功能: 即控制一个游览器, 这样就可以作为一个简单的, 但是高级的爬虫来爬取网站了. 仔细阅读代码, 并往上找依赖, 可以发现原理是 WebDriver 这个协议. 那么问题就变成了该怎么实现这个协议了. 协议省流版 以我用的游览器 Safari (&gt; 10.1) 为例, 其在后端会开一个 WebDriver 服务: (defun run-webdriver-server (&amp;optional (port *webdriver-default-port*)) (uiop:launch-program `(&quot;safaridriver&quot; &quot;-p&quot; ,(format nil &quot;~D&quot; port)))) 根据 Protocol | Endpoints 中的说明, WebDriver 和 Client 之间通过 HTTP 进行通信, 然后根据不同的方法 (method) 执行动作, 并返回对应的结果. 这里会以 JSON 进行传值. 比如参考 New Session, 这里可以做一个非常简单的 Client 的创建: (let ((json (make-hash-table :test &#39;equal)) (capabilities (make-hash-table :test &#39;equal))) ;; 这里构建的是一个 JSON Object: ;; { ;; &quot;capabilities&quot;: { &quot;browserName&quot;: &quot;safari&quot; } ;; } ;; 使用 shasht 库进行 JSON 序列化 (setf (gethash &quot;browserName&quot; capabilities) &quot;safari&quot;) (setf (gethash &quot;capabilities&quot; json) capabilities) ;; 使用 dexador 库进行 HTTP 请求 (dex:post (quri:make-uri-http :host *webdriver-default-address* :port *webdriver-default-port* :path &quot;/session&quot;) ;; 发送的 POST 内容为 JSON Object :content (shasht:write-json json nil))) 其返回的结果是一个 JSON Object: 大概的形式类似于: { &quot;value&quot;: { &quot;sessionId&quot;: &quot;一个 session id&quot;, &quot;capabilities&quot;: { ... } } } 基本上所有的方法的返回值都是一个 JSON Object, 通过 value 项来得到具体的结果. 那么接下来具体有啥方法, 该如何调用, 请看 Endpoint Table. 程序化地调用 method 不难发现, 这些 method 的调用都几乎是一个套路: POST 方法构建调用所需要的 JSON, GET 和 DELETE 则不需要; 请求对应的方法, 然后解析返回值; 注: 这里暂时略去对于错误的处理 (详见 Errors 一节), 后文中将会进行考虑. 处理返回的 JSON Object. 那么完全可以将这个步骤变成一个固定的程序: POST 构建 JSON 输入 构建一个输入的 List 到 Hash Table 再到 JSON 的快速输入: (defmacro make-hash (&amp;body bindings) &quot;Make a hash table from `bindings&#39;." />
<link rel="canonical" href="/lisp/lisp-webdriver-macros/" />
<meta property="og:url" content="/lisp/lisp-webdriver-macros/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-09-04T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lisp WebDriver Macros" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-04T00:00:00+00:00","datePublished":"2024-09-04T00:00:00+00:00","description":"About 我想要在 Lisp 中实现类似于 Ruby 中 watir 类似的功能: 即控制一个游览器, 这样就可以作为一个简单的, 但是高级的爬虫来爬取网站了. 仔细阅读代码, 并往上找依赖, 可以发现原理是 WebDriver 这个协议. 那么问题就变成了该怎么实现这个协议了. 协议省流版 以我用的游览器 Safari (&gt; 10.1) 为例, 其在后端会开一个 WebDriver 服务: (defun run-webdriver-server (&amp;optional (port *webdriver-default-port*)) (uiop:launch-program `(&quot;safaridriver&quot; &quot;-p&quot; ,(format nil &quot;~D&quot; port)))) 根据 Protocol | Endpoints 中的说明, WebDriver 和 Client 之间通过 HTTP 进行通信, 然后根据不同的方法 (method) 执行动作, 并返回对应的结果. 这里会以 JSON 进行传值. 比如参考 New Session, 这里可以做一个非常简单的 Client 的创建: (let ((json (make-hash-table :test &#39;equal)) (capabilities (make-hash-table :test &#39;equal))) ;; 这里构建的是一个 JSON Object: ;; { ;; &quot;capabilities&quot;: { &quot;browserName&quot;: &quot;safari&quot; } ;; } ;; 使用 shasht 库进行 JSON 序列化 (setf (gethash &quot;browserName&quot; capabilities) &quot;safari&quot;) (setf (gethash &quot;capabilities&quot; json) capabilities) ;; 使用 dexador 库进行 HTTP 请求 (dex:post (quri:make-uri-http :host *webdriver-default-address* :port *webdriver-default-port* :path &quot;/session&quot;) ;; 发送的 POST 内容为 JSON Object :content (shasht:write-json json nil))) 其返回的结果是一个 JSON Object: 大概的形式类似于: { &quot;value&quot;: { &quot;sessionId&quot;: &quot;一个 session id&quot;, &quot;capabilities&quot;: { ... } } } 基本上所有的方法的返回值都是一个 JSON Object, 通过 value 项来得到具体的结果. 那么接下来具体有啥方法, 该如何调用, 请看 Endpoint Table. 程序化地调用 method 不难发现, 这些 method 的调用都几乎是一个套路: POST 方法构建调用所需要的 JSON, GET 和 DELETE 则不需要; 请求对应的方法, 然后解析返回值; 注: 这里暂时略去对于错误的处理 (详见 Errors 一节), 后文中将会进行考虑. 处理返回的 JSON Object. 那么完全可以将这个步骤变成一个固定的程序: POST 构建 JSON 输入 构建一个输入的 List 到 Hash Table 再到 JSON 的快速输入: (defmacro make-hash (&amp;body bindings) &quot;Make a hash table from `bindings&#39;.","headline":"Lisp WebDriver Macros","mainEntityOfPage":{"@type":"WebPage","@id":"/lisp/lisp-webdriver-macros/"},"url":"/lisp/lisp-webdriver-macros/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">

  <style type="text/css">
    img {
      margin-left: auto; 
      margin-right:auto; 
      display:block;
    }
  </style><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="My Blog" /><script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        // • rendering keys, e.g.:
        throwOnError : false
      });
  });
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.css" integrity="sha384-z91AFMXXGZasvxZz5DtKJse3pKoTPU0QcNFj/B4gDFRmq6Q2bi1StsT7SOcIzLEN" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.js" integrity="sha384-Af7YmksQNWRLMvro3U9F84xa0paoIu7Pu2niAIUmZoI09Q4aCsbha5dvaj1tHy6K" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Lisp WebDriver Macros</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-09-04T00:00:00+00:00" itemprop="datePublished">Sep 4, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1>About</h1>
<p>我想要在 Lisp 中实现类似于 Ruby 中 <a href="http://watir.com">watir</a> 类似的功能: 即控制一个游览器,
  这样就可以作为一个简单的, 但是高级的爬虫来爬取网站了.</p>
<p>仔细阅读代码, 并往上找依赖, 可以发现原理是 <a href="https://www.w3.org/TR/2024/WD-webdriver2-20240723/">WebDriver</a> 这个协议.
  那么问题就变成了该怎么实现这个协议了.</p>
<h1>协议省流版</h1>
<p>以我用的游览器 Safari (&gt; 10.1) 为例, 其在后端会开一个 WebDriver 服务:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">run-webdriver-server</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">port</span><span class="w"> </span><span class="nv">*webdriver-default-port*</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nf">uiop:launch-program</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="s">&quot;safaridriver&quot;</span><span class="w"> </span><span class="s">&quot;-p&quot;</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="s">&quot;~D&quot;</span><span class="w"> </span><span class="nv">port</span><span class="p">))))</span>
</pre></div>
<p>根据 <a href="https://www.w3.org/TR/2024/WD-webdriver2-20240723/#endpoints">Protocol | Endpoints</a> 中的说明, WebDriver 和 Client 之间通过 HTTP 进行通信,
  然后根据不同的方法 (method) 执行动作, 并返回对应的结果. 这里会以 JSON 进行传值.</p>
<p>比如参考 <a href="https://www.w3.org/TR/2024/WD-webdriver2-20240723/#dfn-new-sessions">New Session</a>, 这里可以做一个非常简单的 Client 的创建:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">json</span><span class="w">         </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="ss">&#39;equal</span><span class="p">))</span>
<span class="w">      </span><span class="p">(</span><span class="nf">capabilities</span><span class="w"> </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="ss">&#39;equal</span><span class="p">)))</span>
<span class="w">  </span><span class="c1">;; 这里构建的是一个 JSON Object:</span>
<span class="w">  </span><span class="c1">;; {</span>
<span class="w">  </span><span class="c1">;;   &quot;capabilities&quot;: { &quot;browserName&quot;: &quot;safari&quot; }</span>
<span class="w">  </span><span class="c1">;; }</span>
<span class="w">  </span><span class="c1">;; 使用 shasht 库进行 JSON 序列化</span>
<span class="w">  </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="s">&quot;browserName&quot;</span><span class="w"> </span><span class="nv">capabilities</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;safari&quot;</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="s">&quot;capabilities&quot;</span><span class="w"> </span><span class="nv">json</span><span class="p">)</span><span class="w"> </span><span class="nv">capabilities</span><span class="p">)</span>
<span class="w">  </span><span class="c1">;; 使用 dexador 库进行 HTTP 请求</span>
<span class="w">  </span><span class="p">(</span><span class="nf">dex:post</span><span class="w"> </span><span class="p">(</span><span class="nf">quri:make-uri-http</span><span class="w"> </span><span class="nv">:host</span><span class="w"> </span><span class="nv">*webdriver-default-address*</span>
<span class="w">				</span><span class="nv">:port</span><span class="w"> </span><span class="nv">*webdriver-default-port*</span>
<span class="w">				</span><span class="nv">:path</span><span class="w"> </span><span class="s">&quot;/session&quot;</span><span class="p">)</span>
<span class="w">	    </span><span class="c1">;; 发送的 POST 内容为 JSON Object</span>
<span class="w">	    </span><span class="nv">:content</span><span class="w"> </span><span class="p">(</span><span class="nf">shasht:write-json</span><span class="w"> </span><span class="nv">json</span><span class="w"> </span><span class="nv">nil</span><span class="p">)))</span>
</pre></div>
<p>其返回的结果是一个 JSON Object:</p>
<p>大概的形式类似于:</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;sessionId&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;一个 session id&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;capabilities&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="err">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>基本上所有的方法的返回值都是一个 JSON Object, 通过 <code>value</code> 项来得到具体的结果.
  那么接下来具体有啥方法, 该如何调用, 请看 <a href="https://www.w3.org/TR/2024/WD-webdriver2-20240723/#endpoints">Endpoint Table</a>.</p>
<h2>程序化地调用 method</h2>
<p>不难发现, 这些 method 的调用都几乎是一个套路:</p>
<ol>
  <li>POST 方法构建调用所需要的 JSON, GET 和 DELETE 则不需要;</li>
  <li>请求对应的方法, 然后解析返回值;
    <p>注: 这里暂时略去对于错误的处理 (详见 <a href="https://www.w3.org/TR/2024/WD-webdriver2-20240723/#errors">Errors</a> 一节), 后文中将会进行考虑.</p>
  </li>
  <li>处理返回的 JSON Object.</li>
</ol>
<p>那么完全可以将这个步骤变成一个固定的程序:</p>
<h3>POST 构建 JSON 输入</h3>
<p>构建一个输入的 List 到 Hash Table 再到 JSON 的快速输入:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">make-hash</span><span class="w"> </span><span class="p">(</span><span class="nf">&amp;body</span><span class="w"> </span><span class="nv">bindings</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Make a hash table from `bindings&#39;.</span>

<span class="s">Bindings shall be like:</span>

<span class="s">   ((</span><span class="se">\&quot;</span><span class="s">hash-key</span><span class="se">\&quot;</span><span class="s"> val-expr)</span>
<span class="s">    (...))</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">hash-table</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="w"> </span><span class="s">&quot;HASH-TABLE&quot;</span><span class="p">)))</span>
<span class="w">    </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="o">,</span><span class="nv">hash-table</span><span class="w"> </span><span class="p">(</span><span class="nb">make-hash-table</span><span class="w"> </span><span class="nv">:test</span><span class="w"> </span><span class="ss">&#39;equal</span><span class="p">)))</span>
<span class="w">       </span><span class="o">,@</span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="p">(</span><span class="nf">key</span><span class="w"> </span><span class="nv">val</span><span class="p">)</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">bindings</span>
<span class="w">	       </span><span class="nv">collect</span><span class="w"> </span><span class="o">`</span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="o">,</span><span class="nv">key</span><span class="w"> </span><span class="o">,</span><span class="nv">hash-table</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">val</span><span class="p">))</span>
<span class="w">       </span><span class="o">,</span><span class="nv">hash-table</span><span class="p">)))</span>
</pre></div>
<h3>解析 JSON Object 的 Hash Table</h3>
<p>会发现, 其实大部分的时候就是取 key, 然后得到 value 的过程:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">gethash*</span><span class="w"> </span><span class="p">(</span><span class="nf">key+</span><span class="w"> </span><span class="nv">hash-table</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Resursively get keys from `hash-table&#39;.</span>

<span class="s">The `key+&#39; shall be a list of hash-table key. &quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">endp</span><span class="w"> </span><span class="nv">key+</span><span class="p">)</span><span class="w"> </span><span class="nv">hash-table</span>
<span class="w">      </span><span class="o">`</span><span class="p">(</span><span class="nf">gethash*</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nf">rest</span><span class="w"> </span><span class="nv">key+</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">key+</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">hash-table</span><span class="p">))))</span>

<span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">let-hash</span><span class="w"> </span><span class="p">(</span><span class="nf">hash-table</span><span class="w"> </span><span class="nv">bindings</span><span class="w"> </span><span class="nv">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Extract values from `hash-table&#39; from `bindings&#39;.</span>

<span class="s">The `bindings&#39; could be like:</span>

<span class="s">    ((variable </span><span class="se">\&quot;</span><span class="s">key-tag</span><span class="se">\&quot;</span><span class="s">) -&gt; gethash</span>
<span class="s">     (variable (</span><span class="se">\&quot;</span><span class="s">key-tag</span><span class="se">\&quot;</span><span class="s"> </span><span class="se">\&quot;</span><span class="s">sub-hash-key-tag</span><span class="se">\&quot;</span><span class="s"> ...)) -&gt; gethash*</span>
<span class="s">     variable) -&gt; (variable </span><span class="se">\&quot;</span><span class="s">variable in camel-case</span><span class="se">\&quot;</span><span class="s">) -&gt; gethash</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nf">loop</span><span class="w"> </span><span class="nv">for</span><span class="w"> </span><span class="nv">binding</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">bindings</span>
<span class="w">	       </span><span class="nv">collect</span><span class="w"> </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">symbolp</span><span class="w"> </span><span class="nv">binding</span><span class="p">)</span>
<span class="w">			      </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nv">binding</span>
<span class="w">				</span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nf">str:camel-case</span><span class="w"> </span><span class="p">(</span><span class="nf">symbol-name</span><span class="w"> </span><span class="nv">binding</span><span class="p">))</span>
<span class="w">					 </span><span class="o">,</span><span class="nv">hash-table</span><span class="p">)))</span>
<span class="w">			     </span><span class="p">((</span><span class="nf">listp</span><span class="w"> </span><span class="nv">binding</span><span class="p">)</span>
<span class="w">			      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">listp</span><span class="w"> </span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="nv">binding</span><span class="p">))</span>
<span class="w">				  </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">binding</span><span class="p">)</span>
<span class="w">				    </span><span class="p">(</span><span class="nf">gethash*</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="nv">binding</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">hash-table</span><span class="p">))</span>
<span class="w">				  </span><span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="nv">binding</span><span class="p">)</span>
<span class="w">				    </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="o">,</span><span class="p">(</span><span class="nb">second</span><span class="w"> </span><span class="nv">binding</span><span class="p">)</span><span class="w"> </span><span class="o">,</span><span class="nv">hash-table</span><span class="p">))))</span>
<span class="w">			     </span><span class="p">(</span><span class="nf">t</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="w"> </span><span class="s">&quot;Malform bindings. &quot;</span><span class="p">))))</span>
<span class="w">     </span><span class="o">,@</span><span class="nv">body</span><span class="p">))</span>
</pre></div>
<h3>组合在一起</h3>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">%webdriver-method</span><span class="w"> </span><span class="p">(</span><span class="nf">method</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">content</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let*</span><span class="w"> </span><span class="p">((</span><span class="nf">url</span><span class="w"> </span><span class="p">(</span><span class="nf">quri:make-uri-http</span><span class="w"> </span><span class="nv">:host</span><span class="w"> </span><span class="nv">*webdriver-default-address*</span>
<span class="w">				  </span><span class="nv">:port</span><span class="w"> </span><span class="nv">*webdriver-default-port*</span>
<span class="w">				  </span><span class="nv">:path</span><span class="w"> </span><span class="nv">path</span><span class="p">))</span>
<span class="w">	 </span><span class="p">(</span><span class="nf">res</span><span class="w"> </span><span class="p">(</span><span class="nf">ecase</span><span class="w"> </span><span class="nv">method</span>
<span class="w">		</span><span class="p">(</span><span class="nf">:post</span><span class="w">   </span><span class="p">(</span><span class="nf">dex:post</span><span class="w"> </span><span class="nv">url</span><span class="w"> </span><span class="nv">:content</span><span class="w"> </span><span class="nv">content</span><span class="p">))</span>
<span class="w">		</span><span class="p">(</span><span class="nf">:get</span><span class="w">    </span><span class="p">(</span><span class="nf">dex:post</span><span class="w"> </span><span class="nv">url</span><span class="p">))</span>
<span class="w">		</span><span class="p">(</span><span class="nf">:delete</span><span class="w"> </span><span class="p">(</span><span class="nf">dex:delete</span><span class="w"> </span><span class="nv">url</span><span class="p">)))))</span>
<span class="w">    </span><span class="p">(</span><span class="nf">gethash</span><span class="w"> </span><span class="s">&quot;value&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">shasht:read-json</span><span class="w"> </span><span class="nv">res</span><span class="p">))))</span>


<span class="p">(</span><span class="k">defmacro</span><span class="w"> </span><span class="nv">with-webdriver-post</span><span class="w"> </span><span class="p">(</span><span class="nf">path</span><span class="w"> </span><span class="nv">json</span><span class="w"> </span><span class="nv">bindings</span><span class="w"> </span><span class="nv">&amp;body</span><span class="w"> </span><span class="nv">body</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;With WebDriver POST method at `path&#39;.</span>

<span class="s">Post content is `json&#39; -&gt; `make-hash&#39;;</span>
<span class="s">Response result will parsed with `bindings&#39; &lt;- `let-hash&#39;.</span>
<span class="s">&quot;</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">object</span><span class="w"> </span><span class="p">(</span><span class="nb">gensym</span><span class="w"> </span><span class="s">&quot;OBJECT&quot;</span><span class="p">)))</span>
<span class="w">    </span><span class="o">`</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="o">,</span><span class="nv">object</span><span class="w"> </span><span class="p">(</span><span class="nf">%webdriver-method</span>
<span class="w">		     </span><span class="nv">:post</span><span class="w"> </span><span class="o">,</span><span class="nv">path</span>
<span class="w">		     </span><span class="p">(</span><span class="nf">shasht:write-json</span><span class="w"> </span><span class="p">(</span><span class="nf">make-hash</span><span class="w"> </span><span class="o">,@</span><span class="nv">json</span><span class="p">)</span><span class="w"> </span><span class="nv">nil</span><span class="p">))))</span>
<span class="w">       </span><span class="p">(</span><span class="nf">let-hash</span><span class="w"> </span><span class="o">,</span><span class="nv">object</span><span class="w"> </span><span class="o">,</span><span class="nv">bindings</span><span class="w"> </span><span class="o">,@</span><span class="nv">body</span><span class="p">))))</span>
</pre></div>
<p>于是一个 POST 的请求就得到了:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">with-webdriver-post</span><span class="w"> </span><span class="s">&quot;/session&quot;</span>
<span class="w">    </span><span class="p">((</span><span class="s">&quot;capabilities&quot;</span><span class="w"> </span><span class="p">(</span><span class="nf">make-hash</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;browserName&quot;</span><span class="w"> </span><span class="s">&quot;safari&quot;</span><span class="p">))))</span>
<span class="w">    </span><span class="p">((</span><span class="nf">session-id</span><span class="w"> </span><span class="s">&quot;sessionId&quot;</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="s">&quot;~A&quot;</span><span class="w"> </span><span class="nv">session-id</span><span class="p">))</span>
</pre></div>
<p>同理还可以实现其他 GET 和 DELETE 的方法.</p>
<h3>一些写 Lisp 宏展开的小技巧</h3>
<p>(不保真, 毕竟只是个人的体会)</p>
<ul>
  <li>不要试图在一个宏展开中解决所有的问题
    <p>因为用户输入肯定是千奇百怪的, 在一个宏展开里面做 parse 只会让代码变得丑陋不堪,
      并且如果这样的展开是合理的, 那么这种展开方式应当可以被自然地拓展到其他的地方,
      而只在一个宏展开实现就会导致其他的宏展开中会存在许多重复的代码.</p>
  </li>
  <li>通过把复杂的模式匹配 fallback 到简单的模式匹配上
    <p>比如根据输入的形式为符号, 列表, 亦或是其他, 上层做的只是对模式进行判断,
      然后匹配到对应的模式展开宏而不是在上层中直接实现.</p>
  </li>
  <li>如何构造宏展开
    <p>可以在已经有的简单代码上进行修改, 通过删除部分代码和逻辑并替换为程序化生成的部分,
      从而实现代码到宏. 这样的缺点往往是动力不强, 毕竟已经实现的代码重新花时间想怎么改,
      怎么听都有一种让人提不起来劲的感觉.</p>
    <p>唯一的正反馈估计就是代码更加整洁, 并且可读性大大增强了吧.</p>
  </li>
  <li>Layered Programming
    <p>感觉这个点很有意思, 以后可以进一步了解.</p>
  </li>
</ul>
<h2>重新包装, 将 Session 作为类进行调用</h2>
<p>既然已经实现了简单的方法 (method) 调用, 那么就改给这个 WebDriver 提供一个 Lispy
  的一个绑定了.</p>
<p>注: 因为我只用少部分的功能, 所以并不会完全实现所有的协议,
  不过既然都已经实现了一个通用的调用接口了, 还怕后面实现有困难么?</p>
<h3>错误的处理</h3>
<p>根据 <a href="https://www.w3.org/TR/2024/WD-webdriver2-20240723/#errors">Errors</a> 中的说明, 在 HTTP 代码为 <code>4xx</code> 和 <code>5xx</code> 的时候, 返回一个 JSON Object
  作为错误的值的具体内容:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">define-condition</span><span class="w"> </span><span class="nv">webdriver-error</span><span class="w"> </span><span class="p">(</span><span class="nb">error</span><span class="p">)</span>
<span class="w">  </span><span class="p">((</span><span class="nf">error-message</span><span class="w"> </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:message</span>
<span class="w">		  </span><span class="nv">:reader</span><span class="w">  </span><span class="nv">error-message</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nf">error-code</span><span class="w">    </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:error-code</span>
<span class="w">		  </span><span class="nv">:reader</span><span class="w">  </span><span class="nv">error-code</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nf">stacktrace</span><span class="w">    </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:stacktrace</span>
<span class="w">		  </span><span class="nv">:reader</span><span class="w">  </span><span class="nv">error-stacktrace</span><span class="p">)</span>
<span class="w">   </span><span class="p">(</span><span class="nf">optional-data</span><span class="w"> </span><span class="nv">:initarg</span><span class="w"> </span><span class="nv">:data</span>
<span class="w">		  </span><span class="nv">:reader</span><span class="w">  </span><span class="nv">error-optional-data</span><span class="p">)))</span>
</pre></div>
<h1>后记</h1>
<p>其实写到这里我真的很想把这个项目做得比较完整一些, 但是手上出现了更加紧迫的问题:
  如何在 Emacs 中使用 Mathematica (或者 Wolfram Engine). 并且最好还能是有一个类似
  SLY 这样的 REPL 和自动补全的功能.</p>
<p>另一个并不是很紧迫的想法: 如何用 Emacs + ffmpeg 进行剪视频 (最近打游戏录了一些视频,
  寄希望于通过这种低质量视频来换取一些视频平台的创作激励, 给自己来点额外收入&#8230; )</p>
<p>虽然到了大四感觉事情少了一些, 实际上却感觉因为太摆烂了所以反而时间少了很多&#8230;</p>
<p>(乐, 貌似这篇文章写完了, 但是没发? )</p>

  </div><a class="u-url" href="/lisp/lisp-webdriver-macros/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
