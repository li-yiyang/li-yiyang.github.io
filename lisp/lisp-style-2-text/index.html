<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Lisp Style Guide | My Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Lisp Style Guide" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="About 以下是一篇在 CMU Lisp Style Guide 中的 Lisp 风格指南的简单翻译和笔记. (注: 应该是部分的翻译. ) How to be a Stylish Lisp Programmer General Programming Style 短的函数 (易读, 易写, 易调试, 易懂) 说明性的变量/函数名称 Lisp Specific Guidelines 别像 Pascal 或者 C 代码一样写 Lisp 尽量用已有的函数 &#8211; 参考 CLtL2 或者使用 apropos 或者 describe. 不要让括号单独成行 &#8211; 代码结构应当通过缩进表现. 大多数 Lisp 系的编辑器都包含了自动括号配对, 括号间跳转, 括号操作, 自动代码缩进的功能. 如果刚接触 Lisp, 请避免使用下面的函数/宏/特殊形式 &#8211; 大部分时间你没必要用它们: eval, progv, catch, throw, block, 以及 return-from. 类似的, 尽量避免破坏性 (带副作用的) 的函数, 如 nconc, sort, delete, rplaca, 以及 replacd. 因为它们可能不会如你所愿地工作. 如果你一定要用 rplaca 和 rplacd, 请使用 (setf (car ...) ..) 以及 (setf (cdr ..) ..) 来代替. 避免使用 prog, go 以及 tagbody. 请直接使用循环函数或者写一个递归函数来代替. 不要用类似 c{a,d}r 这样但是 c, r 中间 a, d 数量超过两个即以上的函数 (如 cddr, cadar 等), 因为它们真的很难读. 请使用 first, second, third, nth 以及 nthcdr 来代替. 使用 cond 来代替 if 和 progn 的组合. 使用 cond 而不是嵌套的 if. 请记住要检查并排除不可能发生 cond 条件分支. 不要使用单条件分支或者某一个条件分支返回值为 nil 的 if. 使用 when 或者 unless 来代替. 尽可能使用局部变量而不是全局变量. 用 let 或者 let* 来定义局部变量. 如果一定要使用全局变量, 用 * 包围名字的方式来对全局变量进行命名, 这有助于其在代码中容易被看出来. 当 nil 被用于做空列表时, 请使用 () 做字面量. 当 nil 被用于布尔运算时, 请使用 nil 做字面量. 类似的, 使用 null 来判断空列表; not 来判断逻辑值. 使用 endp 来判断是否是列表的尾部, 而不是 null. 当能够用 dotimes 或者 dolist 时, 不要用 do. 能用 let 时不要用 let*. 能用 flet 时不要用 labels. 能用 do 时不要用 do*. 不要在 case 判断中使用 quote. 如 (case x (&#39;a 3) ..), 这时不对的, 因为这会等价于判断 x 是否是 =&#39;(quote a)=. 使用 (case x (a 3)) 来代替. 避免用 apply 来将列表进行扁平化. 函数可能会接受有限个参数, 而构造类似于 (apply #&#39;append list-of-lists) 可能会产生冲突. 不要在你之后想要按结构修改的地方使用 quote. 比如: (defun foo () (let ((var &#39;(c d))) ..)) 不要用 =&#39;(c d)=, 而是用 (list &#39;c &#39;d). 不要混淆 listp 和 consp. consp 将会判断是否是 cons 的结构, 即对 nil 会返回 nil, 而 listp 更类似于: (defun listp (x) (or (null x) (consp x))) 当对两个数做除法的时候, 如果想要得到一个实数的话, 记得使用 tuncate 和 round, 否则可能会得到一个分数. Documentation 在 top-level expression 的前后至少放一行空行. 对于左对齐的注释, 使用 ;;; 三个分号开头. 你可以在这里描述一些类似于代码功能, 使用的算法, 以及其他的解释性的文字. 在函数定义的时候带上 documentation string. 有助于帮助用户了解函数功能. 对于和代码平齐浮动的注释, 使用 ;; 两个分号开头. 大多数 Lisp 系的编辑器可以根据代码自动缩进这些注释. 对于代码右侧的短注释, 使用 ; 一个分号开头. 感性地认识就是, 使用的分号的大概和注释的长度差不多. 如果你需要注释一小段代码, 使用左对齐的单个分号. Examples Documentation ;;; A function to compute the nth fibonacci number. (defun fib (n) &quot;Returns the nth Fibonacci number, where f(n) = f(n-1) + f(n-2); f(1)=f(0)=1.&quot; ;; check for the two base cases, otherwise recurse (cond ((zerop n) 1) ; zerop is potentially faster than (= n 0) ((= n 1) 1) (t (+ (fib (1- n)) (fib (- n 2)))))) Control Structures Poor style: (if &lt;condition&gt; (progn &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;)) Good style: (when &lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;) Poor style: (if &lt;condition&gt; nil (progn &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;)) Good style: (unless &lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;) Poor style: (if &lt;condition&gt; (progn &lt;statement1&gt; &lt;statement2&gt;) (progn &lt;statement3&gt; &lt;statement4&gt;)) Good style: (cond (&lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt;) (t &lt;statement3&gt; &lt;statement4&gt;)) Poor style: (if &lt;condition1&gt; &lt;statement1&gt; (if &lt;condition2&gt; &lt;statement2&gt; (if &lt;condition3&gt; &lt;statement3&gt;))) Good style: (cond (&lt;condition1&gt; &lt;statement1&gt;) (&lt;condition2&gt; &lt;statement2&gt;) (&lt;condition3&gt; &lt;statement3&gt;)) Poor style: (cond (&lt;condition&gt; t) (t &lt;statement&gt;)) Good style: (if &lt;condition&gt; t &lt;statement&gt;) Poor style: (defun function (arg1 arg2) (setf local1 value1) (setf local2 value2) &lt;statement&gt;) Good style: (defun function (arg1 arg2) (let ((local1 value1) (local2 value2)) &lt;statement&gt;)) 在上面的 setf 的例子里面, local1 和 local2 实际上是在函数外也是可见的全局变量. 而 let 构造的局部变量仅仅在 let 声明的环境中可见. Iteration 递归的一个模版 (defun function (arg1 arg2) (if end-condition return-result recurse)) 例: (defun factorial (n) (if (zerop n) 1 (* n (factorial (1- n)))))" />
<meta property="og:description" content="About 以下是一篇在 CMU Lisp Style Guide 中的 Lisp 风格指南的简单翻译和笔记. (注: 应该是部分的翻译. ) How to be a Stylish Lisp Programmer General Programming Style 短的函数 (易读, 易写, 易调试, 易懂) 说明性的变量/函数名称 Lisp Specific Guidelines 别像 Pascal 或者 C 代码一样写 Lisp 尽量用已有的函数 &#8211; 参考 CLtL2 或者使用 apropos 或者 describe. 不要让括号单独成行 &#8211; 代码结构应当通过缩进表现. 大多数 Lisp 系的编辑器都包含了自动括号配对, 括号间跳转, 括号操作, 自动代码缩进的功能. 如果刚接触 Lisp, 请避免使用下面的函数/宏/特殊形式 &#8211; 大部分时间你没必要用它们: eval, progv, catch, throw, block, 以及 return-from. 类似的, 尽量避免破坏性 (带副作用的) 的函数, 如 nconc, sort, delete, rplaca, 以及 replacd. 因为它们可能不会如你所愿地工作. 如果你一定要用 rplaca 和 rplacd, 请使用 (setf (car ...) ..) 以及 (setf (cdr ..) ..) 来代替. 避免使用 prog, go 以及 tagbody. 请直接使用循环函数或者写一个递归函数来代替. 不要用类似 c{a,d}r 这样但是 c, r 中间 a, d 数量超过两个即以上的函数 (如 cddr, cadar 等), 因为它们真的很难读. 请使用 first, second, third, nth 以及 nthcdr 来代替. 使用 cond 来代替 if 和 progn 的组合. 使用 cond 而不是嵌套的 if. 请记住要检查并排除不可能发生 cond 条件分支. 不要使用单条件分支或者某一个条件分支返回值为 nil 的 if. 使用 when 或者 unless 来代替. 尽可能使用局部变量而不是全局变量. 用 let 或者 let* 来定义局部变量. 如果一定要使用全局变量, 用 * 包围名字的方式来对全局变量进行命名, 这有助于其在代码中容易被看出来. 当 nil 被用于做空列表时, 请使用 () 做字面量. 当 nil 被用于布尔运算时, 请使用 nil 做字面量. 类似的, 使用 null 来判断空列表; not 来判断逻辑值. 使用 endp 来判断是否是列表的尾部, 而不是 null. 当能够用 dotimes 或者 dolist 时, 不要用 do. 能用 let 时不要用 let*. 能用 flet 时不要用 labels. 能用 do 时不要用 do*. 不要在 case 判断中使用 quote. 如 (case x (&#39;a 3) ..), 这时不对的, 因为这会等价于判断 x 是否是 =&#39;(quote a)=. 使用 (case x (a 3)) 来代替. 避免用 apply 来将列表进行扁平化. 函数可能会接受有限个参数, 而构造类似于 (apply #&#39;append list-of-lists) 可能会产生冲突. 不要在你之后想要按结构修改的地方使用 quote. 比如: (defun foo () (let ((var &#39;(c d))) ..)) 不要用 =&#39;(c d)=, 而是用 (list &#39;c &#39;d). 不要混淆 listp 和 consp. consp 将会判断是否是 cons 的结构, 即对 nil 会返回 nil, 而 listp 更类似于: (defun listp (x) (or (null x) (consp x))) 当对两个数做除法的时候, 如果想要得到一个实数的话, 记得使用 tuncate 和 round, 否则可能会得到一个分数. Documentation 在 top-level expression 的前后至少放一行空行. 对于左对齐的注释, 使用 ;;; 三个分号开头. 你可以在这里描述一些类似于代码功能, 使用的算法, 以及其他的解释性的文字. 在函数定义的时候带上 documentation string. 有助于帮助用户了解函数功能. 对于和代码平齐浮动的注释, 使用 ;; 两个分号开头. 大多数 Lisp 系的编辑器可以根据代码自动缩进这些注释. 对于代码右侧的短注释, 使用 ; 一个分号开头. 感性地认识就是, 使用的分号的大概和注释的长度差不多. 如果你需要注释一小段代码, 使用左对齐的单个分号. Examples Documentation ;;; A function to compute the nth fibonacci number. (defun fib (n) &quot;Returns the nth Fibonacci number, where f(n) = f(n-1) + f(n-2); f(1)=f(0)=1.&quot; ;; check for the two base cases, otherwise recurse (cond ((zerop n) 1) ; zerop is potentially faster than (= n 0) ((= n 1) 1) (t (+ (fib (1- n)) (fib (- n 2)))))) Control Structures Poor style: (if &lt;condition&gt; (progn &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;)) Good style: (when &lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;) Poor style: (if &lt;condition&gt; nil (progn &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;)) Good style: (unless &lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;) Poor style: (if &lt;condition&gt; (progn &lt;statement1&gt; &lt;statement2&gt;) (progn &lt;statement3&gt; &lt;statement4&gt;)) Good style: (cond (&lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt;) (t &lt;statement3&gt; &lt;statement4&gt;)) Poor style: (if &lt;condition1&gt; &lt;statement1&gt; (if &lt;condition2&gt; &lt;statement2&gt; (if &lt;condition3&gt; &lt;statement3&gt;))) Good style: (cond (&lt;condition1&gt; &lt;statement1&gt;) (&lt;condition2&gt; &lt;statement2&gt;) (&lt;condition3&gt; &lt;statement3&gt;)) Poor style: (cond (&lt;condition&gt; t) (t &lt;statement&gt;)) Good style: (if &lt;condition&gt; t &lt;statement&gt;) Poor style: (defun function (arg1 arg2) (setf local1 value1) (setf local2 value2) &lt;statement&gt;) Good style: (defun function (arg1 arg2) (let ((local1 value1) (local2 value2)) &lt;statement&gt;)) 在上面的 setf 的例子里面, local1 和 local2 实际上是在函数外也是可见的全局变量. 而 let 构造的局部变量仅仅在 let 声明的环境中可见. Iteration 递归的一个模版 (defun function (arg1 arg2) (if end-condition return-result recurse)) 例: (defun factorial (n) (if (zerop n) 1 (* n (factorial (1- n)))))" />
<link rel="canonical" href="/lisp/lisp-style-2-text/" />
<meta property="og:url" content="/lisp/lisp-style-2-text/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-03-11T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Lisp Style Guide" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-03-11T00:00:00+00:00","datePublished":"2024-03-11T00:00:00+00:00","description":"About 以下是一篇在 CMU Lisp Style Guide 中的 Lisp 风格指南的简单翻译和笔记. (注: 应该是部分的翻译. ) How to be a Stylish Lisp Programmer General Programming Style 短的函数 (易读, 易写, 易调试, 易懂) 说明性的变量/函数名称 Lisp Specific Guidelines 别像 Pascal 或者 C 代码一样写 Lisp 尽量用已有的函数 &#8211; 参考 CLtL2 或者使用 apropos 或者 describe. 不要让括号单独成行 &#8211; 代码结构应当通过缩进表现. 大多数 Lisp 系的编辑器都包含了自动括号配对, 括号间跳转, 括号操作, 自动代码缩进的功能. 如果刚接触 Lisp, 请避免使用下面的函数/宏/特殊形式 &#8211; 大部分时间你没必要用它们: eval, progv, catch, throw, block, 以及 return-from. 类似的, 尽量避免破坏性 (带副作用的) 的函数, 如 nconc, sort, delete, rplaca, 以及 replacd. 因为它们可能不会如你所愿地工作. 如果你一定要用 rplaca 和 rplacd, 请使用 (setf (car ...) ..) 以及 (setf (cdr ..) ..) 来代替. 避免使用 prog, go 以及 tagbody. 请直接使用循环函数或者写一个递归函数来代替. 不要用类似 c{a,d}r 这样但是 c, r 中间 a, d 数量超过两个即以上的函数 (如 cddr, cadar 等), 因为它们真的很难读. 请使用 first, second, third, nth 以及 nthcdr 来代替. 使用 cond 来代替 if 和 progn 的组合. 使用 cond 而不是嵌套的 if. 请记住要检查并排除不可能发生 cond 条件分支. 不要使用单条件分支或者某一个条件分支返回值为 nil 的 if. 使用 when 或者 unless 来代替. 尽可能使用局部变量而不是全局变量. 用 let 或者 let* 来定义局部变量. 如果一定要使用全局变量, 用 * 包围名字的方式来对全局变量进行命名, 这有助于其在代码中容易被看出来. 当 nil 被用于做空列表时, 请使用 () 做字面量. 当 nil 被用于布尔运算时, 请使用 nil 做字面量. 类似的, 使用 null 来判断空列表; not 来判断逻辑值. 使用 endp 来判断是否是列表的尾部, 而不是 null. 当能够用 dotimes 或者 dolist 时, 不要用 do. 能用 let 时不要用 let*. 能用 flet 时不要用 labels. 能用 do 时不要用 do*. 不要在 case 判断中使用 quote. 如 (case x (&#39;a 3) ..), 这时不对的, 因为这会等价于判断 x 是否是 =&#39;(quote a)=. 使用 (case x (a 3)) 来代替. 避免用 apply 来将列表进行扁平化. 函数可能会接受有限个参数, 而构造类似于 (apply #&#39;append list-of-lists) 可能会产生冲突. 不要在你之后想要按结构修改的地方使用 quote. 比如: (defun foo () (let ((var &#39;(c d))) ..)) 不要用 =&#39;(c d)=, 而是用 (list &#39;c &#39;d). 不要混淆 listp 和 consp. consp 将会判断是否是 cons 的结构, 即对 nil 会返回 nil, 而 listp 更类似于: (defun listp (x) (or (null x) (consp x))) 当对两个数做除法的时候, 如果想要得到一个实数的话, 记得使用 tuncate 和 round, 否则可能会得到一个分数. Documentation 在 top-level expression 的前后至少放一行空行. 对于左对齐的注释, 使用 ;;; 三个分号开头. 你可以在这里描述一些类似于代码功能, 使用的算法, 以及其他的解释性的文字. 在函数定义的时候带上 documentation string. 有助于帮助用户了解函数功能. 对于和代码平齐浮动的注释, 使用 ;; 两个分号开头. 大多数 Lisp 系的编辑器可以根据代码自动缩进这些注释. 对于代码右侧的短注释, 使用 ; 一个分号开头. 感性地认识就是, 使用的分号的大概和注释的长度差不多. 如果你需要注释一小段代码, 使用左对齐的单个分号. Examples Documentation ;;; A function to compute the nth fibonacci number. (defun fib (n) &quot;Returns the nth Fibonacci number, where f(n) = f(n-1) + f(n-2); f(1)=f(0)=1.&quot; ;; check for the two base cases, otherwise recurse (cond ((zerop n) 1) ; zerop is potentially faster than (= n 0) ((= n 1) 1) (t (+ (fib (1- n)) (fib (- n 2)))))) Control Structures Poor style: (if &lt;condition&gt; (progn &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;)) Good style: (when &lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;) Poor style: (if &lt;condition&gt; nil (progn &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;)) Good style: (unless &lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt; &lt;statement3&gt;) Poor style: (if &lt;condition&gt; (progn &lt;statement1&gt; &lt;statement2&gt;) (progn &lt;statement3&gt; &lt;statement4&gt;)) Good style: (cond (&lt;condition&gt; &lt;statement1&gt; &lt;statement2&gt;) (t &lt;statement3&gt; &lt;statement4&gt;)) Poor style: (if &lt;condition1&gt; &lt;statement1&gt; (if &lt;condition2&gt; &lt;statement2&gt; (if &lt;condition3&gt; &lt;statement3&gt;))) Good style: (cond (&lt;condition1&gt; &lt;statement1&gt;) (&lt;condition2&gt; &lt;statement2&gt;) (&lt;condition3&gt; &lt;statement3&gt;)) Poor style: (cond (&lt;condition&gt; t) (t &lt;statement&gt;)) Good style: (if &lt;condition&gt; t &lt;statement&gt;) Poor style: (defun function (arg1 arg2) (setf local1 value1) (setf local2 value2) &lt;statement&gt;) Good style: (defun function (arg1 arg2) (let ((local1 value1) (local2 value2)) &lt;statement&gt;)) 在上面的 setf 的例子里面, local1 和 local2 实际上是在函数外也是可见的全局变量. 而 let 构造的局部变量仅仅在 let 声明的环境中可见. Iteration 递归的一个模版 (defun function (arg1 arg2) (if end-condition return-result recurse)) 例: (defun factorial (n) (if (zerop n) 1 (* n (factorial (1- n)))))","headline":"Lisp Style Guide","mainEntityOfPage":{"@type":"WebPage","@id":"/lisp/lisp-style-2-text/"},"url":"/lisp/lisp-style-2-text/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">

  <style type="text/css">
    img {
      margin-left: auto; 
      margin-right:auto; 
      display:block;
    }
  </style><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="My Blog" /><script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        // • rendering keys, e.g.:
        throwOnError : false
      });
  });
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.css" integrity="sha384-z91AFMXXGZasvxZz5DtKJse3pKoTPU0QcNFj/B4gDFRmq6Q2bi1StsT7SOcIzLEN" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.js" integrity="sha384-Af7YmksQNWRLMvro3U9F84xa0paoIu7Pu2niAIUmZoI09Q4aCsbha5dvaj1tHy6K" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Lisp Style Guide</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-03-11T00:00:00+00:00" itemprop="datePublished">Mar 11, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1>About</h1>
<p>以下是一篇在 <a href="https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/txt/style/">CMU Lisp Style Guide</a> 中的 Lisp 风格指南的简单翻译和笔记.</p>
<p>(注: 应该是部分的翻译. )</p>
<h1>How to be a Stylish Lisp Programmer</h1>
<h2>General Programming Style</h2>
<ul>
  <li>短的函数 (易读, 易写, 易调试, 易懂)</li>
  <li>说明性的变量/函数名称</li>
</ul>
<h2>Lisp Specific Guidelines</h2>
<ul>
  <li>别像 Pascal 或者 C 代码一样写 Lisp
    <ul>
      <li>尽量用已有的函数 &#8211; 参考 <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">CLtL2</a> 或者使用 <code>apropos</code> 或者 <code>describe</code>.</li>
      <li>不要让括号单独成行 &#8211; 代码结构应当通过缩进表现.
        大多数 Lisp 系的编辑器都包含了自动括号配对, 括号间跳转, 括号操作,
        自动代码缩进的功能.</li>
    </ul>
  </li>
  <li>如果刚接触 Lisp, 请避免使用下面的函数/宏/特殊形式 &#8211; 大部分时间你没必要用它们:
    <code>eval</code>, <code>progv</code>, <code>catch</code>, <code>throw</code>, <code>block</code>, 以及 <code>return-from</code>. 类似的, 尽量避免破坏性
    (带副作用的) 的函数, 如 <code>nconc</code>, <code>sort</code>, <code>delete</code>, <code>rplaca</code>, 以及 <code>replacd</code>.
    因为它们可能不会如你所愿地工作. 如果你一定要用 <code>rplaca</code> 和 <code>rplacd</code>,
    请使用 <code>(setf (car ...) ..)</code> 以及 <code>(setf (cdr ..) ..)</code> 来代替.</li>
  <li>避免使用 <code>prog</code>, <code>go</code> 以及 <code>tagbody</code>. 请直接使用循环函数或者写一个递归函数来代替.</li>
  <li>不要用类似 <code>c{a,d}r</code> 这样但是 <code>c</code>, <code>r</code> 中间 <code>a</code>, <code>d</code> 数量超过两个即以上的函数
    (如 <code>cddr</code>, <code>cadar</code> 等), 因为它们真的很难读. 请使用 <code>first</code>, <code>second</code>, <code>third</code>,
    <code>nth</code> 以及 <code>nthcdr</code> 来代替.</li>
  <li>使用 <code>cond</code> 来代替 <code>if</code> 和 <code>progn</code> 的组合. 使用 <code>cond</code> 而不是嵌套的 <code>if</code>.
    请记住要检查并排除不可能发生 <code>cond</code> 条件分支.</li>
  <li>不要使用单条件分支或者某一个条件分支返回值为 <code>nil</code> 的 <code>if</code>. 使用 <code>when</code> 或者
    <code>unless</code> 来代替.</li>
  <li>尽可能使用局部变量而不是全局变量. 用 <code>let</code> 或者 <code>let*</code> 来定义局部变量.
    如果一定要使用全局变量, 用 <code>*</code> 包围名字的方式来对全局变量进行命名,
    这有助于其在代码中容易被看出来.</li>
  <li>当 <code>nil</code> 被用于做空列表时, 请使用 <code>()</code> 做字面量.
    当 <code>nil</code> 被用于布尔运算时, 请使用 <code>nil</code> 做字面量.
    类似的, 使用 <code>null</code> 来判断空列表; <code>not</code> 来判断逻辑值.
    使用 <code>endp</code> 来判断是否是列表的尾部, 而不是 <code>null</code>.</li>
  <li>当能够用 <code>dotimes</code> 或者 <code>dolist</code> 时, 不要用 <code>do</code>.
    能用 <code>let</code> 时不要用 <code>let*</code>.
    能用 <code>flet</code> 时不要用 <code>labels</code>.
    能用 <code>do</code> 时不要用 <code>do*</code>.</li>
  <li>不要在 <code>case</code> 判断中使用 <code>quote</code>. 如 <code>(case x (&#39;a 3) ..)</code>, 这时不对的,
    因为这会等价于判断 <code>x</code> 是否是 ='(quote a)=. 使用 <code>(case x (a 3))</code> 来代替.</li>
  <li>避免用 <code>apply</code> 来将列表进行扁平化. 函数可能会接受有限个参数,
    而构造类似于 <code>(apply #&#39;append list-of-lists)</code> 可能会产生冲突.</li>
  <li>不要在你之后想要按结构修改的地方使用 <code>quote</code>. 比如:
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="p">()</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">var</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span><span class="w"> </span><span class="nv">d</span><span class="p">)))</span>
<span class="w">    </span><span class="o">..</span><span class="p">))</span>
</pre></div>
    <p>不要用 ='(c d)=, 而是用 <code>(list &#39;c &#39;d)</code>.</p>
  </li>
  <li>不要混淆 <code>listp</code> 和 <code>consp</code>. <code>consp</code> 将会判断是否是 cons 的结构, 即对 <code>nil</code>
    会返回 <code>nil</code>, 而 <code>listp</code> 更类似于:
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">listp</span><span class="w"> </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="nf">null</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">consp</span><span class="w"> </span><span class="nv">x</span><span class="p">)))</span>
</pre></div>
  </li>
  <li>当对两个数做除法的时候, 如果想要得到一个实数的话, 记得使用 <code>tuncate</code>
    和 <code>round</code>, 否则可能会得到一个分数.</li>
</ul>
<h2>Documentation</h2>
<ul>
  <li>在 top-level expression 的前后至少放一行空行.</li>
  <li>对于左对齐的注释, 使用 <code>;;;</code> 三个分号开头. 你可以在这里描述一些类似于代码功能,
    使用的算法, 以及其他的解释性的文字.</li>
  <li>在函数定义的时候带上 documentation string. 有助于帮助用户了解函数功能.</li>
  <li>对于和代码平齐浮动的注释, 使用 <code>;;</code> 两个分号开头. 大多数 Lisp
    系的编辑器可以根据代码自动缩进这些注释.</li>
  <li>对于代码右侧的短注释, 使用 <code>;</code> 一个分号开头.</li>
  <li>感性地认识就是, 使用的分号的大概和注释的长度差不多.</li>
  <li>如果你需要注释一小段代码, 使用左对齐的单个分号.</li>
</ul>
<h2>Examples</h2>
<h3>Documentation</h3>
<div class="highlight"><pre><span></span><span class="c1">;;; A function to compute the nth fibonacci number.</span>
<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">fib</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
<span class="w">  </span><span class="s">&quot;Returns the nth Fibonacci number, where f(n) = f(n-1) + f(n-2); f(1)=f(0)=1.&quot;</span>
<span class="w">  </span><span class="c1">;; check for the two base cases, otherwise recurse</span>
<span class="w">  </span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">((</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c1">; zerop is potentially faster than (= n 0)</span>
<span class="w">        </span><span class="p">((</span><span class="nb">=</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">t</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="p">(</span><span class="nf">fib</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">n</span><span class="p">))</span>
<span class="w">              </span><span class="p">(</span><span class="nf">fib</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="mi">2</span><span class="p">))))))</span>
</pre></div>
<h3>Control Structures</h3>
<p><b>Poor style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">&lt;condition&gt;</span>
<span class="w">    </span><span class="p">(</span><span class="nf">progn</span><span class="w"> </span><span class="nv">&lt;statement1&gt;</span>
<span class="w">           </span><span class="nv">&lt;statement2&gt;</span>
<span class="w">           </span><span class="nv">&lt;statement3&gt;</span><span class="p">))</span>
</pre></div>
<p><b>Good style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">when</span><span class="w"> </span><span class="nv">&lt;condition&gt;</span>
<span class="w">  </span><span class="nv">&lt;statement1&gt;</span>
<span class="w">  </span><span class="nv">&lt;statement2&gt;</span>
<span class="w">  </span><span class="nv">&lt;statement3&gt;</span><span class="p">)</span>
</pre></div>
<p><b>Poor style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">&lt;condition&gt;</span>
<span class="w">    </span><span class="nv">nil</span>
<span class="w">    </span><span class="p">(</span><span class="nf">progn</span><span class="w"> </span><span class="nv">&lt;statement1&gt;</span>
<span class="w">           </span><span class="nv">&lt;statement2&gt;</span>
<span class="w">           </span><span class="nv">&lt;statement3&gt;</span><span class="p">))</span>
</pre></div>
<p><b>Good style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">unless</span><span class="w"> </span><span class="nv">&lt;condition&gt;</span>
<span class="w">  </span><span class="nv">&lt;statement1&gt;</span>
<span class="w">  </span><span class="nv">&lt;statement2&gt;</span>
<span class="w">  </span><span class="nv">&lt;statement3&gt;</span><span class="p">)</span>
</pre></div>
<p><b>Poor style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">&lt;condition&gt;</span>
<span class="w">    </span><span class="p">(</span><span class="nf">progn</span><span class="w"> </span><span class="nv">&lt;statement1&gt;</span>
<span class="w">           </span><span class="nv">&lt;statement2&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nf">progn</span><span class="w"> </span><span class="nv">&lt;statement3&gt;</span>
<span class="w">           </span><span class="nv">&lt;statement4&gt;</span><span class="p">))</span>
</pre></div>
<p><b>Good style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;condition&gt;</span>
<span class="w">       </span><span class="nv">&lt;statement1&gt;</span><span class="w"> </span><span class="nv">&lt;statement2&gt;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">t</span><span class="w"> </span><span class="nv">&lt;statement3&gt;</span><span class="w"> </span><span class="nv">&lt;statement4&gt;</span><span class="p">))</span>
</pre></div>
<p><b>Poor style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">&lt;condition1&gt;</span>
<span class="w">    </span><span class="nv">&lt;statement1&gt;</span>
<span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">&lt;condition2&gt;</span>
<span class="w">        </span><span class="nv">&lt;statement2&gt;</span>
<span class="w">        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">&lt;condition3&gt;</span>
<span class="w">            </span><span class="nv">&lt;statement3&gt;</span><span class="p">)))</span>
</pre></div>
<p><b>Good style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;condition1&gt;</span><span class="w"> </span><span class="nv">&lt;statement1&gt;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">&lt;condition2&gt;</span><span class="w"> </span><span class="nv">&lt;statement2&gt;</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">&lt;condition3&gt;</span><span class="w"> </span><span class="nv">&lt;statement3&gt;</span><span class="p">))</span>
</pre></div>
<p><b>Poor style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">cond</span><span class="w"> </span><span class="p">(</span><span class="nf">&lt;condition&gt;</span><span class="w"> </span><span class="nv">t</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nf">t</span><span class="w"> </span><span class="nv">&lt;statement&gt;</span><span class="p">))</span>
</pre></div>
<p><b>Good style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">&lt;condition&gt;</span>
<span class="w">    </span><span class="nv">t</span>
<span class="w">    </span><span class="nv">&lt;statement&gt;</span><span class="p">)</span>
</pre></div>
<p><b>Poor style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="p">(</span><span class="nf">arg1</span><span class="w"> </span><span class="nv">arg2</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">local1</span><span class="w"> </span><span class="nv">value1</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nf">setf</span><span class="w"> </span><span class="nv">local2</span><span class="w"> </span><span class="nv">value2</span><span class="p">)</span>
<span class="w">  </span><span class="nv">&lt;statement&gt;</span><span class="p">)</span>
</pre></div>
<p><b>Good style</b>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="p">(</span><span class="nf">arg1</span><span class="w"> </span><span class="nv">arg2</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">local1</span><span class="w"> </span><span class="nv">value1</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nf">local2</span><span class="w"> </span><span class="nv">value2</span><span class="p">))</span>
<span class="w">    </span><span class="nv">&lt;statement&gt;</span><span class="p">))</span>
</pre></div>
<p>在上面的 <code>setf</code> 的例子里面, <code>local1</code> 和 <code>local2</code> 实际上是在函数外也是可见的全局变量.
  而 <code>let</code> 构造的局部变量仅仅在 <code>let</code> 声明的环境中可见.</p>
<h3>Iteration</h3>
<p>递归的一个模版</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="p">(</span><span class="nf">arg1</span><span class="w"> </span><span class="nv">arg2</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">end-condition</span>
<span class="w">      </span><span class="nv">return-result</span>
<span class="w">      </span><span class="nv">recurse</span><span class="p">))</span>
</pre></div>
<p>例:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">factorial</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span>
<span class="w">      </span><span class="mi">1</span>
<span class="w">      </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="p">(</span><span class="nf">factorial</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">n</span><span class="p">)))))</span>

<span class="c1">;; 尾递归 tail recursion 形式:</span>
<span class="p">(</span><span class="nf">defun</span><span class="w"> </span><span class="nv">factorial</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="w"> </span><span class="nv">&amp;optional</span><span class="w"> </span><span class="p">(</span><span class="nf">result</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">zerop</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span>
<span class="w">      </span><span class="nv">result</span>
<span class="w">      </span><span class="p">(</span><span class="nf">factorial</span><span class="w"> </span><span class="p">(</span><span class="nb">1-</span><span class="w"> </span><span class="nv">n</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="nv">result</span><span class="p">))))</span>
</pre></div>
<p>通常尾递归会被编译器优化以减少栈调用, 从而效率更高.
  但是两种形式都是比较好的代码风格.</p>

  </div><a class="u-url" href="/lisp/lisp-style-2-text/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
