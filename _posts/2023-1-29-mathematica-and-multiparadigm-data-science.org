#+layout: post
#+title: Mathematica and MultiParadigm Data Science
#+date: 2023-2-13
#+options: _:nil ^:nil
#+math: true
#+categories: mathematica
* 非常功利的理由
#+begin_quote
Update:
+ 2023-2-10: 参考 b 站 [[https://www.bilibili.com/video/BV1Rq4y1S7S8][视频]], 增加了一些函数和方法的使用情境.
  更新了关于神经网络部分的一些记录.
#+end_quote

之后要用来分析数据, 所以学一些备用.

教程是 Wolfram U 中的 [[https://www.wolfram.com/wolfram-u/courses/data-science/multiparadigm-data-science/][MultiParadigm Data Science]].
本文的作用就是用来速查的, 尽可能忠实地复制原文,
并随便添加一些注释 (在使用过后).

#+begin_quote
Update: [2023-2-10] 注: 因为这个完全是一个垃圾学习笔记,
无脑缝合了各种文档的笔记, 所以会非常的混乱且没有逻辑. 
#+end_quote

What is multiparadigm data science:

#+begin_quote
Multiparadigm Data Science is a new approach of
using Al and modern analytical techniques, automation
and human-data interfaces to arrive at better answers
with flexibility and scale.

from [[https://www.mpdatascience.com][Multiparadigm Data Science]]
#+end_quote

* Build A Project Overview
This part is an overview of how the data analysis is done.

#+begin_quote
Data science projects attempt to use data to answer certain
questions so that you can derive some useful insights from
the answers and act on them. A flexible, modular, iterative
workflow can serve as a roadmap in this quest to get from
data-driven questions to actionable insights.
#+end_quote

+ Questions
+ Wrangle
+ Explore
+ Analyze
+ Communicate

** Question
+ What can be learned from the data?
  + How many ...?
  + What ...?
  + Who ...?
+ Who wants to know?
  (which means stands at the reader's view and interests.)

** Wrangle
This part is the data gathering and pre-processing,
which is about gathering the data and unifying the data for
further processing.

+ *Data Gathering* 获取数据
+ *Pre-process* 对数据进行预处理, 即:
  + *Beautify Data Struct* 美化数据格式
  + *Strip Unnecessary Data* 剔除不必要的数据
  + *Add Pivots to Important Data* 增加关键的数据节点

会使用到的方法和知识:
+ *Key-Value Pairs* 在 Ruby 里面叫做 [[https://ruby-doc.org/3.2.0/Hash.html][Hash]].
  在 Mathematica 中为 [[https://reference.wolfram.com/language/guide/Associations.html][Associations]]. 通过:

  #+name: key-value-pairs-associations
  #+begin_src matheamtica
    <| key1 -> value1, key2 -> value2, ... |>
  #+end_src

  这样的形式来组织构建.
+ *String Modification* 字符串处理. ([[https://reference.wolfram.com/language/guide/StringManipulation.html][String Manipulation]])
  + [[https://reference.wolfram.com/language/ref/StringCases.html][StringCases]] Find cases of string patterns.

    但是不得不说, 其形式是真的难看:

    #+name: stringcases-rules
    #+begin_src mathematica
      StringCases[str, patt] (* equal to StringCases[patt][str] *)
      StringCases[str, lhs -> rhs] (* replace matched lhs by rhs *)
    #+end_src

    其中, =patt= 的规则类似于 [[https://ruby-doc.org/3.2.0/Regexp.html][Regexp (Ruby)]]
    (在 MMA 中也有对应 [[https://reference.wolfram.com/language/tutorial/StringsAndCharacters.html#16225][Regexp (MMA)]]). 简单来说是用 =~~= 连接,
    用字符串 (如 ="a"= ), 字符集合 (如 =DigitCharacter= ),
    匹配的函数符号 (如 =x_= 或者 =(x: WordCharacter)=) 来组成.
    使用 =..= 来表示匹配多字符.

    #+name: stringcases-example
    #+begin_src mathematica
      txt = "This is an example text @wolfram.";
      StringCases[txt,
	"@"~~u:(LetterCharacter | DigitCharacter | "-")..~~
	  (WhitespaceCharacter | PunctuationCharacter | EndOfString) :> u]
    #+end_src
  + [[https://reference.wolfram.com/language/ref/StringReplace.html][StringReplace]] Make replacements for string patterns.

    类似于 Ruby 里面的 [[https://ruby-doc.org/3.2.0/String.html#method-i-gsub][String#gsub]] 方法.
  + [[https://reference.wolfram.com/language/ref/StringDelete.html][StringDelete]] 类似于查找并删除. 用于去掉非必需的字符串.
+ *List Manipulation* 列表处理. ([[https://reference.wolfram.com/language/guide/ListManipulation.html][List Manipulation]])
  + [[https://reference.wolfram.com/language/ref/Select.html?q=Select][Select]] Pick out all elements of list which =crit= is =True=.
    =Select[list, crit]= 或者 =Select[crit][list]=.
  + [[https://reference.wolfram.com/language/ref/Sort.html?q=Sort][Sort]], [[https://reference.wolfram.com/language/ref/ReverseSort.html?q=ReverseSort][ReverseSort]]
  + [[https://reference.wolfram.com/language/ref/Count.html][Count]] Gives the number of elements.
  + [[https://reference.wolfram.com/language/ref/DeleteDuplicates.html][DeleteDuplicates]]
+ *Graph and Relations* 关系网络.
  ([[https://reference.wolfram.com/language/guide/GraphsAndNetworks.html][Graphs and Networks]], [[https://reference.wolfram.com/language/guide/GraphConstructionAndRepresentation.html][Grap Construction and Representation]])
  + [[https://reference.wolfram.com/language/ref/SimpleGraph.html][SimpleGraph]] Gives the underlying simple graph from the graph.
+ 一些不太好分类的
  + [[https://reference.wolfram.com/language/ref/WordCloud.html?q=WordCloud][WordCloud]] Generate a word cloud.
  + [[https://reference.wolfram.com/language/ref/Interpreter.html?q=Interpreter][Interpreter]] Something like a parser on specific rules.

    比如用来处理地理数据 =Interpreter["ComputedLocation"]=.
    (注: 使用 [[https://reference.wolfram.com/language/ref/GeoListPlot.html][GeoListPlot]] 可以在地图上输出地点,
    [[https://reference.wolfram.com/language/ref/GeoHistogram.html][GeoHistogram]] 可以输出地图上的数据点的强度. )

** Explore
By this stage, use the previous stage of *Wrangle* to visualize
the data gathered and while trying to answer the questions
asked at *Question* stage, figure out more questions of the data.
(which also means returning to the *Question* stage)

Thus the visualization data methods:
+ [[https://reference.wolfram.com/language/ref/DateHistogram.html?q=DateHistogram][DateHistogram]] Plots a histogram of the dates.

  根据日期绘制分布. 比较有用的参数:
  + [[https://reference.wolfram.com/language/ref/DateReduction.html][DateReduction]] 用于约化计数的范围.
    传入的参数范围为 [[https://reference.wolfram.com/language/ref/DateValue.html][DateValue]] (="Year"=, ="Month"= 等).
+ [[https://reference.wolfram.com/language/ref/Histogram.html][Histogram]] Plots a histogram of the values.

  比较有用的参数:
  + [[https://reference.wolfram.com/language/ref/ChartLayout.html][ChartLayout]] Overall layout:
    单参数可传入 ="Overlapped"= (重叠两张表来显示),
    ="Stacked"= (两张图表数值会叠在一起).
    或者可以通过 ="Column"=, ="Row"= 等传入更多的参数,
    但是用处感觉不是很大. 
  + [[https://reference.wolfram.com/language/ref/ChartLegends.html][ChatLegends]] 图例. 
+ [[https://reference.wolfram.com/language/ref/Graph.html][Graph]] Yields a graph.

通过简单的数据处理和可视化来表现数据的性质和特征.

** Analyze
To answer the question asked at the stage of *Question*,
methods could be applied to the data.

+ How many ...?
  + by *Simply Counting*
  + by *Comparision Charts*
    + [[https://reference.wolfram.com/language/ref/Histogram.html][Histogram]]
    + [[https://reference.wolfram.com/language/ref/ArrayPlot.html][ArrayPlot]] Generate a plot in which the values in an array
      are shown in a discrete array of squares.

      可以和 Github 上的小绿图做个类比.
      可以用来分析一个在二维分布的数据的频次.
  + by *Predict the Future Data*
    + [[https://reference.wolfram.com/language/ref/Predict.html][Predict]] generates a [[https://reference.wolfram.com/language/ref/PredictorFunction.html][PredictorFunction]] based on example
      input-output pairs given.
+ What ...?
  + by *String Matching and Counting*
  + by *Clustering* [[https://reference.wolfram.com/language/guide/ClusterAnalysis.html][Cluster Analysis]]
  + by *Classification* (assigning labels to data)
    + [[https://reference.wolfram.com/language/ref/Classify.html][Classify]]
  + by *Graphs and Networks* (show who is connected to whom, aka,
    the relationships).
    + [[https://reference.wolfram.com/language/ref/FindGraphCommunities.html][FindGraphCommunities]] finds communities in the graph

** Communicate
#+begin_quote
*Things to Remember*: (How to tell the story)
+ What is the story your audience is interested in?
+ How can you recreate the story easily?
  + Reproducible analysis
  + Comparative analysis
#+end_quote

+ Easy to read and see the results.
  + Visualization
    + [[https://reference.wolfram.com/language/ref/Grid.html][Grid]] (Used to layout the graphics)
    + [[https://reference.wolfram.com/language/ref/TabView.html][TabView]] (Used to add interactability for flat data)
+ Easy to redo the results.
+ To convince the readers.
+ Notebook as an essay, report slides, cloud publishment,
  report template. (*MMA only*)

* Get Your Data into Shape
This part is mainly about the *Wrangle* part,
which could be done by:
+ Handle data in different formats from different sources
+ Reshape the data into different structures
+ Deal with messy data
+ Extract useful features from raw data
+ Reduce the dimensionality of high-dimensional data

** Handling Different Types of Data
Note: Before wrangling the Real-world data,
you have to get them first (of course):
+ Repositories of curated data

  With Curated Data, it is easier to produce the
  data (or even skip the wrangle part.)
  + [[https://datarepository.wolframcloud.com][Wolfram Data Repository]]: [[https://reference.wolfram.com/language/ref/ResourceData.html][ResourceData]]
    Gives the primary content of the specified resource.
  + [[https://www.wolfram.com/knowledgebase/][Wolfram Knowlegebase]]: [[https://reference.wolfram.com/language/guide/EntityTypes.html][Entity Types]].
  + [[https://reference.wolfram.com/language/ref/FinancialData.html][FinancialData]]: gives the last known price or value for the
    financial entity specified by name.
  + [[https://reference.wolfram.com/language/ref/WeatherData.html][WeatherData]]: gives the most recent measurement for the
    specified weather property at the location.
+ Flat files
  + [[https://reference.wolfram.com/language/ref/Import.html][Import]] Imports data from source.
    And the [[https://reference.wolfram.com/language/ref/$ImportFormats.html][$ImportFormats]] is a list of currently supported
    import formats.

    If passing in a URL, the =Import= function can be
    used to parse the specified data format of the URL.
    For example:

    #+name: mma-import-from-url
    #+begin_src mathematica
      Import["https://li-yiyang.github.io/manga/animatation-review/", "Images"]
    #+end_src

    You can get a list of images (depending on your network
    connectivity...)

    [[{{ site.github.url }}/_img/MMA/MMA-Import-Images-example-of-my-blog.png]]
    
  + [[https://reference.wolfram.com/language/ref/Save.html][Save]] appends definitions associated with a specified symbol
    to a file. And [[https://reference.wolfram.com/language/ref/DumpSave.html][DumpSave]] write definitions associated
    with a symbol to a file in internal Wolfram System format.

    After saving, use [[https://reference.wolfram.com/language/ref/FindFile.html][FindFile]] to find the file path saved.
    With [[https://reference.wolfram.com/language/ref/Get.html][Get (<<)]] can read in a file. 
+ Databases [[https://reference.wolfram.com/language/guide/DatabaseConnectivity.html][Database Connectivity]]
  + [[https://reference.wolfram.com/language/DatabaseLink/guide/SQLDatabaseOperations.html][DatabaseLink SQL Operations]] =Needs["DatabaseLink"]=

    #+begin_src mathematica
      conn = OpenSQLConnection["..."]

      SQLTableNames[conn]

      SQLSelect[conn, ...] (* or, SQLExecute[] *)
    #+end_src
  + [[https://reference.wolfram.com/language/ref/RelationalDatabase.html][RelationalDatabase]] Represents schema information about
    a relational database.
+ External APIs
  + comes alone Wolfram: [[https://reference.wolfram.com/language/ref/ServiceConnect.html][ServiceConnect]] Creates a
    connection to an external service, which are
    listed by [[https://reference.wolfram.com/language/ref/$Services.html][$Services]] or described at
    [[https://reference.wolfram.com/language/guide/ListingOfSupportedExternalServices.html][Listing of Supported External Services]].

    +乐, 一堆国内不好用的.+
  + [[https://reference.wolfram.com/language/ref/WebSearch.html][WebSearch]] Gives a dataset of the top web search results
    for the specified literal string.
  + [[https://reference.wolfram.com/language/ref/WebImageSearch.html][WebImageSearch]] Gives a list of thumbnails of
    the top web image search results for the specified literal
    string.
  + [[https://reference.wolfram.com/language/ref/WikipediaData.html][WikipediaData]] Gives the plain text of the specified
    Wikipedia article.
  + Publicly Available Data
    + [[https://data.stats.gov.cn][国家统计局]]
      +不过离谱的是网站证书过期了...+
    + [[https://opendata.chinadep.com/#/][China Open Data]]
      +类似一个整合网站, 不过数据不一定全部有效+
    + [[https://data.gov][US Government's Open Data]]
    + [[https://data.nasa.gov/browse][NASA's Open Data Portal]]
    + [[https://archive.ics.uci.edu/ml/index.php][UCI Machine Learning Repository]]
    + [[https://www.kaggle.com/datasets][Kaggle Data Science Contests]]
    + [[https://data.fivethirtyeight.com][Five Thirty Eight]]
+ Web scraping

#+begin_html
<details><summary>吐槽</summary>
#+end_html

不知道该说什么好... Mathematica 难道真的是一个非常小众的东西么?
网络上的资料基本上全部都是官方的.
+尽管可能是因为大家都在用... 所以比较低调?+

并且连接到数据库真的好累... 可能是服务器不在国内的缘故吧.
一个曲线救国的方式就是使用梯子, 在
=Mathematica -> Settings -> Internet & Mail=
里面设置 Proxy Settings. 用自己的梯子来. 

#+begin_html
</details>
#+end_html

** Restructuring Data
#+begin_quote
+ Data is systematically stored
+ Data elements are arranged in a structured way

from [[https://blog.wolfram.com/2017/04/20/launching-the-wolfram-data-repository-data-publishing-that-really-works/][Launching the Wolfram Data Repository: Data Publishing that Really Works]]
#+end_quote

#+begin_html
<details><summary>吐槽</summary>
#+end_html

每次看 Stephen Wolfram 的博客的时候,
总有一种好像很牛逼又好像很一般的感觉.
有一种说不上来的敬佩感.

尽管有一种虽然这个问题很简单, 但是为什么要这么做的困惑.
有点像是之前计算机科学导论的课上的感觉.
(尽管我那门课可能上得不太行, 但是里面的知识我觉得都是很有用的)

可能这就是牛逼的人的一种思考方式么. 

#+begin_html
</details>
#+end_html

Here are some helpful organized data types:
+ [[https://reference.wolfram.com/language/ref/List.html][List]]: [[https://reference.wolfram.com/language/guide/ListManipulation.html][List Manipulation]]
+ [[https://reference.wolfram.com/language/ref/Association.html][Association]]: [[https://reference.wolfram.com/language/guide/Associations.html][Associations]]
+ [[https://reference.wolfram.com/language/ref/Dataset.html][Dataset]]: [[https://reference.wolfram.com/language/guide/ComputationWithStructuredDatasets.html][Computation with Structured Datasets]]
+ [[https://reference.wolfram.com/language/ref/EntityStore.html][EntityStore]]: [[https://reference.wolfram.com/language/guide/KnowledgeRepresentationAndAccess.html][Knowledge Representation & Access]]
+ [[https://reference.wolfram.com/language/ref/TimeSeries.html][TimeSeries]]: [[https://reference.wolfram.com/language/guide/TimeSeries.html][Time Series Processing]]

Some more useful data types I think:

*** Lists
Most data imported are in the forms of List,
and many built-in data structures (Vector, Matrix, ...)
are based on List.

+ Read List
  + [[https://reference.wolfram.com/language/ref/First.html][First]] Gives the first element of exp.

    And like =car= and =cdr= in lisp ([[https://www.gnu.org/software/emacs/manual/html_node/eintr/car-_0026-cdr.html][Elisp]]),
    the First function has a relative function: [[https://reference.wolfram.com/language/ref/Rest.html][Rest]],
    which gives the rest element with first one removed.
  + [[https://reference.wolfram.com/language/ref/Part.html][Part]] =expr[[]]= can be used to get part of =expr=.
    + ={a, b, c}[[1]]= will return =a=.
      (start counting from =1=, and the negative index
      will count backward.)
    + ={a, b, c}[[2;;3]]= likes python's [[https://docs.python.org/3/library/functions.html#slice][slice]],
      which could be written as
      =list[[start ;; stop ;; step]]= .
    + ={ {a, 1, 0}, {b, 2, 1} }[[All, {1, 3}]]=
      will return ={ {a, 0}, {b, 1} }=, which could be
      a way to extract nested list data.
+ Process List
  + [[https://reference.wolfram.com/language/ref/GatherBy.html][GatherBy]] Gathers into sublist each set elements
    in =list= that gives the same value when =f= is
    applied. =Gatherby[list, f]=.
  + [[https://reference.wolfram.com/language/ref/Map.html][Map (/@)]] Applies function to each element in list.
+ List Attributes
  + [[https://reference.wolfram.com/language/ref/Dimensions.html][Dimensions]] Gives a list of dimensions.
    (kinda like giving the shape of a list)
  + [[https://reference.wolfram.com/language/ref/Length.html][Length]] Gives the number of elements.
    
*** Associations
[[https://reference.wolfram.com/language/guide/Associations.html][Associations]] are key-value pairs.
+ =<|a -> 1, b -> 2|>[a]= It looks more like a function
  written in mapping rules.

  =<|b -> 2, a -> 1|>[[1]]= will return =2= as the first
  value of it is =2=.
+ Those List functions would also work on Associations:
  [[https://reference.wolfram.com/language/ref/Total.html][Total]], [[https://reference.wolfram.com/language/ref/Select.html][Select]], [[https://reference.wolfram.com/language/ref/Sort.html][Sort]]... (just like they are performed on
  the values ([[https://reference.wolfram.com/language/ref/Values.html][Values]]) of the associations).
+ And the functions with "Key" prefixed will serve on
  the keys ([[https://reference.wolfram.com/language/ref/Keys.html][Keys]]): [[https://reference.wolfram.com/language/ref/KeySort.html][KeySort]], [[https://reference.wolfram.com/language/ref/KeyMap.html][KeyMap]].
+ To map with Key-Value pairs, use [[https://reference.wolfram.com/language/ref/AssociationMap.html][AssociationMap]].
  To construct an Association by Keys and Values,
  use [[https://reference.wolfram.com/language/ref/AssociationThread.html][AssociationThread]] and turn Association to List
  by [[https://reference.wolfram.com/language/ref/Normal.html][Normal]]. 
  
*** Dataset
[[https://reference.wolfram.com/language/ref/Dataset.html][Dataset]] represents a structured dataset based on a hierarchy
of lists and associations.
+ by *Definitions*

  #+name: mma-define-dataset
  #+begin_src mathematica
    d = Dataset[{
	    <| "a" -> 1, "b" -> x, "c" -> {1} |>,
	    <| "a" -> 2, "b" -> y, "c" -> {2, 3} |>}]
  #+end_src
  + [[https://reference.wolfram.com/language/ref/SemanticImport.html][SemanticImport]] attempts to import a file semantically to
    give a *Dataset* object.
+ by *Reading*
  + Query row: =d[2]=, and rows =d[1;;2]=

    and a row can be processed like an *Association*.
    (=d[2] // Normal= will return the *Association* form data)
  + Query with rules: =d[All, "a"]= will return all the column
    of ="a"=.

    With functions passed in will be applied to the matched column.
    For example: =d[Total, "a"]= will return the results of applying
    =Total= to the ="a"= column.

    And pass in select function will apply the function to each
    row: =d[SortBy[Lengh[#c]&]]=, =d[Select[#a > 1 &], "b"]=
    (return the ="b"= column, whose ="a"= value is greater than =1=).

    And =d[GroupBy[Key["b"]], Catenate, "c"]=.

    A simple guess is that when queried with rules,
    functions are applied to each row and finally select the
    corresponding column. 
    
** Dealing with Messy Data
This part is fighting with the messy data, which often
comes with data like:
+ Incomplete
+ Inaccurate
+ Irrelevant

For which data cleaning is necessary:
+ Replacing
+ Modifying
+ Removing errors

And a possible checklist for such a process can be:
+ *Type Checking*: Consistent formatting across each row and column
  + [[https://reference.wolfram.com/language/ref/Head.html][Head]] Gives the head of input.
  + [[https://reference.wolfram.com/language/ref/InputForm.html][InputForm]] Prints as a version of =expr= suitable
    for input to the Wolfram Language.
  + [[https://reference.wolfram.com/language/ref/DeleteDuplicates.html][DeleteDuplicates]] Delete all duplicates from a list.
    This could strip out the different types of values.
    Also, [[https://reference.wolfram.com/language/ref/Sort.html][Sort]] values could help with stripping out
    wrong data.
+ *Range Checking*: Reasonable and informative feature values
  + Use [[https://reference.wolfram.com/language/ref/Histogram.html][Histogram]] to plot out the data to check.
  + Use [[https://reference.wolfram.com/language/ref/Select.html?q=Select][Select]] to strip out suspecious values.
  + 除了上面的方法, 还可以使用统计方式来找出存在误差的值.
    如: 使用正态分布来剔除 $3 \sigma$ 外的值, 认为在 $3 \sigma$ 外的值为不正常的值.
    一般适合总体符合正态分布的数据, 如人口数据, 测量误差, 生产加工质量,
    考试成绩等. 不适合其他分布. 

    或者是在箱线图中看数值是否存在异常. 比较普遍适用. 
    
    或者使用 [[https://reference.wolfram.com/language/ref/AnomalyDetection.html][AnomalyDetection]] 来生成查找非正常数据的函数.
    这个处理的方式就比较无脑了. 
+ *Missing Data*: Occurrence of missing data
  + [[https://reference.wolfram.com/language/ref/DeleteCases.html][DeleteCases]] to match values with ="NA"= missing data,
    and delete them. /[Note: if you have enough data to delete...]/

    注: 对于缺失太多的数据, 可以选择删除. 比如 40% 的缺失,
    就不适合作为一个正经数据源来使用了. 
  + [[https://reference.wolfram.com/language/ref/ReplaceAll.html][ReplaceAll (/.)]] Applies a rule or list of rules in an attempt
    to transform each subpart of an expression =expr=.
    /[Note: Use it to replace missing value. ]/

    The *replacing* methods are various:
    + Replace with default values: =data /. "NA" -> 0=
    + Replace with means:
      /[Note: Also, select with [[https://reference.wolfram.com/language/ref/Cases.html][Cases]] to provide better means.]/
      =data /. "NA" -> Mean[Select[data, NumbericQ]]=

      使用平均值替代的, 适用于对 *个体精度要求不大*, *基数大* 的数据
      根据定量和定性来进行区分具体使用的方法, 比如定量的数据可以考虑平均,
      定性的数据可以考虑众数, 即出现次数最多的数据.
    + [[https://reference.wolfram.com/language/ref/Interpolation.html][Interpolation]] 插值法, 即通过构造近似函数来补上缺失值.
      + *牛顿插值法*: 适用于热力学温度, 地形测量,
        定位等最求函数值的精确而不关心变化情况.
        (这个因为可能会发生振荡而不太适合求解变化的情况. )
      + *样条插值法*: 分段光滑曲线去插值, 连续且有连续曲率,
        适用于零件加工, 要关心变化导数的问题. 
    + Replace with random value [[https://reference.wolfram.com/language/ref/RandomVariate.html][RandomVariate]]:
      + [[https://reference.wolfram.com/language/ref/NormalDistribution.html][NormalDistribution]]:
	First get the $\mu$ and $\sigma$ out from good data by
	[[https://reference.wolfram.com/language/ref/Mean.html][Mean]], [[https://reference.wolfram.com/language/ref/StandardDeviation.html][StandardDeviation]]. Then use =RandomVariate= to generate.
      + [[https://reference.wolfram.com/language/ref/LearnedDistribution.html][LearnedDistribution]]: Guess a possible distribution.
    + Replace with [[https://reference.wolfram.com/language/ref/Nearest.html][Nearest]] sample.
    + Use a Regression or Classification Model to [[https://reference.wolfram.com/language/ref/Predict.html][Predict]]:
      =Predict[data, Method -> "..."]=.
    + Treat "missing" as a special value [[https://reference.wolfram.com/language/ref/Missing.html][Missing]]: =Missing[]=
** Feature Extraction and Dimensionality Reduction
This part is about extracting useful features from raw data,
and reducing the dimensionality of high-dimensional data.

*** Feature Extraction
Transform raw data into numeric vectors to enable:
+ Applying transformations like standardization, rescaling,
  filtering etc.
+ Performing operations like Principal Component Analysis
+ Calculating distances between samples
+ Feeding data into Neural Networks

To extract data, the following methods could be applied:
+ *Nominal to Numbers*: [[https://reference.wolfram.com/language/ref/FeatureExtract.html][FeatureExtract]] and apply Feature Selection.

  /[Note: About the [[https://en.wikipedia.org/wiki/Feature_(machine_learning)][features]] in machine learning.]/

  通过 =FeatureExtract= 来提取出数据的关键参数,
  然后通过 Feature Selection 的方式来选择需要的数据以提高效率.
  常见的选择方式:
  + *Filter methods*: 类似于给一个打分标准来选择什么样的 feature 更好用.
  + *Wrapper methods*: 在数据的子集上先进行训练,
    然后更换子集来看是否训练的模型是匹配的.

    /[Note: 可以使用 [[https://reference.wolfram.com/language/ref/RandomSample.html][RandomSample]], [[https://reference.wolfram.com/language/ref/RandomChoice.html][RandomChoice]] 来从数据集中提取出一个小样本. ]/

    /[Note: 或者是对数据先 *Select* 之后再筛选. ]/
  + *Embedded methods*
    
*** Dimension Reduce
实际上也可以算是一种 Feature Extract 和 Feature Selection 的组合了.

+ [[https://reference.wolfram.com/language/ref/DimensionReduce.html][DimensionReduce]]: 自动尝试将输入进行缩减.

  有一个非常炫酷的例子: 

  #+begin_src mathematica
  images = Import["https://li-yiyang.github.io/manga/animatation-review/", "Images"];
  reduced = DimensionReduce[images, 2];
  ListPlot[MapThread[Labeled[#1, #2] &, {reduced, images}]]
  #+end_src

  这个例子里面的结果就很炫酷, 可以将输入的图片直接进行一个分类.
  (当然, 应该不是内容识别, 猜测可能是根据图片的色调之类的进行的区分,
  因为我输入的这几张图片在颜色上还是有那么一个区分的. )

  [[{{ site.github.url }}/_img/MMA/MMA-DimensionReduce-on-Images-Imported-from-my-Blog.png]]

  并且可以传入各种各样的参数, 所以非常的方便. +尽管都不会+

  类似上面操作的还有 [[https://reference.wolfram.com/language/ref/FeatureSpacePlot.html][FeatureSpacePlot]]. 
* Get to Know Your Data (EDA: Exploratory Data Analysis)
*What to do* at this stage:
+ Gain an intuitive understanding of the underlying
  nature of the dataset
+ Identify relationships between variables
+ Formulate good questions for the actual analysis
  (as the explorations proceed, those questions can change)
+ Evaluate the quality of data (Data QA)

Questions to *keep in mind* for EDA:
+ Do we have the data as needed for the planned analysis?
  Is there enough of it?
+ Does the data seem to be accurate? Are there obvious errors?
  Is the data missing something?
+ Is the data relevant? Are there outliers?
+ Are there some characteristics of the features that
  attract attention right away?

EDA Checklist:
+ Visualise the data in *feature space*
  + Try pairs of raw features
  + Project data to 2 or 3 dimensions
    through Dimensionality Reduction.
+ Create scatterplot matrices to look at pairwise relationships
  across all variables
+ Plot distributions of all variables
  + Start with single distribution - single variable
  + Go on to joint distributions of pairs of variables
+ Overlay plots and graphs
  + Compare distribution shapes to histograms
  + Look for deviations
+ Visualise clusters of samples
  + Identify outliers
  + Look for gaps in the data
+ Plot time series data to identify trends
+ Try visualization tools from other disciplines
+ Look at pairwise relationships between variables - correlation
  
** Visual Exploration
#+begin_quote
We are visual creatures. Visual things stay put, whereas sounds fade.

人是视觉的动物.

by Steven Pinker
#+end_quote

所以数据可视化对于认识数据极其有帮助. 

*Tools* of EDA:
+ Graphical (visualizations) or Non-graphical (statistics)

  /[Note: a useful website about [[https://datavizcatalogue.com/ZH/][Visualization Plots]]. ]/
  + [[https://reference.wolfram.com/language/ref/Show.html][Show]] 用于整合输出多幅图
  + Scatterplots (散点图) [[https://reference.wolfram.com/language/ref/ListPlot.html][ListPlot]]

    通过 [[https://reference.wolfram.com/language/ref/Grid.html][Grid]] 来组织不同的图表来展现不同类别的散点图. 
  + [[https://reference.wolfram.com/language/ref/BarChart.html][BarChart]] (柱状图, 相对大小), [[https://reference.wolfram.com/language/ref/PieChart.html][PieChart]] (饼状图, 成分占比)
  + [[https://reference.wolfram.com/language/ref/Histogram.html][Histogram]], 或使用 [[https://reference.wolfram.com/language/ref/PairedHistogram.html][PairedHistogram]] 来进行对比.

    注: 一个绘图的小技巧是在绘图前可以对数据进行一个缩放 [[https://reference.wolfram.com/language/ref/Rescale.html][Rescale]],
    使得其输出结果更加容易看:

    #+begin_src mathematica
      dataScaled = With[{
              dat1 = ({Min[#1], Max[#1]}&)[dur],
              dat2 = ({Min[#1], Max[#1]}&)[wait]},
                   (Rescale[#1, dat1, dat2]&) /@ dur];
    #+end_src

    上面是来自官方的代码, 满满的函数式编程的味道.

    其他的还有: [[https://reference.wolfram.com/language/ref/DensityHistogram.html][DensityHistogram]], [[https://reference.wolfram.com/language/ref/Histogram3D.html][Histogram3D]],
    [[https://reference.wolfram.com/language/ref/SmoothHistogram.html][SmoothHistogram]], [[https://reference.wolfram.com/language/ref/SmoothHistogram3D.html][SmoothHistogram3D]]. 
  + [[https://reference.wolfram.com/language/ref/BoxWhiskerChart.html][BoxWhiskerChart]] (箱线图)

    注: 箱线图的 (线) 两端表示最大和最小, 中间的框表示第一四分位数,
    第三四分位数的一个范围. 最后中间的线表示中位数. 其反应了数据的:
    中心位置, 散布程度, 对称性的信息.

    可以用箱线图来帮助了解数据是否有误. 如从上下极限可以找到是否有异常数值,
    或者根据四分位距 $IQR = Q_3 - Q_1$ 来判断, 再通过设置一个合理区间来判断.
    即设置上极限和下极限的区域为 $Q_1 - 1.5 \times IQR, Q_3 + 1.5 \times IQR$.
    是一种比较普遍适用的方法. 
  + [[https://reference.wolfram.com/language/ref/DistributionChart.html][DistributionChart]] (默认) 得到的是 [[https://mode.com/blog/violin-plot-examples/][Violin Plots]] (小提琴图).

    注: 类似于箱线图的升级版本. 可以和人口年龄结构分布图类比一下.
  + [[https://reference.wolfram.com/language/ref/QuantilePlot.html][QuantilePlot]] (Q-Q 图)

    注: 用来表示两个分布之间的差异. 比如默认是和标准分布的差:
    假设数据样本的概率分布为 $F(X)$ 而标准分布为 $\hat{F}(X)$.
    那么如果将其差 $F(X) - \hat{F}(X)$ 在一条直线附近绘制出来,
    就会得到 Q-Q 图.

    #+begin_quote
    + Do two data sets come from populations with
      a common distribution?
    + Do two data sets have a common location and scale?
    + Do two data sets have similar distributional shapes?
    + Do two data sets have similar tail behavior?

    from [[https://www.itl.nist.gov/div898/handbook/eda/section3/qqplot.htm][Quantile-Quantile Plot]]
    #+end_quote
  + Cluster visualizations 通过对数据进行分类以达到数据可视化的程度.
    + [[https://reference.wolfram.com/language/ref/FindClusters.html][FindClusters]] 对输入的数据进行一个分类
    + [[https://reference.wolfram.com/language/ref/ClusteringTree.html][ClusteringTree]] 基于树状图的一个分类,
      类似的还有 [[https://reference.wolfram.com/language/ref/Dendrogram.html][Dendrogram]] 来绘制. 
  + TimeSeries plots
    + [[https://reference.wolfram.com/language/ref/DateListPlot.html][DateListPlot]], [[https://reference.wolfram.com/language/ref/DateListStepPlot.html][DateListStepPlot]]
  + [[https://reference.wolfram.com/language/ref/WordCloud.html?q=WordCloud][WordCloud]]

    /[Note: 可以用来分析词条的出现频次.]/
+ Univariate (single variable behavior) or multivariate
  (combined behavior of two or more variables)

** Looking at Data Differently
这一部分的想法就是, 对于不同的类型的数据, 通过不同的方式来处理,
可以得到很好的结果:
+ 词条的出现频次, 通过 [[https://reference.wolfram.com/language/ref/WordCloud.html?q=WordCloud][WordCloud]] 这样的方案就很好
+ 对于低维数据, 可以通过简单的绘图的方式显现.
  但是对于复杂的高维数据, 则可以通过特征提取的方式来分类.
  + [[https://reference.wolfram.com/language/ref/FeatureSpacePlot.html][FeatureSpacePlot]]
  + [[https://reference.wolfram.com/language/ref/Graph.html][Graph]], and [[https://reference.wolfram.com/language/ref/HighlightGraph.html][HighlightGraph]] helps information stand out.
+ 对于特定的种类的数据, 可以用专门的方式来绘制:
  + [[https://reference.wolfram.com/language/ref/GeoGraphics.html][GeoGraphics]], [[https://reference.wolfram.com/language/ref/GeoHistogram.html][GeoHistogram]] 
  + [[https://reference.wolfram.com/language/ref/TimelinePlot.html][TimelinePlot]]
** Statistical Tools
+ $\bar{x} = \sum x_i / N$ [[https://reference.wolfram.com/language/ref/Mean.html][Mean]], $\sum(x - \bar{x})^2/N$ [[https://reference.wolfram.com/language/ref/Variance.html][Variance]]
+ $\sigma$ [[https://reference.wolfram.com/language/ref/StandardDeviation.html][StandardDeviation]]
+ Tukey's *Five number summary*

  注: 这个 [[https://en.wikipedia.org/wiki/Five-number_summary][Five number summary]] 描述的量在箱线图中就有表述.
  + [[https://reference.wolfram.com/language/ref/Min.html][Min]]
  + First quartile
  + Median
  + Third quartile
  + [[https://reference.wolfram.com/language/ref/Max.html][Max]]
+ Frequency Counts [[https://reference.wolfram.com/language/ref/Count.html][Count]]

  /[Note: when dealing with *Float* data, it is helpful to first apply [[https://reference.wolfram.com/language/ref/Round.html][Round]].]/
+ [[https://reference.wolfram.com/language/ref/Correlation.html][Correlation]]
+ Others
  + [[https://reference.wolfram.com/language/ref/Skewness.html][Skewness]]
  + [[https://reference.wolfram.com/language/ref/Kurtosis.html][Kurtosis]]

* Assenble a Multiparadigm Toolset
This part is about using tools to answer the questions asked above.

*Quick Review of Terms*: (黑话介绍)
+ *Independent variables* as input $\vec{x} = {x_1, \dots, x_n}$
+ *Dependent variable* as the result $y$.
+ *Model* about how input generates the output,
  which could be a function $y = f(\vec{x})$ or just
  simply a *blackbox*: $\vec{x} \rightarrow \mathrm{blackbox} \rightarrow  y$. 
+ *Parameters* are values in the model or algorithm that
  are not assumed by the predictor or response variables;
  learned/tuned while training.
+ *Training* The process of identifying the function or the
  algorithm (and the corresponding parameters) that best
  represents the relationship between the input and output.
  
** Classification
This part is about answering the question like *Is this A or B?*

Use [[https://reference.wolfram.com/language/ref/Classify.html][Classify]] to mark data, return a [[https://reference.wolfram.com/language/ref/ClassifierFunction.html][ClassifierFunction]] which could
classify input. The  [[https://reference.wolfram.com/language/ref/ClassifierFunction.html][ClassifierFunction]] can be used for getting
the probabilities for all classes or a specific class.

#+begin_src mathematica
  c = Classify[data];
  c[value] (* Return the class *)
  c[value, "Probabilities"] (* All possible classes with probability *)
  c[value, "Probabilities" -> "A"] (* Probability for a specific class*)
#+end_src

思路是这样的, 在数据集中选择一个代表数据集, 然后进行手工标定,
最后用 [[https://reference.wolfram.com/language/ref/Classify.html][Classify]] 来对数据集进行学习, 以期望能够通过学习的结果,
用来对其他的数据进行预测.

训练的方法 =Classify[data, Method -> "..."]= 有: (方法内容介绍有空补)
+ *Logistic Regression* to classify using probabilities from linear
  combinations of features.
+ *Nearest Neighbors* to classify from nearest neighbor examples
+ *Naive Bayes* to classify by assuming probabilistic independence of features
+ *Decision Tree* to classify using a tree-like model for representing
  decisions and their consequences
+ *Gradient Boosted Trees* to classify using an ensemble of trees
  trained with gradient boosting
+ *Random Forests* to classify using Breiman-Cutler ensembles of
  decision trees
+ *Markov Models* to classify using a stochastic model on the sequence
  of features (for text, bags of tokens, etc.)
+ *Support Vector Machines* to classify using a discriminative model that
  constructs a hyperplane or sets of hyperplanes to separate samples of
  different classes.
+ *Neural Networks* to classify using algorithms modeled loosely after
  biological neural networks.
+ 更多方法见 [[https://reference.wolfram.com/language/ref/Classify.html][Classify]] 文档.

训练结果可以添加用来判断分类的阀值, 如:
=Classify[data, IndeterminateThreshold -> 0.9`]=,
若没有高于阀值的分类结果, 则返回 =Indeterminate= 表示不能判断.
也可以在实际使用中添加参数: =cfunc[value, Indeterminate -> ...]=. 

在训练的时候, 可以传入标定概率的数据集 =UtilityFunction= 来增强分类结果.

#+begin_src wolfram
  utility = Association[
    "a" -> Association["a" -> 1, "b" -> 0, Indeterminate -> 0.5`],
    "b" -> Association["a" -> -15, "b" -> 1, Indeterminate -> 0.8`]];
  ClassifierMeasurements[c, test, "ConfusionMatrixPlot", UtilityFunction -> utility]
#+end_src

使用 =PerformanceGoal= 参数在 =Classify= 中可以改变分类的性能.
是速度优先或者是质量优先或者其他. 

对于结果, 通过 [[https://reference.wolfram.com/language/ref/Information.html][Information]] 来提取关于拟合的 [[https://reference.wolfram.com/language/ref/ClassifierFunction.html][ClassifierFunction]] 函数的信息,
比如 =Information[c]= 得到所有关于 =c= 的信息. 或者再传入一个参数指定信息:
=Information[c, "MethodOption"]=. 其中的参数还有: =LearningCurve= (训练曲线),
=Accuracy= 精确度等等.

使用 [[https://reference.wolfram.com/language/ref/ClassifierMeasurements.html][ClassifierMeasurements]] 来评估一个 *ClassifierFunction* 的好坏程度.
其中, =test= 为另一部分人为标定的数据集. =cfunc= 是根据部分标定的数据训练得到的结果.

#+begin_src mathematica
  cfuncMeasure = ClassifierMeasurements[cfunc, test]
  cfuncMeasure["Accuracy"]
  cfuncMeasure["ConfusionMatrixPlot"]
#+end_src

其中的参数有:
+ *Accuracy*: fraction of correctly classified examples
+ *ConfusionMatrixPlot*: plot of the confusion matrix
+ *BestClassifiedExamples*: examples having the highest actual-class probability
  samely: *WorstClassifiedExamples*.

总结:
+ Classification as a supervised machine learning task of
  predicting labels for new samples, based on a set of previously
  labeled training samples
+ Classify: a machine learning super-function
  + Works for various types of input--numerical features,
    images, text, etc.
  + ClassifierMeasurements: to evaluate the performance of
    the ClassifierFunction created by Classify
+ Customize Classify to:
  + Use different "Methods" or common classification algorithms
    like Logistic Regression, Decision Trees, Nearest Neighbor etc.
  + Use different UtlityFunction and IndeterminateThreshold
    for making decisions
  + Optimize performance according to different criteria
    like training speed, actual runtime speed, memory usage,
    or accuracy of predictions
** Regression
This part is to answer *How much* would something be.

+ *Linear Regression* [[https://reference.wolfram.com/language/ref/LinearModelFit.html][LinearModelFit]]

  #+begin_src mathematica
    lm = LinearModelFit[data, {f1, f2, ...}, {x1, x2, ...}]
    lm["BestFit"] (* linear exp of f1, f2, ... *)
  #+end_src
+ *Machine Learning Super Function* [[https://reference.wolfram.com/language/ref/Predict.html][Predict]] 
  + =PerformanceGoal=
  + Methods used to generate prediction:
    + =BoostingMethod=
  + Test of predicted results:
    + Plot /distribution/ of predicted function on specific input:
      =Plot[PDF[predictFunction[input, "Distribution"], x], {x, 0, 1}]=
    + [[https://reference.wolfram.com/language/ref/PredictorMeasurements.html][PredictMeasurements]] to test predicted results.
      + =ComparisionPlot= to plot predictions with data input.
      + =StandardDeviation=
      + =Report=
+ =FindFormula= to find a formula to describe the given data
** Cluster Analysis
The previous two parts use a lot of supervised machine-learning methods.
This part is about some unsupervised machine learning methods,
which will answer questions like:
+ How is the data organized?
+ Does the data have some inherent structure?
+ Do the samples sort themselves out into different groups and subgroups?
  
[[https://reference.wolfram.com/language/ref/FindClusters.html][FindClusters]] 来对输入的函数进行分类. 其中可以传入的参数:
+ =DistanceFunction= 对于输入的一个距离函数, 需要满足的条件:
  $f(e_i, e_i) = 0, f(e_i, e_j) \geq 0, f(e_i, e_j) = f(e_j, e_i)$.

  默认使用的距离函数根据不同的输入会有不同的结果.
  如对于 Numeric data, 可以是 Euclid Distance;
  对于 Boolean data, 使用的方法是 Matching Dissimilarity or
  Jaccard Dissimilarity; 对于 String data, 方法为 Edit Distance
  或 Hamming Distance.

  [[https://reference.wolfram.com/language/ref/Nearest.html][Nearest]] 函数用来找最近的元素. =Nearest[list, query, <number>]=.
  [[https://reference.wolfram.com/language/ref/FeatureNearest.html][FeatureNearest]], [[https://reference.wolfram.com/language/ref/FeatureSpacePlot.html][FeatureSpacePlot]]. 
+ =Method= 用来指定使用的分类方法
+ =CriterionFunction=

其他类似的函数有 [[https://reference.wolfram.com/language/ref/ClusteringTree.html][ClusteringTree]], [[https://reference.wolfram.com/language/ref/Dendrogram.html][Dendrogram]], 以及 [[https://reference.wolfram.com/language/ref/ClusteringComponents.html][ClusteringComponents]]
可以给出不同元素所对应的类别的一个 list.

[[https://reference.wolfram.com/language/ref/ClusterClassify.html][ClusterClassify]] 函数可以通过使用 *Cluster* 的方式来构建一个分类函数.

[[https://reference.wolfram.com/language/ref/LearnDistribution.html][LearnDistribution]] 和 [[https://reference.wolfram.com/language/ref/FindDistribution.html][FindDistribution]] 的作用和 [[https://reference.wolfram.com/language/ref/FindFormula.html][FindFormula]] 类似,
可以根据输入来生成一个可能的分布.

** Anomaly Detection
Answer the question about *is this unusual?*.
To perform anomaly detection, here are some methods:
+ Network instrusion
+ Fraudulent transaction
+ Unusual characteristics of diseased cells

[[https://reference.wolfram.com/language/ref/AnomalyDetection.html][AnomalyDetection]] 可以在样本的基础上训练一个找不同函数,
配合 [[https://reference.wolfram.com/language/ref/FindAnomalies.html][FindAnomalies]] 函数使用可以在输入中找到一个不同的函数结果.
后者通过传入 =AcceptanceThreashold= 参数来改变默认的剔除阀值.
这个找不同函数也可以用来 [[https://reference.wolfram.com/language/ref/DeleteAnomalies.html][DeleteAnomalies]]. 来防止不同的样本对后续分析的影响.

或者是使用 [[https://reference.wolfram.com/language/ref/LearnDistribution.html][LearnDistribution]] 生成一个分布, 并使用 [[https://reference.wolfram.com/language/ref/RarerProbability.html][RarerProbability]]
来找出那些不太可能出现的量 (通过概率来). 并且可以用这个生成的分布,
来填补之前的 =Missing= 的数据. 使用的函数是 [[https://reference.wolfram.com/language/ref/SynthesizeMissingValues.html][SynthesizeMissingValues]].

** Predict of Next Value
Use [[https://reference.wolfram.com/language/ref/SequencePredict.html][SequencePredict]] to generate a [[https://reference.wolfram.com/language/ref/SequencePredictorFunction.html][SequencePredictFunction]],
which could be used to generate the next value of input by learning
sample data: =predictFunc[input, "RandomNextElement" -> num]=. 

在 [[https://reference.wolfram.com/language/ref/SequencePredict.html][SequencePredict]] 使用不同的参数来处理输入:
+ =FeatureExtractor= 来指定如何提取输入的关键部分, 如 =SegmentedWords=
+ =Method= 中可以指定 =Markov= 链的长度 =Method -> {"Markov", "Order" -> 5}=,
  类似这样.

#+begin_quote
*灰色预测模型* $GM(1, 1)$

适用于时间序列预测, 灾变预测, 波形预测, 系统预测.
其中 $GM(1, 1)$ 表示仅含有一个变量的一阶微分方程模型.
#+end_quote

** Neural Networks
#+begin_quote
The good news is that the Wolfram Neural Net Repository and
the Neural Net Framework in the Wolfram Language makes it really easy
to incorporate this powerful technology into
our project workflow.

The bad news is that we could never do justice to covering
this topic in just 10 minutes.
#+end_quote

+ Neural networks are either chains or (acyclic) graphs of layers
+ Layers process arrays (a.k.a. tensors) of numbers
  (a.k.a. neural activities)
+ Encoders and decoders convert the input to and output from
  numerical arrays
+ Frameworks provide different loss functions
+ Frameworks provide built-in backpropagation and
  stochastic gradient descent
+ Frameworks are highly optimized to run on (special) hardware

所以关于神经网络的部分还得之后继续学.

可以参考的网站:
+ [[https://resources.wolframcloud.com/NeuralNetRepository/][WOLFRAM NEURAL NET REPOSITORY]]
+ [[https://www.wolfram.com/language/12/neural-network-framework/perform-net-surgery-for-transfer-learning.html][Perform Net Surgery for Transfer Learning]]
+ [[https://reference.wolfram.com/language/tutorial/NeuralNetworksIntroduction.html][Introduction to Neural Nets]]
+ [[https://zh.d2l.ai/index.html][动手学深度学习]] (但是不是 Mathematica 的版本)

#+begin_html
<details><summary>Introduction to Neural Networks</summary>
#+end_html

*** Introduction to Neural Networks
课程是 [[https://www.wolfram.com/wolfram-u/courses/machine-learning/introduction-neural-networks-ml010/][Wolfram U: Introduction to Neural Networks]] 的课程.

#+begin_quote
What are Neural Nets?

*Modertn term*: [[https://en.wikipedia.org/wiki/Differentiable_programming][differentiable programming (wikipedia)]]. 
#+end_quote

**** Layers (Operator)
/[Note: 因为我是照着英文从零开始学的, 所以并不知道名词应该怎么翻译. 故以下名词全部保留英文. ]/

*Layer* 是一个网络中最基本的组成, 类似于一个运算子 (operator),
但是只接受数值输入的 tensors:

#+begin_src mathematica :exports both :results value pp
  elem = ElementwiseLayer[Tanh];
  {elem @ {1, 2, 3},
  N @ Tanh @ {1, 2, 3}}
#+end_src

#+RESULTS:
: { {0.7615941762924194, 0.9640275835990906, 0.9950547814369202}, {0.7615941559557649, 0.9640275800758169, 0.9950547536867305} }

且 Layer 是可导的. (可导性为后续用于计算参数 "学习" 的一个前提. )

#+begin_src mathematica
  elem[{1, 2, 3}, NetPortGradient["Input"]]
  D[Tanh[x], x] /. x -> {1., 2., 3.}
#+end_src

#+begin_html
<details><summary>其他关于 Layers 的一些知识</summary>
#+end_html

在运算的时候可以指定 GPU 和 CPU 来进行运算:

#+begin_src mathematica
  elem[{1, 2, 3}, TargetDevice -> "GPU"]
#+end_src

/注: macOS 貌似没有对 GPU 的支持./

/[等一下, 我突然发现讲课的人用的是 macOS, 且其 GPU 至少有 3 线程... 是我的电脑不配么...]/

在新建 Layer 的时候可以指定输入的类型:

#+begin_src mathematica
  ElementwiseLayer[Tanh, "Input" -> {4, 32}]
#+end_src

上面的就是一个 $4 \times 32$ 的矩阵作为输入. 

#+begin_html
</details>
#+end_html

一些 Layer 有可学习的参数:

#+begin_src mathematica
  dot = LinearLayer[3, "Input" -> 2]
#+end_src

/注: 上面的是一个三维输出, 二维输入的一个线性 Layer./

#+name: 2-to-3-layer-example
#+header: :file ../_img/MMA/2-to-3-layer-example.svg
#+begin_src dot :exports none
  digraph G {
    rankdir = LR;
    node [shape = circle];

    subgraph cluster_Output {
      style = dashed;
      label = "Output (x3)";
      out1; out2; out3;  
    }

    subgraph cluster_Input {
      style = dashed;
      label = "Input (x2)";
      in1 -> out1 [label = "w11"];
      in1 -> out2 [lebel = "w12"];
      in1 -> out3 [lebel = "w13"];
      in2 -> out1 [label = "w21"];
      in2 -> out2 [lebel = "w22"];
      in2 -> out3 [lebel = "w23"];
    }
  }
#+end_src

#+RESULTS: 2-to-3-layer-example
[[file:../_img/MMA/2-to-3-layer-example.svg]]

[[{{ site.github.url }}/_img/MMA/2-to-3-layer-example.svg]]

而默认是没有初始化这些未知的参数的, 所以需要通过初始化的方式 ([[https://reference.wolfram.com/language/ref/NetInitialize.html][NetInitialize]])
来给一个 Layer 赋上随机的参数值. 使用 [[https://reference.wolfram.com/language/ref/NetExtract.html][NetExtract]] 可以提取出参数的具体值. 

[[{{ site.github.url }}/_img/MMA/MMA-LinearLayer-Uninitialize.png]]

通过 =?*Layer= 可以列出可用的各种 Layer. 

**** Chain and Graph
使用 [[https://reference.wolfram.com/language/ref/NetChain.html][NetChain]] 可以将多个 Layer 串联在一起, 将其输入和输出依次相连.
但是这样得到的只是单输入的一个网络. 使用 [[https://reference.wolfram.com/language/ref/NetGraph.html][NetGraph]] 可以构建有多个输入的网络. 

比如有一个函数是: =func = (Tanh @ #Input1 + LogisticSidmoid @ #Input2)&=,
用网络来表示就是:

#+begin_src mathematica
  NetGraph[{ElementwiseLayer[Tanh], ElementwiseLayer[LogisticSigmoid], TotalLayer},
  {NetPort["Input1"] -> 1, NetPort["Input2"] -> 2, {1, 2} -> 3}]
#+end_src

其中 =1=, =2= 对应的就是第一个参数 (节点列表) 中节点的顺序.
于是对于这样的 =net=, 通过 =net @ <| "Input1" -> {...}, "Input2" -> {...} |>=
的形式来进行计算.

**** NetEncoder and NetDecoder
使用 [[https://reference.wolfram.com/language/ref/NetEncoder.html][NetEncoder]] 可以对输入的数据进行一个解码.
如对输入的图片以灰度形式转换为 $12 \times 12$ 的一个张量:

#+begin_src mathematica
  NetEncoder[{"Image", {12, 12}, "ColorSpace" -> "Grayscale"}]
#+end_src

参考文档:
+ [[https://reference.wolfram.com/language/tutorial/NeuralNetworksLargeDatasets.html][Training on Large Datasets]]

或者可以直接通过 =*Layer[..., "Input" -> NetEncoder[...]]=
来指定一个 Layer 输入的类型. 

使用 [[https://reference.wolfram.com/language/ref/NetDecoder.html][NetDecoder]] 可以将张量转换为原始的输出.
通过 =*Layer[..., "Output" -> NetDecoder[...]]= 的形式,
可以来指定一个  Layer 输出的类型. 

**** Training
使用 [[https://reference.wolfram.com/language/ref/NetTrain.html][NetTrain]] 可以根据输入的数据来训练一个网络.

一个输出的数据的例子如下: ={input -> output, {1, 2} -> 3}=, 
类似这样.

其使用 Gradient Descent (梯度下降) 的方式来对参数进行查找.
但是其原理目前并不需要太过了解. 

**** An Example: a Digit Classifier
详细的介绍在 [[{{ site.github.url }}/_img/MMA/MMA-a-Digital-Number-Classifier-example.nb][Notebook]] 里面可以查看.
简单的介绍如下:

+ 使用 [[https://en.wikipedia.org/wiki/LeNet][LeNet]] 来构建的神经网络, 主要包含的内容如下:

  [[{{ site.github.url }}/_img/MMA/lenet-from-d2l-ai.svg]]

  /[Note: 图片来源: [[https://zh.d2l.ai/chapter_convolutional-neural-networks/lenet.html#img-lenet][动手深度学习: LeNet]] ]/
+ 使用一个 NetGraph 来用于训练.

注: 最终训练的网络结果可以在 [[{{ site.github.url }}/_img/MMA/trained-LeNet-for-digits.wlnet][这里]] 下载. 
#+begin_html
</details>
#+end_html

* Get the Message Across
** Visualizations
列举一些绘图用的函数以及其可能的用途和参数:

/[Note: 因为这些参数并不只能用在一个函数中, 其他函数估计也可以, 但是这里只记录一次出现. ]/

+ [[https://reference.wolfram.com/language/ref/BarChart.html][BarChart]] 柱状图, 用于表现各组分的数量比较关系
  + [[https://reference.wolfram.com/language/ref/ChartLabels.html][ChartLabels]] 用于给组分进行标记, 一个比较妙的标记方式:
    =ChartLabels -> Keys @ data=

    对于绘制的 *Label*, 默认是在下方 (x 轴),
    通过 =Placed[Keys @ data, Top]=, 可以放在柱的顶部.
    通过 =Callout[Keys @ data, Above]= 可以以箭头注记的方式标在顶部.
  + [[https://reference.wolfram.com/language/ref/AxesLabel.html][AxesLabel]] 用于绘制坐标轴上的注记 (轴末端, 水平方向),
    类似的还有 [[https://reference.wolfram.com/language/ref/FrameLabel.html][FrameLabel]] (框线侧, 框线方向) 和 [[https://reference.wolfram.com/language/ref/Frame.html][Frame]].
    后者通过布尔值来判断是否在图的四周绘制框线.
  + [[https://reference.wolfram.com/language/ref/PlotLabel.html][PlotLabel]] 用于绘制图顶部的图名称
  + [[https://reference.wolfram.com/language/ref/PlotTheme.html][PlotTheme]] 用于标记图表的主体, 类似的有 [[https://reference.wolfram.com/language/ref/ChartStyle.html][ChartStyle]], [[https://reference.wolfram.com/language/ref/PlotStyle.html][PlotSytle]].
    区别在于 *PlotTheme* 改变的是图表的数据标记, 框线之类的非主体要素;
    *ChartStyle* 改变的是图表绘制的内容 (柱条颜色) 之类的主体内容整体指定;
    *PlotStyle* 则是对每一个元素主体进行一一指定.
  + [[https://reference.wolfram.com/language/ref/ImageSize.html][ImageSize]] 指定绘制的图表的大小
+ [[https://reference.wolfram.com/language/ref/RectangleChart.html][RectangleChart]] 可以用来绘制二维向量的柱状图,
  每个矩形的横宽和竖高分别代表不同的向量的分量.
+ [[https://reference.wolfram.com/language/ref/BubbleChart.html][BubbleChart]] (泡泡图?) 可以用来绘制三维向量的图,
  用在 $xOy$ 平面上半径为 $r$ 的不同大小的圆来表示 $\{x, y, z\}$ 这样的向量.

  类似的还有 [[https://reference.wolfram.com/language/ref/GeoBubbleChart.html][GeoBubbleChart]]. 
  + [[https://reference.wolfram.com/language/ref/ChartLegends.html][ChartLegends]] 给出图例

    一个比较适合多数据的颜色的图例为 [[https://reference.wolfram.com/language/ref/BarLegend.html][BarLegend]].
    这个函数适合配合 [[https://reference.wolfram.com/language/ref/ChartStyle.html][ChartStyle]] 一起使用, 如:
    =ChartLegends -> BarLegend[{<ChartStyle>, QuantityMagnitude[MinMax[data]]}]=
  + [[https://reference.wolfram.com/language/ref/Tooltip.html][Tooltip]] 一个对于导出图片来说没什么鸟用的 Mathematica Notebook 限定的华丽操作.
    可以指定在 Mathematica 绘制出来的图片上, 当鼠标放置在特定元素上时,
    弹出的自动提示框的样式.
+ [[https://reference.wolfram.com/language/ref/Manipulate.html][Manipulate]] 可以用来给图表添加交互性, 也是一个 Mathematica Notebook 限定的华丽操作.
  像 Mathematica Engine 这样的就无福享受了.
+ 对数坐标轴, 有助于将中间的对象提取出来, 防止挤在一起
+ [[https://reference.wolfram.com/language/ref/Graph.html][Graph]] 关系图

  一个非常酷的关系图的例子:

  #+begin_src mathematica
    data = (* a list *)
    nearby = Flatten[Map[(Thread[# -> DeleteCases[Nearest[data, #, 3], #]])&, words]]
    Graph[nearbys, VertexLabels -> Automatic]
  #+end_src

  或者用 [[https://reference.wolfram.com/language/ref/NearestNeighborGraph.html][NearestNeighborGraph]] 也可以实现类似的功能.

  一个更加炫酷的例子:
  
  #+begin_src mathematica
    wordPlot[w_String] := Graph[(x = Characters[w];
      Thread[Drop[x, -1] -> Drop[x, 1]]), VertexLabels -> Automatic,
      DirectedEdges -> True];
    wordPlot["Shakespeare"]
  #+end_src

更多参考: [[https://reference.wolfram.com/language/guide/DataVisualization.html][Data Visualization]] 或者 [[https://www.wolfram.com/wolfram-u/courses/visualization-graphics/data-visualization-wolfram-language-vis201/][Data Visualization with the Wolfram Language]].
[[https://www.wolfram.com/wolfram-u/courses/catalog/?topic=visualization-graphics][Visualization and Graphics]]. 

** Automated Reports
自动化一键生成报告, 很好. 不过因为不太能用到,
(平时以 Org-mode 为主), 所以这部分快速一点:

+ [[https://reference.wolfram.com/language/ref/CreateDocument.html][CreateDocument]] 用来生成一个最终的文档
+ [[https://reference.wolfram.com/language/ref/CreateNotebook.html][CreateNotebook]] 配合 =CreateNotebook["Template"]=, 用于生成模版.
  
** Microsites and Web Apps
因为 CloudDeploy 要 Credits, 所以这部分就是穷鬼看看就好了.

其中将计算的结果用 =iframe= 的形式嵌入到网页中这个功能我觉得是可用的,
不过可能需要有一些更加实际的场景才能让穷鬼花费自己的 Credits 去部署吧. 

** Reproducible Research Checklist
这个我觉得很有必要, 可复现性. 

Publishing data-backed reproducible analyses enable the community to:
+ Verify results (Replication == Stronger evidence)
+ Build on existing results
+ Combine results for better insight

为了达到上面的目的, 一个 checklist:
+ Build a flexible, modular iterative workflow in stages
  (Question, Wrangle, Explore, Analyse, Communicate)
+ Plan for structured data analysis
+ Automate (write code) the process wherever possible.
  (Avoid point and click).
+ Document the code; Use a notebook-based workflow to combine code
  and visualizations along with text descriptions (styled and formatted
  for better communication)
+ Record and preserve
  + Sources: raw data, goals, references
  + Process: explorations, final code, observations,
    and comments (selections and rejections)
  + Output: clean data, visualizations, reports, apps
+ Use version control
+ Prepare for obsolescence - things will change,
  and sources will get removed. (存档或者对新资源重新利用)

* Other Mathematica Functions
因为官方的教程中大量使用了 Mathematica 中的缩写和函数式的知识,
所以在这里进行一个记录以用来之后的查找.
+ [[https://reference.wolfram.com/language/ref/With.html][With]], 使用方法就像是 Lisp 中的 =let= 方法. 提供临时局部变量绑定. 
  但是并不能做到按顺序进行依次赋值, 比如 =With[{a = 1, b = a + 1}, exp]=
  这样的表达式是不能够实现的. 可以通过嵌套的 =With= 来曲线救国.
+ 函数 [[https://reference.wolfram.com/language/ref/Function.html][Function]]: 定义一个完整形式的函数 =Function[arg, exp]=,
  如 =Function[{x, y}, x + y]= 生成一个函数.
  (和 Lisp 中的 =(lambda (arg) exp)= 类似)

  或者使用缩写形式: =(exp)&= 来表示一个表达式, 其中用 =#=, =##=, =#1=, =##2=
  这样的方式来表示传递进来的参数. 其中:
  + =#= 形式代表选择对应的传入参数, 默认为第一个参数,
    带上数字后缀则表示对应的位置的参数, 比如 =#1= 为第一个传入的参数,
    =#2= 为第二个传入的参数, 依此类推. 比如 =(#1 ^ #2)&[2, 3]= 就会变成 =2 ^ 3=.
  + =##= 形式代表选择从某一位开始之后的传入参数, 默认从第一个参数开始,
    带上数字后最则表示从对应位置开始的所有参数, 如 =##2= 为从第二位开始的所有参数.
    比如 =(##2)&[1, 2, 3, 4, 5]= 就会返回 =Sequence[2, 3, 4, 5]=. *比较少用*. 
+ [[https://reference.wolfram.com/language/ref/Map.html][Map]] 系的函数: [[https://reference.wolfram.com/language/ref/Apply.html][Apply]] (相关函数: [[https://reference.wolfram.com/language/ref/Evaluate.html][Evaluate]]), [[https://reference.wolfram.com/language/ref/MapThread.html][MapThread]], [[https://reference.wolfram.com/language/ref/MapIndexed.html][MapIndexed]] 等.
  一些简单的例子和缩写:

  #+begin_src wolfram
    (#^2)& /@ Range[5]  (* Abbrevation of Map[(#^2)&, Range[5]],
                          but Table[i^2, {i, 5}] is better. *)
    MapThread[(#1 -> #2)&, { {a, b}, {1, 2} }] (* Return {a -> 1, b -> 2} *)
    MapIndexed[f, {a, b}] (* Return {f[a, {1}], f[b, {2}]} *)
  #+end_src

其他的参考:
+ [[https://reference.wolfram.com/language/tutorial/FunctionalOperations.html][Functional Operation]]

#+begin_html
<details><summary>Functional Programming Quick Start</summary>
#+end_html
参考 Wolfram U 上的 [[https://www.wolfram.com/wolfram-u/courses/programming-applications/functional-programming-quick-start-dev020/][Functional Programming Quick Start]] 课程.

+ *Everything is an Expression*
  
  除了基本的元素以外, 所有的 Mathematica 中的表达式的形式都可以归化为
  =Head[elem1, elem2, ...]= 的形式. 而一些操作符号有其对应的缩写形式 (shorthand).
+ *Evaluation of Expressions*

  使用 [[https://reference.wolfram.com/language/ref/Attributes.html][Attributes]] 可以查看函数的特性, 譬如对于 [[https://reference.wolfram.com/language/ref/Plot.html][Plot]] 函数,
  =Attributes[Plot]= 的返回值为 ={HoldAll, Protected, ReadProtected}=.
  其中 =Protected= 表示被保留, 不会被随便写掉.
  而 =HoldAll= 表示 =Plot= 不会将其参数先执行求值后运算.
  (类似于 SICP 中的 applicative-order 和 normal-order 的感觉. )
+ *List, the Functional Workhorse*
  + *Constructing* a List: [[https://reference.wolfram.com/language/ref/Range.html][Range]], [[https://reference.wolfram.com/language/ref/Table.html][Table]]
  + *Manipulation* and *Extraction*: [[https://reference.wolfram.com/language/ref/Part.html][Part]], 一般使用缩写 =list[[index]]=. 
+ *Procedural to Functional Programming*

  #+begin_quote
  Mathematica is a multi-paradigm language,
  and while procedural programming is supported,
  it is better to use the system using its native paradigm.
  #+end_quote
  + Lose the Loop: =Do[exp, {iterVar, start, end}]=,
    但是效率不高, 所以并不推荐. 一般的历遍和建表的操作,
    应该选用 [[https://reference.wolfram.com/language/ref/Map.html][Map]] 和 [[https://reference.wolfram.com/language/ref/Table.html][Table]].
  + Conditional Programming:
    + =If[condition, t, f]=, 或者是缩写形式 =t /; condtion=.
    + 或者是 =func[var_?EvenQ]= 这样的 pattern 形式.
      这样的形式可以用来替换 =Which= 的分支定义:

      #+begin_src mathematica
        func[n_] := Which[cond1, exp1, cond2, exp2]
        (* The following are equal definitions *)
        func[n_?cond1] := exp1;
        func[n_?cond2] := exp2;
      #+end_src
+ *Patterns and Rules*
  + Extracting Parts with Patterns: 使用 =_= 来表示占空.
    相关的函数有 [[https://reference.wolfram.com/language/ref/Cases.html][Cases]], [[https://reference.wolfram.com/language/ref/Position.html][Position]] 和 [[https://reference.wolfram.com/language/ref/Count.html][Count]].
  + Transforming Expressions with Rules: 使用 =named_= 来为占空的匹配进行命名.
    类似于 Regexp 中的命名匹配元素.
    一个例子: ={x^2, x^3} /. x^power_ -> power=.
  + Patterns and Functions: 在函数定义的时候的表也是一个 Pattern 的例子. 
    

#+begin_html
</details>
#+end_html

* About Mathematica And Emacs
+ A helpful guide about mathematica and emacs can be seen [[https://rgoswami.me/posts/org-mathematica/][here]].

  You may need first download [[https://github.com/stuartsierra/org-mode/blob/master/contrib/lisp/ob-mathematica.el][ob-mathematica.el]]
  to your included path. And at [[https://github.com/stuartsierra/org-mode/blob/fd8a18151a7a64ded36c169f03c76bf96733bfd9/contrib/lisp/ob-mathematica.el#L34][line 34]], change
  =(org-babel-get-header params :var)= to
  =(org-babel--get-vars params)= according to this [[https://github.com/wose/ob-scad/issues/1][issue]].

  And using [[http://ai.eecs.umich.edu/people/dreeves/mash/][mash.pl]] can help with evaluation.
+ And a mathematica [[https://microsoft.github.io/language-server-protocol/][LSP]] server can be seen at Github:
  [[https://github.com/WolframResearch/LSPServer][WolframResearch]], or [[https://github.com/kenkangxgwe/lsp-wl][lsp-wl]], which need to write yourself
  emacs code. (I choose the latter one.)

  +Although I can't tell why it was slow to connect.+
+ To enable lsp-mode for org-src-mode when editing Mathematica code,
  could refer to this [[https://github.com/emacs-lsp/lsp-mode/issues/2842#issuecomment-870807018][issue]]. (which I think is important,
  especially for something like Mathematica with tons of functions.)
+ Also, you can use Jupyter and Wolfram Engine, which,
  I think is a bit complicated.

* Others
#+begin_quote
All models are wrong. Some are useful. 
#+end_quote

** 线性规化, 非线性规化和多目标规化 - 最优方案
*** 线性规划
对于 [[https://reference.wolfram.com/language/tutorial/ConstrainedOptimizationLinearProgramming.html][线性规化]] 的问题, 若有不等式方程组为条件:

$$\left\{\begin{array}{lll}x_1 + x_2 & \leq & 6 \\\\ x_1 & \geq & 1 \\\\ x_2 & \geq & 1 \\\\ 240 x_1 + 120 x_2 & \leq & 1200\end{array}\right.$$

想要求 $y = 40 x_1 + 30 x_2$ 的最大值. 

使用 [[https://reference.wolfram.com/language/ref/LinearOptimization.html][LinearOptimization]] 方法来计算最小值时的变量取值.

#+begin_src mathematica :exports both :results value pp
  LinearOptimization[ - (40 x1 + 30 x2),
    {x1 + x2 <= 6, x1 >= 1,  x2 >= 1,
       240 * x1 + 120 * x2 <= 1200}, {x1, x2}]
#+end_src

#+RESULTS:
: {x1 -> 4, x2 -> 2}

或者直接扔到 [[https://reference.wolfram.com/language/ref/Minimize.html][Minimize]] 或者 [[https://reference.wolfram.com/language/ref/Maximize.html][Maximize]] 函数中可以得到结果:

#+begin_src mathematica :exports both :results value pp
  Maximize[{40 x1 + 30 x2,
            x1 + x2 <= 6 && x1 >= 1 && x2 >= 1
            && 240 * x1 + 120 * x2 <= 1200},
    {x1, x2}]
#+end_src

#+RESULTS:
: {220, {x1 -> 4, x2 -> 2}}

并且上面的 *Minimize* 和 *Maximize* 方法还不只适用于线性规划:

#+begin_src mathematica :exports both :results value pp
  NMinimize[{x1^2 + x2^2 + x3^2 + 8,
    x1^2 - x2 + x3^2 >= 0 && x1 + x2^2 + x3^2 <= 20 &&
     -x1 - x2^2 + 2 == 0 && x2 + 2 * x3^2 == 3 &&
     x1 >= 0 && x2 >= 0 && x3 >= 0}, {x1, x2, x3}]
#+end_src

#+RESULTS:
: {10.651091807695447, {x1 -> 0.5521673359041438, x2 -> 1.2032591743672956, x3 -> 0.9478240343844963}}

注: 并不适合多变元的问题. ([[https://reference.wolfram.com/language/tutorial/ConstrainedOptimizationComparison.html][参考]])

其他的方法有二次规划 ([[https://reference.wolfram.com/language/ref/QuadraticOptimization.html][QuadraticOptimization]]),
罚函数法, 梯度法等, 可以参考文档:
+ [[https://reference.wolfram.com/language/tutorial/ConstrainedOptimizationOverview.html][Constrained Opimization]]
+ [[https://reference.wolfram.com/language/tutorial/UnconstrainedOptimizationOverview.html][Unconstrained Optimization]]

多个目标规化:
+ 每个目标都有一个完成情况的目标 $d_i^0$,
+ 取实际值函数 $f_i$, 于是可以得到正偏差 $d_i^+ = \max\{f_i - d_i^0\}$
  以及负偏差 $d_i^- = -\min\{f_i - d_i^0, 0\}$.
+ 绝对约束是前提的约束, 而目标约束是对目标的一个要求,
  类似于绝对约束是客观事实, 而目标约束是画的大饼应该有的样子,
  比如利润目标应 $f_i \geq 2,000$ 之类的. 目标约束可以有一定的偏差,
  于是可以加入正负偏差变量: $f_i + d_i^- - d_i^+ = d_i^0$.
  
  注: 上面的偏差公式的意义是: $f_i$ 可以比 $d_i^0$ 小 $d_i^-$,
  可以比 $d_i^0$ 大 $d_i^+$. 如果一个目标约束只能偏大,
  那么就不能有 $d_i^-$ 的项. 

  好处: (为什么这样做), 将偏差用正负偏差变量来代替,
  可以把目标函数变成等式的约束条件.
  等式的约束条件也就是让我们可以不用考虑目标函数的约束了. 
+ 有限因子 $P_i$, 根据多个目标的重要程度来设定不同目标函数的权值.
  一般靠查文献和瞎编得到.

  于是多个目标的 "总的" 目标函数就变成了 $F = \sum P_i d_i^*$,
  其中 $d_i^*$ 表示对于目标 $i$ 的希望: 如希望 $d_i^0$ 只能偏大,
  不会偏小, 那么有 $d_i^* = d_i^+$, 如果是在附近, 那么就是 $d_i^* = d_i^+ + d_i^-$. 

*** 贪心算法
1. 选择一点 $p$, 对应有可行域 $F(p)$, 选择可行域中最大 $\max_{p_j \in F(p)} p_j$
2. 将 $p_j$ 作为下一个 $p$ 重复步骤 1 直至没有更大的

缺点: 容易陷入局部极值.

*** 模拟退火
为了防止贪心算法的局部极值的问题. 使用模拟退火的方式来做.
适用于可信解过多, NP-hard 的问题. 

+ 在可见范围内随机选择一点, 如果该点比当前位置更高, 就直接选择该点;
  若更低, 则选择根据当前值用一定概率来选择去不去.
+ 退火的概念就是让这个选择去不去的概率随时间慢慢减少,
  确保最终会停留在最高值处. 

** 多指标评估模型
*** 层次分析法
层次分析法的方法就是将目标和方案层之间, 通过一个准则层来进行连接.
这类似于有一个评估的参数列表 $attr_i$, 希望得到一个最终的目标的决策: 

#+name: analytic-hierachy-process
#+header: :file ../_img/MMA/analytic-hierachy-process.svg
#+begin_src dot :exports none
  digraph {
    rankdir = LR;
    node [shape = circle];

    subgraph cluster_Goal {
      style = dashed;
      label = "Goal";
      goal;
    }

    subgraph cluster_criteria {
      style = dashed;
      label = "Criteria"
      {attr1, attr2, attr3} -> goal;
    }

    subgraph cluster_alternatives {
      style = dashed;
      label = "Alternatives";

      a -> {attr1, attr2, attr3};
      b -> {attr1, attr2, attr3};
      c -> {attr1, attr2, attr3};
      d -> {attr1, attr2, attr3};
    }
  }
#+end_src

#+RESULTS: analytic-hierachy-process
[[file:../_img/MMA/analytic-hierachy-process.svg]]

[[{{ site.github.url }}/_img/MMA/analytic-hierachy-process.svg]]

即每个可选项都有 $n$ 个特征项 $attr_i$, 要根据这些特征项选择一个最优的可选项.
于是就需要对特征按权值 $w_i$ 进行考虑, 最终在比较的时候, 考虑
$\sum w_i attr_i$ 来作为最终的选择依据. 

注: 不过为了让数据能够可以被更好地使用, 一开始一般可以先对数据进行归一化.
即对于特征 $attr_i$, 每个可选项都有对应的值 $attr_i(x)$, 于是归一化即
$attr_i(x) / \sum_x attr_i(x)$.

通过一个矩阵来进行描述每个特征的权重:

| $attr_i$ to $attr_j$ | $attr_1$      | $attr_2$ |
|----------------------+---------------+----------|
| $attr_1$             | $1$           | $5$      |
| $attr_2$             | $\frac{1}{5}$ | $1$      |

类似于上面这样. 比如上面认为 $attr_2$ 比 $attr_1$ 重要 $5$ 倍,
(比例是随便编的). 即 $a_{ij}$ 表示第 $i$ 个元素对于第 $j$ 个元素重要 $a_{ij}$ 倍.

为了让这个比例矩阵更加科学, 那么需要满足的是, 除了两两相比有大小,
对于整体应满足可比性. 即不会出现 $A < B < C < A$ 这样的情况出现.
于是就引入 *一致性检验*: 
+ 计算一致性比例 $CR = \frac{CI}{RI}, CI = \frac{\lambda_{max} - n}{n - 1}$,
+ 其中 $\lambda_{max}$ 为矩阵的最大特征值, $n$ 为指标数 (矩阵行数).
+ $RI$ 为平均随机一致性指标. (查表得到)

  | $n$  | 1 | 2 |    3 |    4 |    5 |
  |------+---+---+------+------+------|
  | $RI$ | 0 | 0 | 0.52 | 0.89 | 1.12 |
+ $CR < 0.1$ 时为通过一致性检验.

在得到矩阵后, 按列归一化, 按行求和后除以 $n$ 得到最终的权重值.

注: 若准则层没有客观评价因素, 那么可以将其作为准则层,
然后在其中加入可以衡量的客观因素, 重新引用层次分析法.

其他资源 (MMA)
+ 一个 [[https://demonstrations.wolfram.com/PreferenceWeightsFromPairwiseComparisons/][代码]]

*** TOPSIS 法
有 $attr_i$ 一组的客观指标 (共 $n$ 个) 用于衡量 $x_i$ 各个对象.
对于 $attr_i$ 有打分函数 $f_{\mathrm{rank_i}}$, 于是就可以用 TOPSIS 法来进行比较.

如若有如下数据:

| 对象 \ 指标 | $attr_1$                             | $attr_2$                             | $attr_3$                             |
|-------------+--------------------------------------+--------------------------------------+--------------------------------------|
| $x_1$       | $1$                                  | $-2$                                 | $6$                                  |
| $x_2$       | $2$                                  | $0$                                  | $9$                                  |
| 正理想解    | $\max f_{\mathrm{rank}_1}(attr_i(x_i))$ | $\max f_{\mathrm{rank}_2}(attr_i(x_i))$ | $\max f_{\mathrm{rank}_2}(attr_i(x_i))$ |
| 负理想解    | $\min f_{\mathrm{rank}_1}(attr_i(x_i))$ | $\min f_{\mathrm{rank}_2}(attr_i(x_i))$ | $\min f_{\mathrm{rank}_2}(attr_i(x_i))$ |

于是可以构造一个比较约定: 在 $n$ 维空间中,
若一个对象距离正理想解越近, 且距离负理想解越远, 则视为最佳的选择. 

适用于有客观指标的对象, 若没有客观指标,
可以利用层次分析法来构建一个评价指标. 

*** 熵权法
对于 $n$ 个指标 $attr_i$, 考虑每个指标对应的对象的离散程度,
通过离散程度, 也就是熵值来判断指标对综合评价的影响强弱.
比如一个集中分布的指标就不如一个差异较大的指标更能够判断评价.
于是使用熵值来作为判断指标的影响权值.

适用于数据全面, 缺少文献或者主观依据的问题,
比如有各种数据, 但是因为指标过于抽象, 不清楚哪个才是决定因素,
也不能够像层次分析法一样直观地给出定性判断, 所以可以用熵权法.
在统计的意义上建立评价体系. 适合 "公平公正" 的情况,
但是不适合考虑数据之外的影响因素. 

一个参考的文档: [[https://www.hindawi.com/journals/mpe/2020/3564835/][Effectiveness of Entropy Weight Method in Decision-Making]].

1. 数据预处理: 将所有数据正规化, 如第 $j$ 个对象的第 $i$ 个指标的值 $x_{ij}$,
   正规化为 $p_{ij} = \frac{x_{ij} - \min_j x_ij}{\max_j x_ij - \min_j x_ij}$.

   (或者 $p_{ij} = \frac{x_{ij}}{\sum_j x_{ij}}$)
2. 计算熵 [[https://reference.wolfram.com/language/ref/Entropy.html][Entropy]], 或者 $E_i = - \frac{\sum_j p_{ij} \mathrm{ln} p_{ij}}{\mathrm{ln} n}$.
3. 以熵作为权值: $w_i = \frac{1 - E_i}{\sum_i (1 - E_i)}$

** 图问题
Mathematica 中的 [[https://reference.wolfram.com/language/ref/Graph.html][Graph]]:

[[{{ site.github.url }}/_img/MMA/MMA-Graph-FindShortestPath-example.png]]

其中:
+ 对于无向图中的符号 ●--●, 其为 =\[UndirectedEdge]=,
  输入方法为 =ESC ue ESC=. 通过 =Ctrl - 7= 可以输入上标, 上标对应的是边的权值,
  或者可以用 [[https://reference.wolfram.com/language/ref/UndirectedEdge.html][UndirectedEdge]] 来直接输入: =UndirectedEdge[u, v, t]=.
+ 使用 [[https://reference.wolfram.com/language/ref/FindShortestPath.html][FindShortestPath]] 来找到图中最短的路径.
  使用 =Method= 参数可以指定找到最短路径的算法:
  [[https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm][Dijkstra]], [[https://en.wikipedia.org/wiki/Bellman–Ford_algorithm][BellmanFord]]. (注: 其他还有 [[https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm][Floyd-Warshall]] 算法)

  适用于货物运输问题, 设备更新问题这样的有一个起点和终点的规划模型的问题.
  一般的想法是首先建立节点和节点之间的权, 最后使用找最短路径的方式来解决问题. 
+ 使用 [[https://reference.wolfram.com/language/ref/FindSpanningTree.html][FindSpanningTree]] 来找到一个最小生成树. 可用的 *Method* 有:
  [[https://en.wikipedia.org/wiki/Kruskal%27s_algorithm][Kruskal]], [[https://www.sciencedirect.com/science/article/abs/pii/S0899825611000923][Minimum cost arborescences]], [[https://en.wikipedia.org/wiki/Prim%27s_algorithm][Prim]].

  适用于通信建设, 管道铺设规划, 这样的没有起点和终点的规划模型的问题.
  即想要让所有的点连接在一起的最小连接方法的问题. 
  
*** 蚁群算法
在一个图中, 如何求得遍历所有点的最短路径的方法.
且只经过城市 1 次. 其思想从蚁群如何寻找最短路径而来:
+ 蚂蚁经过路径会留下信息浓度 $\tau$, 其与经过路径的长度 $d_{ij}$ 成反比.
+ 蚂蚁在分叉路上更可能选择信息素浓度高的方向移动, 即
  
  $$P_{ij}^k(t) = \left\{\begin{array}{ll}\frac{\tau_{ij}(t)}{\sum_{s \in allowed_k} \tau_{is} (t)} & j \in allowed_k \\\\ 0 & j \notin allowed_k \end{array}\right.$$

  其中, $P_{ij}^k(t)$ 为在 $t$ 时刻第 $k$ 只蚂蚁选择从 $i$ 到 $j$ 的概率.
  $allowed_k$ 为 $k$ 蚂蚁未经过的城市集合.

  为了加速收敛速度, 考虑距离的影响:
  
  $$P_{ij}^k(t) = \left\{\begin{array}{ll}\frac{[\tau_{ij}(t)]^\alpha \times [\frac{1}{d_{ij}(t)}]^\beta}{\sum_{s \in allowed_k} [\tau_{is} (t)]^\alpha \times [\frac{1}{d_{is}(t)}]^\beta} & j \in allowed_k \\\\ 0 & j \notin allowed_k \end{array}\right.$$

  + 若 $\beta = 0$, 则完全为正反馈算法, 收敛速度较慢
  + 若 $\alpha = 0$, 则完全为贪心算法, 容易陷入局部极值
+ 信息素随时间挥发, 故 $i$ 和 $j$ 节点之间 $t$ 时刻的信息素记为 $\tau_{ij}(t)$.
  则 $\tau_{ij}(t + 1) = (1 - \rho) \tau_{ij} (t) + \sum_{k = 1}^m \Delta \tau_{ij}^k, 0 < \rho < 1$.
  其中 $\Delta \tau_{ij}^k = \frac{Q}{L_k}$ 若 $k$ 经过 $d_{ij}$, 否则为 $0$, $L_k$ 为总路径长度;
  $\rho$ 为一个信息素消失的速度. $Q$ 为一个常数. 

其他资源 (MMA):
+ 一个代码的 [[https://demonstrations.wolfram.com/AntColonyOptimizationACO/][例子]]
+ 一个函数的 [[https://resources.wolframcloud.com/FunctionRepository/resources/AntColonyOptimization][库]]

** 神经网络
适用于: 预测类, 分类, 评价类型的问题.

*** 感知机
一个感知机模型 (最简单的神经网络) 由如下的部分组成:
+ 输入层: *Input* 为输入的信号 $x$
+ 激活函数: 综合判断输入信号是否达到 *阀值*
+ 输出层: *Output* 激活函数在输出层, 求得的函数就是输出值 $y$

示意图:

#+name: neural-network-sensor-machine
#+header: :file ../_img/MMA/neural-network-sensor-machine.svg
#+begin_src dot :exports none
  digraph M {
    rankdir = LR;
    node [shape = point] output;
    node [shape = circle];

    subgraph cluster_Output {
      style = dashed;
      label = "Output";
      f -> output [label = "y"];
    }

    subgraph cluster_Input {
      style = dashed;
      label = "Input";
      x1 -> f [label = "w1"];
      x2 -> f [label = "w2"];
    }
  }
#+end_src

#+attr_org: :width 0.32
#+RESULTS: neural-network-sensor-machine
[[file:../_img/MMA/neural-network-sensor-machine.svg]]

[[{{ site.github.url }}/_img/MMA/neural-network-sensor-machine.svg]]

若要在上面的模型中加入一个阈值.

#+name: neural-network-sensor-machine-threshold
#+header: :file ../_img/MMA/neural-network-sensor-machine-threshold.svg
#+begin_src dot :exports none
  digraph M {
    rankdir = LR;
    node [shape = point] output;
    node [shape = circle];

    subgraph cluster_Output {
      style = dashed;
      label = "Output";
      sum -> f [label = "t = sum(wi * xi) - b"];
      f -> output [label = "y"];
    }

    subgraph cluster_Input {
      style = dashed;
      label = "Input";
      x1 -> sum [label = "w1"];
      x2 -> sum [label = "w2"];
      "-1" -> sum [label = "w3 = b"];
    }
  }
#+end_src

#+attr_org: :width 0.618
#+RESULTS: neural-network-sensor-machine-threshold
[[file:../_img/MMA/neural-network-sensor-machine-threshold.svg]]

[[{{ site.github.url }}/_img/MMA/neural-network-sensor-machine-threshold.svg]]

于是就可以加入一个阀值的考虑, 如果 =f(x) = x < 0 ? 0 : 1=,
那么就变成了一个决断系统了. 

注: 如果用 Mathematica 来的话, 就变成了一个简单的 *LinearLayer*:

#+begin_src mathematica
  layer = LinearLayer[1, "Input" -> 3]
#+end_src

大概就是这个样子的. 

** 蒙特卡洛法
当无法求得精确解的时候, 通过随机抽样, 根据统计试验求近似解.
适用于可行域过大, 没有通用方法求出精确解的问题.

注: 为了满足统计意义, 需要抽样数足够多.

一个经典例子:

[[{{ site.github.url }}/_img/MMA/MMA-MonteCarlo-method-and-pi.png]]

蒙特卡洛法可以配合用于非线性规划来计算初始值,
用于在非线性规划中辅助计算:
1. 对于非线性多元函数 $f(\boldsymbol{x})$, 有 $n$ 个变元 $x_i$.
   现在要在一组约束 $g_i(\boldsymbol{x})$ 下计算 $f$ 的最大 (小) 值. 
2. 随机生成 $n$ 个变元, 记为 $\boldsymbol{x}^{(k)}$. 
3. 判断约束 $g_i$ 是否被满足, 若是, 则进入下一步; 若否, 则重新生成. 
4. 判断该结果是否为更大 (小) 值, 若是, 则更新最大 (小) 值; 若否,
   则回到生成步骤重新开始. 

其他参考:
+ [[https://reference.wolfram.com/language/howto/PerformAMonteCarloSimulation.html][How to | Perform a Monte Carlo Simulation]]

** 传播模型
可以参考 [[https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology][Compartmental models in epidemiology]].
下面的模型原理非常简单, 基本只要搞清楚转换关系和约束关系即可. 

*** 指数传播模型
+ $t$ 时刻传播数 $N(t)$
+ 单位时间传播的数量 $\lambda N(t) \Delta t$
+ 方程: $N(t + \Delta t) = N(t) + \lambda N(t) \Delta t$,
  结果为 $N = N_0 e^{\lambda t}$ 类型的指数传播模型.
+ 一般只能用于描述初期的问题, 不太合理.

*** SI 模型
+ 总数 $N$, 认为是不考虑变化的常数
+ 将人群分为易感染 (susceptible, 可感染) 和已感染 (infective),
  用占比 $s(t)$ 和 $i(t)$ 来表示, 有 $s(t) + i(t) = 1$.
  忽略治愈和死亡. 
+ 感染率: 已感染者每天接触的平均人数 $\lambda$ (日感染率),
  接触可感染者时, 会将其感染成病人,
  故一个已感染者传播的人数即为其接触的可感染人数 $\lambda s(t)$. 
+ 方程: $N i(t + \Delta t) - N i(t) = \lambda N s(t) i(t) \Delta t$.
  一个例子:

  #+begin_src mathematica
    NDSolve[{i'[t] == 0.5* s[t] * i[t], s[t] + i[t] == 1, i[0] == 0.001},
      {s, i}, {t, 0, 30}];
    Plot[Evaluate[{s[t], i[t]} /. %[[1]]], {t, 0, 30}, PlotRange -> All]
  #+end_src

+ 用 $i'(t)$ 来表示传染病曲线, 在高峰期 $i = 0.5$,
  有 $t_m = \frac{1}{\lambda} \mathrm{ln} (\frac{1}{i_0} - 1)$
+ 但是没有考虑治愈

*** SIS
+ 在 SI 模型上考虑治愈比例 $\mu$, 即每天被治愈的病人占总数的比例.
  以及无免疫性, 即被治愈后仍然可以被感染.
+ 于是新的方程为:

  $$\left\{\begin{array}{llll} i'(t) & = & \lambda i(t) (1 - i(t) - \mu i(t)) & t > 0\\\\i(0) & = & i_0 & \end{array}\right.$$

*** SIR
+ 考虑治愈后不会被感染
+ $s'(t) = - \lambda i(t) s(t)$ 可感染人数的变化, 即被感染后的人数每天可以接触 $\lambda$ 人.
+ $i'(t) = \lambda i(t) s(t) - \mu i(t)$ 感染人数的变化为被感染的减去治愈的
+ $r'(t) = \mu i(t)$ 感染后治愈的人数的变化
+ $i(t) + s(t) + r(t) = 1$ 为总人数

** 马尔科夫链
适用于状态随机, 下一阶段只和当前状态有关的问题,
如健康变化, 销售储存, 等价结构变化这样的问题.

其他的参考资料:
+ [[https://www.wolfram.com/mathematica/new-in-9/markov-chains-and-queues/][Markov Chains and Queues]]
+ [[https://mathworld.wolfram.com/MarkovChain.html][Markov Chains]]

#+begin_html
<details><summary>一个题外话</summary>
#+end_html

后悔, 总之现在就是非常后悔, 如果当时我在概统课上好好听老师讲的关于赌博的问题的话,
现在估计也不会花这么多的时间来学这些了. 害. 

#+begin_html
</details>
#+end_html
