---
layout: post
title:  "Crypto Pre-learning"
date:   2021-11-01 22:02:27 +0800
categories: jekyll update
---
# 初学一点点的Crypto
小菜狗开始学Crypto... 看到题目就瑟瑟发抖, 躺倒在地, 再起不能. 

(好吧, 只是因为CTF里面加了一批新题, 然后旧的做不来, 
只好在新领域试水了. 唉. )

(这里实际上是我看之前CTF密码学的一个报告的PPT的, 
几乎就是抄PPT, 对不起了. 唉, 为什么但是没有翘课去听报告呢? )

## 窃听
假如要偷到传输的信息, 那么我们可以在通信的通道上去监听对话. 
嘿, 窃听风暴(The Lives of Others 
[豆瓣](https://movie.douban.com/subject/1900841/)), 
这个电影挺好. 

同理, 为了防止被偷听(隔墙有耳嘛), 就要加密信息, 
加密了之后再解密, 道高一尺魔高一丈, 密码学就是干这个的. 

## 密码学的基本要素(加密/解密模型)
* 明文`m`: 比如`"Hello. "`, 就是待加密的文本
* 密文`c`: 比如`I'm Groot"`, 就是加密完后的文本
* 密匙`key`: 用来加密明文的东西
* 加密算法`enc`: 将明文和密匙映射到密文上
* 解密算法`dec`: 和加密算法有点像是互逆运算

## 古典加密
* 代换密码(substitution cipher)  
  就是将字符集做一个一一映射, 如大小写互换的做法
* 置换密码(permutation cipher)  
  就是将明文顺序交换, 类似于数学里的置换(所以叫这个名字吧. )

古典加密实际上依赖于加密算法的保密, 假如加密算法被知道了, 
那么就很容易构造逆过程, 就可以解密了. 

更加尴尬的是, 古典加密的方法还可以通过用频率的方式来破解密码. 
因为这样构造的映射实际上是字符之间的一一映射, 
所以映射后的字符出现的频率和原字符的频率是一样的, 也就是说, 
在统计规律上有相似性. 这样就可以解决代换密码的问题. 举个例子, 
假如密文`r`出现很多次, 然后我们又知道这个应该是一个`e`, 
因为统计上说, `e`在英文里出现的频率很高. 

然后对于置换的问题, 可以靠**猜**(不是), 靠想象力来猜一下. 

## 现代密码
_**现代性的表现**_

* 从对加密算法的保密到对密匙的保密的重视. 
  (Kerckhoffs原则: 一个密码体系的安全只取决于密匙的安全)
  也就是说, 哪怕攻击者知道了算法, 只要密匙不知道, 
  那么攻击者也仍然什么也做不了. 
* 同时也要消除统计性, 防止攻击者用统计手段来破解


### 对称密码
所以香农就提出了两个原则: **混淆**和**扩散**. 

* 混淆
  看作是高级代换, 复杂非线性代换
* 扩散
  明文中的每一位去影响更多的密文. 

攻击方法: 去窃听密匙. 因为对称密码要求加密解密都用同一个密匙, 
但是这个密匙肯定是要通过交换才得到的, 所以这样就可以在交换的时候, 
就直接偷家. 

### 非对称加密
懂了, 就是加密用一个密匙, 发布到外面, 即公匙; 
解密用一个密匙, 自己留着, 即私匙. 所有人都知道公匙, 
所有人都用公匙来加密自己的信息, 然后发送给服务器. 
服务器用私匙解密, 中间窃听的人就不知道了. 

缺点: 运算效率低, 太麻烦, 加密的东西越大, 时间越久. 

### 混合加密
非对称加密缺点的解决方式: 混合加密

用非对称加密传递对称加密的密匙. 然后就用对称加密来传播大信息. 

攻击方法: 伪造服务器, 即**中间人攻击**. 
原理很简单, 把自己装作是可以信任的服务器, 告诉客户端自己的公匙, 
最后就可以瞒天过海. 

### 证书
解决上面的问题的方法就是引入证书来解决问题. 但是证书太难搞, 
还是因为效率的问题. 

### 哈希函数
所以引入哈希函数来快速来判断证书是否被篡改. 但是还有碰撞的风险. 
(就是不同的东西却有相同的哈希值. )
所以要看一个哈希函数是否高级, 就看它是不是难以碰撞. 

## CTF要学的东西
* 数论(唉, 头大, 要学的东西增加了)
* 抽象代数
* 读论文
* 编程(攻击和理解)

## 后记
路漫漫其修远兮, 目前题目还是不会做, 努努力去想一个做法, 
没准就给我蒙出来了. 