<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Computer Algebra PickUP | My Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Computer Algebra PickUP" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Computer Algebra PickUP 采用的教材是Joel S. Cohen Computer Algebra and Symbolic Computation." />
<meta property="og:description" content="Computer Algebra PickUP 采用的教材是Joel S. Cohen Computer Algebra and Symbolic Computation." />
<link rel="canonical" href="http://0.0.0.0:4000/learning/computer-algebra-pickup/" />
<meta property="og:url" content="http://0.0.0.0:4000/learning/computer-algebra-pickup/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-30T03:11:52+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Computer Algebra PickUP" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-30T03:11:52+00:00","datePublished":"2022-05-30T03:11:52+00:00","description":"Computer Algebra PickUP 采用的教材是Joel S. Cohen Computer Algebra and Symbolic Computation.","headline":"Computer Algebra PickUP","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/learning/computer-algebra-pickup/"},"url":"http://0.0.0.0:4000/learning/computer-algebra-pickup/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">

  <style type="text/css">
    img {
      margin-left: auto; 
      margin-right:auto; 
      display:block;
    }
  </style><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="My Blog" /><script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        // • rendering keys, e.g.:
        throwOnError : false
      });
  });
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.css" integrity="sha384-z91AFMXXGZasvxZz5DtKJse3pKoTPU0QcNFj/B4gDFRmq6Q2bi1StsT7SOcIzLEN" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.js" integrity="sha384-Af7YmksQNWRLMvro3U9F84xa0paoIu7Pu2niAIUmZoI09Q4aCsbha5dvaj1tHy6K" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Computer Algebra PickUP</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-05-30T03:11:52+00:00" itemprop="datePublished">May 30, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="computer-algebra-pickup">Computer Algebra PickUP</h1>
<p>采用的教材是<a href="https://www.ukma.edu.ua/~yubod/teach/compalgebra/%5BJoel_S._Cohen%5D_Computer_algebra_and_symbolic_comp(BookFi.org).pdf">Joel S. Cohen Computer Algebra and Symbolic Computation</a>.</p>

<p>我坚定我的决心了, 不仅要学, 还要用最作死的方式来学 – 我要用我不熟悉的Lisp Scheme, 来编写代码并且运行. 祝愿我好运吧. (笑哭).</p>

<p>(又, 我用的是<a href="http://lisppad.objecthub.net">LispPad</a>来运行代码的. 这个玩意应该在<a href="https://apps.apple.com/de/app/lisppad/id1258939760?l=en&amp;mt=12">macOS</a>和<a href="https://apps.apple.com/us/app/lisppad-go/id1565747728">iOS</a>上都能用, 非常方便并且还有很多方便的库. 如果是Unix的话, 也可以使用<a href="https://www.gnu.org/software/mit-scheme/">MIT-Scheme</a>. 或者是<a href="https://cisco.github.io/ChezScheme/#intro">Chez Scheme</a>. 不过, 最后我还是使用的是LispPad, 毕竟无脑又简单嘛. 参考的手册在<a href="https://groups.csail.mit.edu/mac/ftpdir/mit-scheme/7.7/7.7.1/doc-pdf/scheme.pdf">这里</a>和<a href="https://r6rs.mrliu.org">这里</a>)</p>

<p>(不过保险起见, 所有的代码我都再用Ruby实现一遍吧. 不过应该不会是同步的, 毕竟写代码很麻烦. 不过Ruby的代码现在还是改不掉那种丑陋的样子… )</p>

<p>(注: 因为我的数学不够好, 所以里面的所有数学名词, 能够瞎说的我都用自己的语言来瞎说了. )</p>

<h2 id="quick-ref">Quick Ref</h2>
<ul>
  <li><a href="#computer-algebra-pickup">Computer Algebra PickUP</a>
    <ul>
      <li><a href="#quick-ref">Quick Ref</a></li>
      <li><a href="#integers-rational-numbers-and-fields">Integers, Rational Numbers and Fields</a>
        <ul>
          <li><a href="#integers">Integers</a>
            <ul>
              <li><a href="#带余除法qutient-q-remainder-r">带余除法(qutient $q$, remainder $r$)</a></li>
              <li><a href="#最大公约数-greatest-common-divisor-algorithm">最大公约数 (Greatest Common Divisor Algorithm)</a></li>
              <li><a href="#算术基本定理-fundamental-theorem-of-arithmetic">算术基本定理 Fundamental Theorem of Arithmetic</a></li>
              <li><a href="#中国剩余定理-chinese-remainder-problem">中国剩余定理 Chinese Remainder Problem:</a></li>
              <li><a href="#integer-exercise">Integer Exercise</a></li>
            </ul>
          </li>
          <li><a href="#rational-number-arthmetic">Rational Number Arthmetic</a>
            <ul>
              <li><a href="#exercise">Exercise</a></li>
            </ul>
          </li>
          <li><a href="#field">Field</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="integers-rational-numbers-and-fields">Integers, Rational Numbers and Fields</h2>
<h3 id="integers">Integers</h3>
<h4 id="带余除法qutient-q-remainder-r">带余除法(qutient $q$, remainder $r$)</h4>
<p>\(\forall a, b \neq 0, \exist! q \ s.t. \  a = q b + r, 0 \leq r \leq \vert b\vert  - 1\)</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">quotient</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>  <span class="c1">; MPL: iquot(a, b)</span>
<span class="p">(</span><span class="nb">remainder</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="c1">; MPL: irem(a, b)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">iquot</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">quotient</span>  <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">irem</span>  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</code></pre></div></div>

<details>
<summary><bold>irem</bold>与<bold>iquot</bold>的性质</summary>
<li>零元素为$m$, 特征为$m$: $a m + b = b (\mathrm{mod} m)$</li>
<li>加法结合律: $a + b + c = a + (b + c) (\mathrm{mod} m)$</li>
<li>保留加法: $a + b = a (\mathrm{mod} m) + b (\mathrm{mod} m)$ <br /> 保留乘法: $a b = (a (\mathrm{mod} m)) (b (\mathrm{mod} m))$ <br /> $\Rightarrow a^n = (a (\mathrm{mod} m))^n$ </li>
<li>$\mathrm{irem}(c b, c m) = c \mathrm{irem}(b, m), c &gt; 0$</li>
</details>
<p><br /></p>

<p>整除 $b$ is $a$ divisor: $a \vert  b \Leftrightarrow (irem\ a\ b) = 0$, 且满足:</p>
<ul>
  <li>自反性: $a \vert  b \wedge b \vert  a \Rightarrow a = \pm b$</li>
  <li>和运算: $a \vert  b \wedge a \vert  c \Rightarrow c \vert  (a + b)$</li>
  <li>乘运算: $c \vert  a \Rightarrow c \vert  (a \cdot b)$</li>
  <li>传递性: $a \vert  b \wedge b \vert  c \Rightarrow a \vert  c$</li>
  <li>互素消除: $c \vert  (a b) \wedge \gcd(a, c) = 1 \rightarrow c \vert  b$</li>
  <li>素因子: $c \vert  (a b) \wedge \mathrm{prime}\ c \rightarrow c \vert  a \vee c \vert  b$</li>
  <li>互素因子: $a \vert  c \wedge b \vert  c \wedge \gcd$</li>
</ul>

<blockquote>
  <p>Note: 同余就是一种等价类的表现方式.</p>
</blockquote>

<h4 id="最大公约数-greatest-common-divisor-algorithm">最大公约数 (Greatest Common Divisor Algorithm)</h4>
<p>$\gcd (a, b) = d &gt; 0 \Leftrightarrow \forall e((e\vert a \wedge e\vert b) \rightarrow e\vert d)$  <br />
by definition, $\gcd (0, 0) = 0$.</p>
<ul>
  <li>存在性</li>
  <li>唯一性</li>
  <li>$\gcd (b, 0) = \vert b\vert $</li>
</ul>

<blockquote>
  <p><strong>Euclid’s Greatest Common Divisor Algorithm</strong>:  <br />
let $r = irem(a, b), \gcd(a, b) = \gcd(b, r)$</p>
</blockquote>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">gcd</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eq?</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">abs</span> <span class="nv">a</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">gcd</span> <span class="nv">b</span> <span class="p">(</span><span class="nf">irem</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
</code></pre></div></div>

<details>
<summary>(目前)没什么鸟用的小技术</summary>

Tail Recursion 尾递归优化: 对于那些函数在尾部有调用自身的函数, 编译器可以自动将函数编译为循环的形式来减少对栈的使用和负担. (并且同时也能够保持代码的抽象可读性)
</details>
<p><br /></p>

<p>在计算过程中, 会发现有这样的过程:</p>
<ol>
  <li>$a = q_1 b + r_1 \Rightarrow r_1 = a - q_1 b$</li>
  <li>$b = q_2 r_1 + r_2 \Rightarrow r_2 = b - q_2 (a - q_1 b) = -q_2 a + (1+q_1 q_2)b$</li>
  <li>$r_1 = q_3 r_2 + r_3$</li>
  <li>$\cdots \Rightarrow r_i = r_{i-2} - q_i r_{i-1} = (m_{i-2} - q_i m_{i-1}) a + (n_{i-2} - q_i n_{i-1}) b$</li>
  <li>$r_{\rho-2} = q_{\rho} r_{\rho-1} + r_{\rho}, r_{\rho} = 0, \gcd(a, b) = r_{\rho - 1}$</li>
</ol>

<p>于是可以有$\gcd(a, b) = m a + n b$, 得到以下的拓展算法:</p>

<blockquote>
  <p><strong>Extended Euclid’s Greatest Common Divisor Algorithm</strong>:</p>
</blockquote>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ext-gcd</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">iter-ext-gcd</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">mm</span> <span class="nv">nn</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eq?</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">a</span> <span class="nv">mm</span> <span class="nv">nn</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">mm</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">nn</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">q</span> <span class="p">(</span><span class="nf">iquot</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">iter-ext-gcd</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">m</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">mm</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">q</span> <span class="nv">m</span><span class="p">))</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">nn</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">q</span> <span class="nv">n</span><span class="p">))))))</span>
  <span class="p">(</span><span class="nf">iter-ext-gcd</span> <span class="nv">a</span> <span class="nv">b</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<p>代码写得有点丑…</p>

<blockquote>
  <p>互素 (relatively prime): $\gcd(a, b) = 1$</p>
</blockquote>

<blockquote>
  <p>可以这样构造$\mathbb{Z}/m$环上的逆元:   <br />
\(c a \equiv 1 (\mathrm{mod}\ m)\)  <br />
思路如下, $c a = k m + 1$, 于是可以利用<code class="language-plaintext highlighter-rouge">ext-gcd</code>计算出$c a + k m = 1 \Rightarrow c = (\mathrm{car}\ (\mathrm{cdr}\ (\mathrm{ext-gcd}\ a\ m)))$, 于是得到<code class="language-plaintext highlighter-rouge">inv-mod</code>过程.</p>
</blockquote>

<h4 id="算术基本定理-fundamental-theorem-of-arithmetic">算术基本定理 Fundamental Theorem of Arithmetic</h4>
<p>任一整数均可进行素因子分解: $n = \prod^s_n p_i^{n_i}$</p>

<p>(书中给出的是一个叫做<code class="language-plaintext highlighter-rouge">ifactor</code>的函数来分解整数, 但是并没有给出算法, 或者是虽然有, 但是电子版书里面没有带吧. 所以我只能自己给出一个比较烂的算法. )</p>

<details>
<summary>ifactor 试除法</summary>

因为数学和编程都不是很会, 所以最后写出了一个丑陋的函数, 这个对稍微大一点的整数运算的速度就会奇慢无比. 


<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ifactor</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">times</span> <span class="nv">n</span> <span class="nv">p</span> <span class="nv">k</span><span class="p">)</span>
  	<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">n</span> <span class="nv">p</span><span class="p">)))</span>
    	<span class="p">(</span><span class="nb">list</span> <span class="nv">n</span> <span class="nv">p</span> <span class="nv">k</span><span class="p">)</span>
    	<span class="p">(</span><span class="nf">times</span> <span class="p">(</span><span class="nb">quotient</span> <span class="nv">n</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">p</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">k</span><span class="p">))))</span>

  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">iter-ifactor</span> <span class="nv">n</span> <span class="nv">p</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">((</span><span class="nb">=</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">)</span> <span class="o">'</span><span class="p">())</span>
      <span class="p">((</span><span class="nf">prime?</span> <span class="nv">p</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">t</span> <span class="p">(</span><span class="nf">times</span> <span class="nv">n</span> <span class="nv">p</span> <span class="mi">0</span><span class="p">)))</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">t</span><span class="p">)))</span>
           	 <span class="p">(</span><span class="nf">iter-ifactor</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">p</span><span class="p">))</span>
           	 <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">t</span><span class="p">))</span> <span class="p">(</span><span class="nf">iter-ifactor</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">p</span><span class="p">))))))</span>
      <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">iter-ifactor</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">p</span><span class="p">)))))</span>

  <span class="p">(</span><span class="nf">iter-ifactor</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">))</span></code></pre></figure>


之所以称这个算法是一个不好的算法, 是因为这个算法的思路就是从小到大依次取遍所有可能的素数, 然后将这些素数给作为要尝试的东西去试试. 
</details>
<p><br /></p>

<h4 id="中国剩余定理-chinese-remainder-problem">中国剩余定理 Chinese Remainder Problem:</h4>
<ol>
  <li>在同余意义下的相等: $\mathrm{irem}(a, c) = \mathrm{irem}(b, c)$</li>
  <li>于是得到同余方程: $f(a) \equiv b (\mathrm{mod} c)$</li>
  <li>最后得到一般的同余方程组:  <br />
  \(\left\{\begin{array}{lll} x &amp; \equiv &amp; x_1 (\mathrm{mod} m_1) \\ x &amp; \equiv &amp; x_2 (\mathrm{mod} m_2) \\ \cdots &amp; \cdots &amp; \cdots \\ x &amp; \equiv &amp; x_k (\mathrm{mod} m_k) \\\end{array}\right. \quad \gcd(m_i, m_j) = 1, \forall i, j\)</li>
  <li>对于上面的同余方程组, 先取其中两个:  <br />
\(\left\{\begin{array}{lll} x &amp; \equiv &amp; x_1 (\mathrm{mod} m_1) \\ x &amp; \equiv &amp; x_2 (\mathrm{mod} m_2) \end{array}\right.\)  <br />
  然后利用一个小trick, $\gcd(m_1, m_2) = c m_1 + d m_2$  <br />
  $\Rightarrow c m_1 x_2 = (1 - d m_2) x_2 \equiv x (\mathrm{mod} \ m_2)$  <br />
  于是构造$x = c m_1 x_2 + d m_2 x_1$满足问题条件.</li>
</ol>

<p>(a solution of a system of integer remainder equations)</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">chinese-remainder</span> <span class="nv">eqs</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">eqs</span><span class="p">))</span>
     <span class="p">(</span><span class="k">let</span>  <span class="p">((</span><span class="nf">x</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">eqs</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">m</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">eqs</span><span class="p">)))))</span>
       <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">remainder</span> <span class="nv">x</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">m</span><span class="p">))</span>
     <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nf">x1</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">eqs</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">m1</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">eqs</span><span class="p">))))</span>
            <span class="p">(</span><span class="nf">x2</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">eqs</span><span class="p">))))</span>
            <span class="p">(</span><span class="nf">m2</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">eqs</span><span class="p">)))))</span>
            <span class="p">(</span><span class="nf">egcd</span> <span class="p">(</span><span class="nf">ext-gcd</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">egcd</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">d</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">egcd</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">x</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">c</span> <span class="nv">m1</span> <span class="nv">x2</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">d</span> <span class="nv">m2</span> <span class="nv">x1</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">m</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">m1</span> <span class="nv">m2</span><span class="p">)))</span>
       <span class="p">(</span><span class="nf">chinese-remainder</span>
         <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">m</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">cddr</span> <span class="nv">eqs</span><span class="p">))))))</span>
</code></pre></div></div>

<h4 id="integer-exercise">Integer Exercise</h4>
<p>挑的都是大概可能会做的来做的, 不一定保证正确.</p>

<ul>
  <li>向上取整和向下取整 floor and ceiling</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">floor</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">iquot</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">n</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nb">ceiling</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">a</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">n</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">n</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">irem</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">iquot</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">iquot</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))))</span>
</code></pre></div></div>

<p>(这两个函数在Scheme里面已经有内置了, 所以我在代码里面把他们注释了. )</p>

<ul>
  <li>integer_divisors</li>
</ul>

<p>(我承认, 我摆烂了, 这个东西想不出特别好的算法, 所以我就用暴力枚举的方法来做了. )</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">integer-divisors</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">iter</span> <span class="nv">t</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
      <span class="p">((</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">t</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
       <span class="o">'</span><span class="p">())</span>
      <span class="p">((</span><span class="nb">=</span> <span class="p">(</span><span class="nf">irem</span> <span class="nv">n</span> <span class="nv">t</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">append</span>
         <span class="p">(</span><span class="nb">list</span> <span class="nv">t</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">t</span><span class="p">)</span>
               <span class="p">(</span><span class="nf">iquot</span> <span class="nv">n</span> <span class="nv">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nf">iquot</span> <span class="nv">n</span> <span class="nv">t</span><span class="p">)))</span>
         <span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">t</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="nv">t</span><span class="p">)))))</span>

  <span class="p">(</span><span class="nf">iter</span> <span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>number of digits 统计给出输入整数$n$中的不同数字的出现次数? (原文: Give a procedure <code class="language-plaintext highlighter-rouge">Number_of_digits(n)</code> that returns the number of digits in n. )</li>
</ul>

<p>我觉得对CAS好像没什么用… 所以不写了.</p>

<ul>
  <li>基底转换, 把$n$转换为用$b$为基底的数字</li>
</ul>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">base-rep</span> <span class="nv">n</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">)</span>
    <span class="o">'</span><span class="p">()</span>
    <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nf">irem</span> <span class="nv">n</span> <span class="nv">b</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">base-rep</span> <span class="p">(</span><span class="nf">iquot</span> <span class="nv">n</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>
</code></pre></div></div>

<ul>
  <li>
    <p><strong>Proof</strong>: $a = u \gcd(a, b), b = v \gcd(a, b) \Rightarrow \gcd(u, v) = 1$  <br />
\(\left\{\begin{array}{lll}a &amp; = &amp; u (c a + d b) \\ b &amp; = &amp; v (c a + d b)\end{array}\right. \Rightarrow \gcd(a, b) = c a + d b = u \gcd(a, b) c + v \gcd(a, b) d \\ \Rightarrow 1 = u c + v d = \gcd(u, v)\)</p>
  </li>
  <li>
    <p><strong>Proof</strong>: $\gcd(a, b) = 1 \Rightarrow \gcd(a^t, b^t) = 1$  <br />
使用数学归纳法证明即可, 当$\gcd(a^t, b^t) = 1$成立, 即$\phi_t a^t + \psi_t b^t = 1$, 又因为$\gcd(a, b) = 1 = \phi_1 a + \psi_1 b = 1$, 于是就能够构造$\phi_1 a (\phi_t a^t + \psi_t b^t) (\phi_1 a + \psi_1 b) = \phi_1 a$和$\psi_1 b = \cdots$, 加起来就好了.</p>
  </li>
</ul>

<p>(大概是这么证明的吧…)</p>

<ul>
  <li>
    <p><strong>Proof</strong>: $\gcd(c a, c b) = \vert c \vert \gcd(a, b)$  <br />
\(d = \gcd(c a, c b) = u c a + v c b \Rightarrow d = c d', d' = u a + c b\)  <br />
然后用反证法, 证明不存在比$d’$大的值即可.</p>
  </li>
  <li>
    <p>$\mathrm{lcm}(a, b) = \frac{\vert a b \vert}{\gcd(a, b)}$</p>
    <ul>
      <li><strong>Proof</strong>: $\mathrm{lcm}(a, b) = m a + n b$  <br />
let $d = \gcd(a, b), a = k d, b = t d$, $\mathrm{lcm}(a, b) = t k (u a + v b)$.</li>
      <li>代码…</li>
    </ul>
  </li>
</ul>

<h3 id="rational-number-arthmetic">Rational Number Arthmetic</h3>
<p><strong>Define</strong>:</p>
<ol>
  <li>$b &gt; 1$</li>
  <li>$\gcd(a, b) = 1$</li>
</ol>

<p>因为目前没有做值的类型的处理, 所以就只是单纯地做一个简单的做法. 以后重新构造的时候需要注意这个方面的东西.</p>

<p>关于命名, 如果可以的话, 我会用那种和善的方式来命名.</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>               <span class="c1">; MPL FracOp</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">d</span> <span class="p">(</span><span class="nb">gcd</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">d</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="ss">'frac</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">a</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">b</span> <span class="nv">d</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">list</span> <span class="ss">'frac</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">d</span><span class="p">)))))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define-syntax</span> <span class="nv">sum</span>
  <span class="p">(</span><span class="k">syntax-rules</span> <span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">e0</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">integer?</span> <span class="nv">e0</span><span class="p">)</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">e0</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">e0</span><span class="p">))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">e1</span> <span class="nv">e2</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">integer?</span> <span class="nv">e1</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">list</span> <span class="ss">'add</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">e1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">e2</span> <span class="o">...</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">list</span> <span class="ss">'add</span> <span class="nv">e1</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">e2</span> <span class="o">...</span><span class="p">))))))</span>
</code></pre></div></div>

<details>
<summary>Lisp わくわく</summary>
<p>「わくわく」とは、嬉しい・楽しいことが起きると期待して興奮し、心を躍らせ、心が落ち着かないさまを表現する語。</p>

<p>嗯, 现在稍微理解了一点点Lisp宏(<a href="http://www.shido.info/lisp/scheme_syntax_e.html">参考的教程看这里</a>)的美妙之处了. 也能够理解一点点Lisp为什么要有括号这样的奇怪的形式了. 因为括号的形式将过程用list这样类似于数据的形式来储存起来, 所以就有这样的一种可能性: <strong>为什么不将过程当做数据一样处理了之后再运行呢?</strong> 于是就有了宏. (至少我是这样认为的. ) 这样的话, 哪怕一开始的语言的表达能力弱得离谱, 但是也能够通过宏的形式来变得超级牛皮. </p>

<p>(又: 在做<a href="/ruby/ri-lang/">りlang</a>的时候, 我认为这样的语法格式的一个好处就是对于Parser来说非常的方便. 后来尝试过对中文的一个Parser, 遇到的问题就是格式不好搞... 最后就全身疾而终了. )</p>

<p>感觉这样的就不能够叫做宏了, 在<a href="https://zh.wikipedia.org/wiki/巨集">维基百科</a>上面的介绍是这样的: 绝大多数情况下，“宏”这个词的使用暗示着将小命令或动作转化为一系列指令。(因为目前我还没有这些编程基础, 所以一切都是在乱说)个人感觉就像是文本的按规则查找和替换. 然而, 在Lisp里面, 感觉更像是一种对输入的过程先处理在运算一样的东西. 有点像是Ruby里面的元编程? (这个之前我觉得有点难, 所以跳过没学. 以后再说. )</p>

<details>
<summary>关于群魔乱舞的一些乱七八糟的想法</summary>
<p>这个是我在学这个东西的同时突然想到的一个东西, 觉得很有意思所以记录了下来. 因为太短了所以就不单独开一个篇章来记录了. </p>

<p>人类的创造力应该是十分强大的. 至少我是这么希望的. 但是我目前感觉有种遗憾: 我一直在学习去掌握那帮比我早出生好多年的人的创造, 却没有办法去学习如何来像他们一样搞出那么多的乱七八糟的东西. </p>

<p>以我之前的<a href="/ruby/ri-lang/">りlang</a>为例, 现在看看, 发现里面受到我学逆向的影响实在是太深了. 并且里面的数据的表达方式也受到一般的想法太深了. 最后实现出来的东西完全就是C的那一套玩意, 完全没有Lisp(除了语法上的形式)的味道. (用我们老师diss声学的话来说就是太工程了, 虽然我觉得这样又没有什么问题... )</p>

<p>但是一开始Lisp的感觉是怎么样的呢? 我觉得简直是一种超级炫酷的想法. 这样的想法真的是数学家的那种美妙的点子. (<a href="https://zh.wikipedia.org/wiki/LISP#Lisp_1.5的7个原始运算">见Lisp1.5的7个原始运算</a>) 这样简直就像是图灵机一样, 或者就像是数学公理一样, 超级酷的好不好. </p>

<p>或者是Lambda演算, (图灵机什么的就不用说了, 毕竟状态转变的想法我觉得在类似C编程的过程中自然就能够理解了. ) 之前看了一点点的书, 感觉有一种新的想法. 忽然能够理解离散数学里面函数的映射的重要性了. 为什么要把运算看作是运算呢? 为什么不把它看作是一种映射关系呢? 于是运算就变成了两点之间的连线了... </p>

<p>然后是震惊我好久的形式逻辑(确切来说是一阶逻辑, 当时我在学离散数学的一阶逻辑, 然后我们老师多说了一嘴: 高阶逻辑用一阶逻辑来表示是困难的. 一开始的人工智能... 于是我就开始搜索了一下), 哇, 真得可以有这样有趣的方式来编程的吗? (我是指<a href="https://zh.wikipedia.org/wiki/Prolog">Prolog</a>) 还有是<a href="https://www.haskell.org">Haskell</a> 之类的... 虽然我没有真的实际操作过这些语言, 但是这些语言都有很棒的一些精神(至少它们宣言的精神很棒). </p>

<p>当然了, 那些整活的语言我就不说了. (可以看看<a href="https://www.youtube.com/watch?v=6avJHaC3C2U">The Art of Code</a>, 里面有很多整活的语言介绍. ) 虽然要说实际用它们来编写一个什么大工程之类的事情的, 我认为可能性并不大. 但是它们都指出了一种可能性, 那就是一种新的发展方向的可能性. 不过大概就跟《未选择的路》一样吧, 小径深幽, 难知前路; 大道一条, 路标插满. </p>

<p>不过现在看来, 这样的近乎群魔乱舞的编程语言, 真的是非常有意思. 至少对我这个门外汉来说, 就像是刘姥姥进大观园一样有意思. 这里我确实要同意一下我们计科导老师讲的一个话(当时我把りlang给他看): 假如你要设计自己的编程语言的话, 一定要让自己的语言和别的编程语言有所不同才行. 可能是老师认为我还没有能力干一些很有意思的事情, 所以他指出的方向大多是增加计算能力, 拓展计算功能的方向等(具体我忘了, 当时太紧张了). 可惜对于我这个门外汉来说, 大概我只能够学点道道, 让精通术的计算机系的同学们来承担老师的厚望了... 残念. </p>

<p>啊, 不管它了. </p>

<p>不过因为我还是刚开始接触这些, 肯定没有那些从高中开始就接触计算机的大佬牛... 里面的话说得不一定对, 就算错了, 那就看作是我现在理解错了吧... (高中的我要是能够使用电脑来跑代码, 而不是猫在教室里面看书的话, 我也不至于现在这么玩了... )</p>
</details>

<p>嗯, 编写了这个sum函数之后, 上面的想法就是我突然之间想到的, 觉得精妙无比, 特此记录下这些狗屁文字. 估计这样的理解可能是十分肤浅的一种理解了. </p>
</details>

<p>配合一下<code class="language-plaintext highlighter-rouge">add</code>函数, 就能够得到一个计算程序了:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">add</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">((</span><span class="nb">integer?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">add</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span>
    <span class="p">((</span><span class="nb">integer?</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">add</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">else</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">a-num</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">a</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">a-dem</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">a</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">b-num</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">b-dem</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">b</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">frac</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a-num</span> <span class="nv">b-dem</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">*</span> <span class="nv">b-num</span> <span class="nv">a-dem</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">*</span> <span class="nv">a-dem</span> <span class="nv">b-dem</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define-syntax</span> <span class="nv">diff</span>
  <span class="p">(</span><span class="k">syntax-rules</span> <span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">a</span><span class="p">)</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">integer?</span> <span class="nv">a</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">frac</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">a</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
       <span class="p">((</span><span class="k">let</span> <span class="p">((</span><span class="nf">a-num</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">a</span><span class="p">)))</span>
              <span class="p">(</span><span class="nf">a-dem</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">a</span><span class="p">))))</span>
          <span class="p">(</span><span class="nf">frac</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">a</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))))</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">a</span> <span class="nv">b</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">add</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">diff</span> <span class="nv">b</span> <span class="o">...</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">prod</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">((</span><span class="nb">integer?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">prod</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span>
    <span class="p">((</span><span class="nb">integer?</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">prod</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">else</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">a-num</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">a</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">a-dem</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">a</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">b-num</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">b-dem</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">b</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">frac</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a-num</span> <span class="nv">b-num</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">*</span> <span class="nv">a-dem</span> <span class="nv">b-dem</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">quot</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span>
    <span class="p">((</span><span class="nb">integer?</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">quot</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))</span>
    <span class="p">((</span><span class="nb">integer?</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">quot</span> <span class="nv">a</span> <span class="p">(</span><span class="nf">frac</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">else</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">a-num</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">a</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">a-dem</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">a</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">b-num</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">b</span><span class="p">)))</span>
            <span class="p">(</span><span class="nf">b-dem</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cddr</span> <span class="nv">b</span><span class="p">))))</span>
        <span class="p">(</span><span class="nf">frac</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a-num</span> <span class="nv">b-dem</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">*</span> <span class="nv">a-dem</span> <span class="nv">b-num</span><span class="p">))))))</span>
</code></pre></div></div>

<p>于是就能够这样:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nf">frac</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
<span class="c1">;; =&gt; (add (frac 3 2) (add (frac 5 1) (frac 6 1)))</span>
<span class="p">(</span><span class="nb">eval</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nf">frac</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1">;; =&gt; (frac 25 2)</span>
</code></pre></div></div>

<p>但是还不够, 还要有符号计算能力. 那么什么是符号计算能力? 就是对表达式的化简和处理能力. 比如<code class="language-plaintext highlighter-rouge">(simplify '(add m (frac n d)))</code>这样的东西.</p>

<p>那么, 就重新来过吧? 简单的思路就是构造一个化简函数, 处理输入的表达式. (不过好像这一块被留到了后面介绍, 所以先做练习, 看完第二章(Automatically Simpilfy)如果没有讲的话再重新自己写. )</p>

<h4 id="exercise">Exercise</h4>
<ol>
  <li>$\gcd(a, b) = \gcd(c, d) = \gcd(b, d) = 1 \Rightarrow \gcd(a d + b c, b d) = 1$  <br />
  看着像是分数$((\mathrm{add} (\mathrm{frac} a b)$, 但是可以说分数的加法就能够处理这个问题了吗? 思考了一下, 发现有些多余.  <br />
  <strong>Proof</strong>: 反证法, 只需证明$\nexists k &gt; 1 s.t. k \mid (a d + c b) \wedge k \mid b d$. 首先有$k \nmid b, k \nmid d$(因为$k &gt; 1$), 所以$k \mid a, k \mid b$, 但是$\gcd(a, b) = 1$, 所以矛盾.</li>
  <li>(上一个问题的继续)上面给出了一个分数的表达的可能性. 那么下面的情况也行: \(\frac{a\ \mathrm{iquot}(d, g) + c\ \mathrm{iquot}(b, g)}{l}\)  <br />
  其中$l$为$lcm(a, b)$, $g$为$gcd(a, b)$. 好吧, 这个问题是个水问题, 因为$lcm = \frac{b d}{\gcd(b, d)}$, 所以就没有问题了.</li>
</ol>

<p>(总觉得好少哦… 喔吼吼. )</p>

<h3 id="field">Field</h3>
<p>关于域, <a href="/notes/linear-algebra-final/">线性代数</a>课上讲过. (还是上个学期的东西呢…)</p>

<details>
<summary>域的定义(没有新的东西)</summary>

<ul>
<li>Closure Properties 对加法和乘法的封闭性. </li>
<li>Commutative Properties 加法和乘法的交换律. </li>
<li>Associative Properties 加法和乘法的结合律. </li>
<li>Distributive Properties 加法和乘法的分配律. </li>
<li>Identities 加法的零元, 乘法的单位元. </li>
<li>Inverses 加法的负元和乘法的逆元. </li>
</ul>

<p>上面的是域的公理化(Field Axioms)的定义. 通过这样的定义, 可以得到如下的推论: </p>
<ol>
<li>单位元和零元在域中</li>
<li>任意域中元素, 存在唯一对应的逆元和负元. </li>
</ol>

<p>域中的运算: 
<ul>
<li>减法, 除法: 通过与负元, 逆元的加法和乘法来定义. </li>
<li></li>
</ul>
</p>
</details>

  </div><a class="u-url" href="/learning/computer-algebra-pickup/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
