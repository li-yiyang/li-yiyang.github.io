<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Ruby : Understanding Computation | My Blog</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Ruby : Understanding Computation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="计算的本质 – 读书记录 因为SICP太难了, 所以从这本简单一点的书开始看看, 顺带对应明年的计科导第一单元. 算是预习吧? 是吧?" />
<meta property="og:description" content="计算的本质 – 读书记录 因为SICP太难了, 所以从这本简单一点的书开始看看, 顺带对应明年的计科导第一单元. 算是预习吧? 是吧?" />
<link rel="canonical" href="http://0.0.0.0:4000/ruby/understanding-computation/" />
<meta property="og:url" content="http://0.0.0.0:4000/ruby/understanding-computation/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-13T03:12:50+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ruby : Understanding Computation" />
<script type="application/ld+json">
{"description":"计算的本质 – 读书记录 因为SICP太难了, 所以从这本简单一点的书开始看看, 顺带对应明年的计科导第一单元. 算是预习吧? 是吧?","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/ruby/understanding-computation/"},"url":"http://0.0.0.0:4000/ruby/understanding-computation/","@type":"BlogPosting","headline":"Ruby : Understanding Computation","dateModified":"2022-01-13T03:12:50+00:00","datePublished":"2022-01-13T03:12:50+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="My Blog" /><script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        // • rendering keys, e.g.:
        throwOnError : false
      });
  });
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.css" integrity="sha384-z91AFMXXGZasvxZz5DtKJse3pKoTPU0QcNFj/B4gDFRmq6Q2bi1StsT7SOcIzLEN" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.js" integrity="sha384-Af7YmksQNWRLMvro3U9F84xa0paoIu7Pu2niAIUmZoI09Q4aCsbha5dvaj1tHy6K" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Ruby : Understanding Computation</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-01-13T03:12:50+00:00" itemprop="datePublished">Jan 13, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="计算的本质--读书记录">计算的本质 – 读书记录</h1>
<p>因为SICP太难了, 所以从这本简单一点的书开始看看, 顺带对应明年的计科导第一单元. 
算是预习吧? 是吧?</p>

<p>注: 我这里面的所有的文字并不都是原书中摘录的, 大部分都是自己瞎写的. 
(甚至没有任何的修改, 都是直接写出来的, 估计错误也一大堆)看的话就图一乐吧.</p>

<h2 id="简单的ruby基础">简单的ruby基础</h2>
<p>记录一下自己之前没有太注意的点就行了.</p>

<h3 id="proc">proc</h3>
<p>将函数(方法)看作数据对象来看的思想.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 一种简单的proc的写法</span>
<span class="n">multiply</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">{</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="p">}</span>

<span class="c1"># proc的调用, 可以用call, 可以用方括号</span>
<span class="n">multiply</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="c1"># =&gt; 54</span>
<span class="n">multiply</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; 6</span>
<span class="n">multiply</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="c1"># =&gt; 12</span>
</code></pre></div></div>

<h3 id="类和模块">类和模块</h3>
<p>类就是一个分类的思想, 然后模块的思想就是多重继承?</p>

<p>在子类里面可以用<code class="language-plaintext highlighter-rouge">super</code>来调用超类里面的同名方法.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Father</span>
  <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Children</span> <span class="o">&lt;</span> <span class="no">Father</span>
  <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="k">super</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">res</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Children</span><span class="p">.</span><span class="nf">superclass</span> <span class="c1"># =&gt; Father</span>

<span class="n">child</span> <span class="o">=</span> <span class="no">Children</span><span class="p">.</span><span class="nf">new</span>
<span class="n">child</span><span class="p">.</span><span class="nf">times</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># =&gt; -6</span>
</code></pre></div></div>

<p>在子类里面可以拥有父类的方法, 并且, 通常的做到这样的方法是利用<code class="language-plaintext highlighter-rouge">module</code>来做, 
因为这样可以mix-in多个所谓的父类.</p>

<h3 id="杂项">杂项</h3>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># inspect方法, 提供一个对象在控制台中展示的方式</span>
<span class="n">o</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># =&gt; #&lt;Object:0x0000aaab0df110b8&gt;</span>
<span class="k">def</span> <span class="nc">o</span><span class="o">.</span><span class="nf">inspect</span><span class="p">;</span> <span class="s2">"OOOOOOO"</span><span class="p">;</span> <span class="k">end</span>
<span class="n">o</span> <span class="c1"># =&gt; OOOOOOO</span>

<span class="c1"># 定义方法的时候用`*'运算符来表示数目可变的参数, </span>
<span class="c1"># 虽然每个方法只能有一个可变参数, 但是可变参数的位置可以随便放</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="p">;</span> <span class="k">end</span>

<span class="c1"># 删除常量</span>
<span class="no">Object</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:remove_const</span><span class="p">,</span> <span class="ss">:CONST_NAME</span><span class="p">)</span>
<span class="c1"># 注: remove_const是一个private方法, 只能内部调用</span>
</code></pre></div></div>

<h2 id="程序和机器">程序和机器</h2>
<p>“含义”的含义, 这个问题倒是没有仔细想过. 我们周围的东西都是一些符号, 
譬如虚数$i$, 就不过是满足方程$x^2 + 1 = 0$的符号而已
(实际并不是, 因为不是这样定义的, 上面说是拥有这样性质的符号的话, 感觉更好, 
不过, 直接的那样的定义感觉很好理解), 这样的符号的指意能力, 就是一种哲学的思想. 
(我现在可以理解一点”语义分析”的意思了, 大概)</p>

<p>考虑”形式主义”, 在”我是谁? “, 这个问句里面, 有主语, 谓语, 还有宾语, 
这样的组合形成了一个句子. 然后可以适当地替换其中的成分, 就可以得到新的含义, 
然而实际上这不过是符号之间的不同组合罢了. 但是, 假如调换了顺序, 
或者改变了结构, 哪怕是同样的符号也不能够有原来的含义.</p>

<p>啊这, 感觉自己在讲废话.</p>

<p>回到计算机程序, 计算机程序的语言实际上就像是人的语言一样, 或者干脆说, 
就是人的语言也不是不行. 计算机的编程语言也有自己的结构, 然后对于这样的结构, 
计算机做的事情就是将语句破碎分割成片段, 然后重新根据片段构建一个结构的概念, 
接着再在结构的基础上形成语义的概念. (代码通过语法解析器生成抽象语法树AST, 
即Abstract Syntax Tree; 在这基础上继续执行得到程序的意义)</p>

<p>那么人是如何处理语言和语义的? 听到一句话, 然后我会下意识地去分析语法结构吗? 
但是语法结构明明是我在会说会写之后才掌握的吧? 啊, 不是, 
我觉得应该确实有这样的下意识过程. 拿学习语言的过程来看, 一开始什么也不会, 
也就有需要单纯的结构来得到语义的过程. 比如”私わ中国人です”, 
就像是一个<code class="language-plaintext highlighter-rouge">String</code>的模版一样, <code class="language-plaintext highlighter-rouge">"#{a}わ#{b}です"</code>, 就好像是在说<code class="language-plaintext highlighter-rouge">a=b</code>一样. 
感觉我学的时候就是有这样的一个转换过程, 然后熟练了之后就变成了无意识的过程了.</p>

<p>然后为了得到确定的语义, 也就是为了消除二义性, 就要有对语言的规范的定义. 
比如”我家热得快炸了”就有二义性, 首先可以这样断句(语义断句): 
“我/家//热得//快炸了”, 就是一个”主语(定语/主语)//谓语//状语”的概念. 
然后又可以这样断句: “我家/热得快//炸了”, 就是一个”主语(定语/主语)//状语”. 
(注: 热得快以一种加热器, 热水用的. )
(这段语文的分析完全是随意分析的, 有错是应该很正常的. )</p>

<h3 id="小步语义和大步语义">小步语义和大步语义</h3>
<p>书中利用了一个Simple语言的例子来讲, 我就照猫画虎地试试看看能不能也来一个.</p>

<p>首先是<strong>小步语义</strong>, 数学定义如下:</p>

\[\frac{\langle e_1, \sigma \rangle \leadsto_e e_1'}{\langle e_1 + e_2, \sigma \rangle \leadsto_e e_1' + e_2} \quad \frac{\langle e_2, \sigma \rangle \leadsto_e e_2'}{\langle v_1 + e_2, \sigma \rangle \leadsto_e v_1 + e_2'} \\ \frac{}{\langle n_1 + n_2, \sigma \rangle \leadsto_e n} \  \mathrm{if} \  n = n_1 + n_2 \\ \frac{\langle e_1, \sigma \rangle \leadsto_e e_1'}{\langle e_1 * e_2, \sigma \langle \leadsto_e e_1' * e_2} \quad \frac{\langle e_2, \sigma \rangle \leadsto_e e_2'}{\langle v_1 * e_2, \sigma \rangle \leadsto_e v_1 * e_2'} \\ \frac{}{\langle n_1 * n_2, \sigma \rangle \leadsto_e n} \  \mathrm{if} \  n = n_1 \times n_2 \\ \frac{\langle e_1, \sigma \rangle \leadsto_e e_1'}{\langle e_1 &lt; e_2, \sigma \rangle \leadsto_e e_1' &lt; e_2} \quad \frac{\langle e_2, \sigma \rangle \leadsto_e e_2'}{\langle v_1 &lt; e_2, \sigma \rangle \leadsto_e v_1 &lt; e_2'} \\ \frac{}{\langle n_1 &lt; n_2, \sigma \rangle \leadsto_e \boldsymbol{\mathrm{true}}} \  \mathrm{if} \  n_1 &lt; n_2 \quad \frac{}{\langle n_1 &lt; n_2, \sigma \leadsto_e \boldsymbol{\mathrm{false}}} \  \mathrm{if} \  n_1 \geq n_2 \\ \frac{}{\langle x, \sigma \rangle \leadsto_e \sigma(x)} \  \mathrm{if} x \in \mathrm{dom}(\sigma) \\ \frac{\langle e, \sigma \rangle \leadsto_e e'}{\langle x = e, \sigma \rangle \leadsto_s \langle x = e', \sigma \rangle} \quad \frac{}{\langle x = v, \sigma \rangle \leadsto_s \langle \boldsymbol{\mathrm{do-nothing}}, \sigma [x \mapsto v]} \\ \frac{\langle e, \sigma \rangle \leadsto_e e'}{\langle \boldsymbol{\mathrm{if}} (e) \{ s_1 \} \boldsymbol{\mathrm{else}} \{ s_2 \}, \sigma \rangle \leadsto_s \langle s_1, \sigma \rangle} \\ \frac{}{\langle \boldsymbol{\mathrm{if}} (\boldsymbol{\mathrm{true}}) \{ s_1 \} \boldsymbol{\mathrm{else}} \{ s_2 \}, \sigma \rangle, \leadsto_s \langle s_1, \sigma \rangle} \quad \frac{}{\langle \boldsymbol{\mathrm{if}} (\boldsymbol{\mathrm{false}}) \{ s_1 \} \boldsymbol{\mathrm{else}} \{ s_2 \}, \sigma \rangle \leadsto_s \langle s_2, \sigma \rangle} \\ \frac{\langle s_1, \sigma \rangle \leadsto_s \langle s_1', \sigma' \rangle}{\langle s_1; s_2, \sigma \rangle \leadsto_s \langle s_1'; s_2, \sigma' \rangle} \quad \frac{}{\langle \boldsymbol{\mathrm{do-nothing}}; s_2, \sigma \rangle \leadsto_s \langle s_2, \sigma \rangle} \\ \frac{}{\langle \boldsymbol{\mathrm{while}} (e) \{ s \}, \sigma \rangle \leadsto_s \langle \boldsymbol{\mathrm{if}} (e) \{ s; \boldsymbol{\mathrm{while}} (e) \{ s \} \} \boldsymbol{\mathrm{else}} \boldsymbol{\mathrm{else}} \{ \boldsymbol{\mathrm{do-nothing}} \}, \sigma \rangle}\]

<p>虽然看起来就是和一堆乱码没有任何的区别, 但是这就是利用一个迭代的定义方式, 
来得到了对于Simple的定义. 我觉得这样的定义十分的漂亮和简洁, 
所以我就用这个方法来介绍.</p>

<p>首先是要理解这里面的每个元素和语义的含义, 然后请尝试理解一下:</p>
<ul>
  <li>首先是<strong>表达式</strong>
$\langle \mathrm{expression}, \mathrm{environment} \rangle$   <br />
这个实际上就是我们的$e, e_1, e_2$等等的东西.</li>
  <li>表达式会对应着<strong>值</strong>, $e’$这样的东西, 或者也可以叫做是<strong>返回值</strong>.</li>
  <li>相对于$e’$的返回值(这样的值更像是符号值), 定义一个<strong>字面值</strong>, 即$n$</li>
  <li>并且有两个特殊的值, <strong>true</strong>和<strong>false</strong>, 是一个(特殊含义的符号值)</li>
  <li>然后是<strong>环境</strong>$\sigma$ (或者叫做<strong>上下文</strong>会不会更好? )</li>
  <li>在环境中有<strong>变量</strong>$x$, 也是一种符号值(应该不是符号值, 
算是一种根据符号然后去找出值的映射)</li>
</ul>

<p>(感觉自己缺乏很好的语言来描述)</p>

<p>那可以来几个例子:</p>
<ul>
  <li>$(1 * 2) + (3 * 4)$    <br />
这个表达式在上面的规则里面可以写成:  <br />
\(\langle (1 * 2) + (3 * 4), \sigma \rangle \\ \leadsto_e \langle (1 * 2), \sigma \rangle + \langle (3 * 4), \sigma \rangle \\ \leadsto (1 * 2) + (3 * 4) = 2 + 12 = 14\)    <br />
不要觉得这个简直就是脱裤子放屁, 因为我们可以利用这样的方法来得到复杂的结论, 
比如说让计算机来运算更加复杂的表达式.</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Note: 我打算和原来的做法不一样, </span>
<span class="c1">#   试试看自己写新的代码, 不是照抄原来的代码. </span>

<span class="c1"># 首先是一个能够执行代码的机器, </span>
<span class="c1">#   它的输入是一个表达式, 我们的机器的功能就是可以对这个表达式进行求值</span>
<span class="c1">#   然后还有一个环境, 在这个环境里面有我们的变量</span>
<span class="k">class</span> <span class="nc">Machine</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:exp</span><span class="p">,</span> <span class="ss">:env</span><span class="p">)</span>
  <span class="c1"># run方法的作用就是让机器来运行表达式</span>
  <span class="k">def</span> <span class="nf">run</span>
    <span class="vi">@exp</span><span class="p">.</span><span class="nf">eval</span>
  <span class="k">end</span>

  <span class="c1"># </span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Expression</span>
  <span class="c1"># 拥有一个可变的参数列表输入</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
    <span class="vi">@arg</span> <span class="o">=</span> <span class="n">arg</span>
  <span class="k">end</span>

  <span class="c1"># 这里的eval方法就是一个空方法, 可以说就是do-nothing</span>
  <span class="c1">#   具体的运算的方法要在每个子类里面定义</span>
  <span class="k">def</span> <span class="nf">eval</span><span class="p">;</span> <span class="p">;</span> <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Add</span> <span class="o">&lt;</span> <span class="no">Expression</span>
  <span class="c1"># 加法就是把所有的参数(字面值)加在一起</span>
  <span class="k">def</span> <span class="nf">eval</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="vi">@arg</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Expression</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">item</span><span class="p">.</span><span class="nf">eval</span>
      <span class="k">else</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">item</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">res</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Mutiply</span> <span class="o">&lt;</span> <span class="no">Expression</span>
  <span class="c1"># 乘法就是把所有的参数(字面值)乘在一起</span>
  <span class="k">def</span> <span class="nf">eval</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="vi">@arg</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Expression</span>
        <span class="n">res</span> <span class="o">*=</span> <span class="n">item</span><span class="p">.</span><span class="nf">eval</span>
      <span class="k">else</span>
        <span class="n">res</span> <span class="o">*=</span> <span class="n">item</span>
      <span class="k">end</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">res</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># 定义一个小于的比较</span>
<span class="k">class</span> <span class="nc">Compare</span> <span class="o">&lt;</span> <span class="no">Expression</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">super</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># 于是</span>
<span class="c1">#   Add.new(Mutiply.new(1, 2), Mutiply.new(3, 4)).eval</span>
<span class="c1">#     # =&gt; 14</span>
</code></pre></div></div>

<p>(2022-1-13: 这几天先学CTF, 有些头大. 这个先停一下. )</p>

  </div><a class="u-url" href="/ruby/understanding-computation/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
