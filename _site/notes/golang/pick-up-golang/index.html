<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Golang PickUP | My Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Golang PickUP" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Golang PickUP 咳, 计科导要用, 迫于生活, 不得不学. 为了防止以后学go让我太累, 现在先学一点点." />
<meta property="og:description" content="Golang PickUP 咳, 计科导要用, 迫于生活, 不得不学. 为了防止以后学go让我太累, 现在先学一点点." />
<link rel="canonical" href="http://0.0.0.0:4000/notes/golang/pick-up-golang/" />
<meta property="og:url" content="http://0.0.0.0:4000/notes/golang/pick-up-golang/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-26T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Golang PickUP" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-26T00:00:00+00:00","datePublished":"2022-02-26T00:00:00+00:00","description":"Golang PickUP 咳, 计科导要用, 迫于生活, 不得不学. 为了防止以后学go让我太累, 现在先学一点点.","headline":"Golang PickUP","mainEntityOfPage":{"@type":"WebPage","@id":"http://0.0.0.0:4000/notes/golang/pick-up-golang/"},"url":"http://0.0.0.0:4000/notes/golang/pick-up-golang/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">

  <style type="text/css">
    img {
      margin-left: auto; 
      margin-right:auto; 
      display:block;
    }
  </style><link type="application/atom+xml" rel="alternate" href="http://0.0.0.0:4000/feed.xml" title="My Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Golang PickUP</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-02-26T00:00:00+00:00" itemprop="datePublished">Feb 26, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="golang-pickup">Golang PickUP</h1>
<p>咳, 计科导要用, 迫于生活, 不得不学. 为了防止以后学go让我太累, 
现在先学一点点.</p>

<h2 id="golang-env-setup">Golang ENV setUP</h2>
<p>怎么说吧, 我觉得搭建环境的时候真的很让人不爽. 因为搭建环境的选择太多了, 
然而实际上的东西又是差不多的名字, 就像是题目里面的抠字眼的问题. 
太容易让人上套了. 然而讲的人却默认了省略的语境, 导致了提供帮助的人, 
却成为了阻挠的人, 或者说, 成为了题目里面的干扰条件.</p>

<blockquote>
  <p>五色令人目盲; 五音令人耳聾; 五味令人口爽; 馳騁田獵, 令人心發狂; 
難得之貨, 令人行妨. 是以聖人為腹不為目, 故去彼取此.</p>
</blockquote>

<p>所以我只知道一件事: 在我的电脑上, <code class="language-plaintext highlighter-rouge">macbook air (m1, 2020) macOS 12.2.1</code>
上面, 安装 golang 的环境还算是挺简单的. 去<a href="go.dev">官网</a>下载对应的安装包, 
就是arm版本的, 然后安装就可以使用了.</p>

<p>唯一的配置就是配置了一下 vim-go: (我用的是 
<a href="https://github.com/junegunn/vim-plug">Vim-Plug</a>)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }   
</code></pre></div></div>

<p>然后利用 <a href="https://github.com/neoclide/coc.nvim">coc-nvim</a>, 
安装了对应的 <a href="https://github.com/josa42/coc-go">lsp</a> 插件: 
<code class="language-plaintext highlighter-rouge">:CocInstall coc-go</code></p>

<p>然后就完事了. 虽然如此, 我觉得是挺简单的, 但是想了想我之前做了怎样的铺垫, 
有了多少的准备, 什么 vim 的插件, 什么 coc-nvim 还有 neovim, 一堆乱七八糟的, 
甚至还有终端的配置, 别说还有什么字体啊, 乱七八糟的一堆又一堆的东西. 
总之我忘掉了. 然后看别人的痛苦安装过程中, 我一开始是不解的, 然后, 
啊, 原来如此, 我原来忘记了啊. 这种痛苦. 啊.</p>

<h2 id="golang-basic">Golang Basic</h2>
<p>本来我就是个低水平业余计算机爱好者, 对计算机也不是很懂. 所以主要参考了
<a href="https://gobyexample-cn.github.io">Go by Example</a> 的教程.</p>

<p>然后把最简单的一些东西写在下面:</p>

<details><summary> 点击展开一坨代码 </summary>


<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="c">/*
	使用类似于 C 的注释风格
	教程来源: https://gobyexample-cn.github.io
*/</span>

<span class="c">// 将下面的程序都定义为 main 的包中的内容</span>
<span class="c">// 感觉有点像是 ruby 里面的模块</span>
<span class="k">package</span> <span class="n">main</span>

<span class="c">// formatted I/O</span>
<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="c">// 同时导入多个包的做法</span>
<span class="c">// import (</span>
<span class="c">//	 "fmt"</span>
<span class="c">//   "time"</span>
<span class="c">// )</span>

<span class="c">// main.main() 函数的名字就叫这个</span>
<span class="c">// 麻了, 我绝对不想要在逆向里见到这个家伙</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// 使用 fmt 包进行一个格式化 I/O 输出</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Lucky Me. "</span><span class="p">)</span>

	<span class="c">// 定义变量</span>
	<span class="c">// 会自动判断变量类型, 假如有一个初始值的话,</span>
	<span class="c">// 比如下面的还可以写成 var a = 1</span>
	<span class="k">var</span> <span class="n">a</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">1</span>
	<span class="k">var</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="kt">float32</span> <span class="o">=</span> <span class="m">3.14</span><span class="p">,</span> <span class="m">8.314</span>
	<span class="k">var</span> <span class="p">(</span>
		<span class="n">d</span> <span class="kt">bool</span>
		<span class="n">e</span> <span class="kt">string</span>
	<span class="p">)</span>
	<span class="c">// 初始化变量的简写</span>
	<span class="n">f</span> <span class="o">:=</span> <span class="s">"short"</span>

	<span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="no">true</span><span class="p">,</span> <span class="s">"the string of f is: "</span>
	<span class="c">// 发现会在两个参数之间加入分割用的 " "</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"a = "</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"b * c = "</span><span class="p">,</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

	<span class="c">// 定义常数</span>
	<span class="c">// 常数表达式可以执行任意精度的运算, 并且可以根据上下文自动确定类型</span>
	<span class="k">const</span> <span class="n">pi</span> <span class="o">=</span> <span class="m">3.1415926</span>

	<span class="c">// 数组</span>
	<span class="k">var</span> <span class="n">arr_1</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span>
	<span class="n">arr_2</span> <span class="o">:=</span> <span class="p">[</span><span class="m">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span>
	<span class="k">var</span> <span class="n">arr_3</span> <span class="p">[</span><span class="m">5</span><span class="p">][</span><span class="m">3</span><span class="p">]</span><span class="kt">string</span>

	<span class="c">// 访问数组的内容</span>
	<span class="n">arr_1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr_1</span><span class="p">)</span>
	<span class="n">arr_3</span><span class="p">[</span><span class="m">3</span><span class="p">][</span><span class="m">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"lalala"</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"arr_1 is"</span><span class="p">,</span> <span class="n">arr_1</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"arr_2 is"</span><span class="p">,</span> <span class="n">arr_2</span><span class="p">[</span><span class="m">4</span><span class="p">])</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"arr_3 is"</span><span class="p">,</span> <span class="n">arr_3</span><span class="p">)</span>

	<span class="c">// 切片</span>
	<span class="n">slice_1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
	<span class="n">slice_2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"L"</span><span class="p">,</span> <span class="s">"u"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">"k"</span><span class="p">,</span> <span class="s">"y"</span><span class="p">,</span> <span class="s">"Me"</span><span class="p">,</span> <span class="s">"."</span><span class="p">}</span>

	<span class="n">slice_1</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">"WoW"</span>
	<span class="n">l</span> <span class="o">:=</span> <span class="n">slice_2</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="m">6</span><span class="p">]</span>
	<span class="n">slice_3</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>

	<span class="c">// 复制的逻辑和切片的逻辑还是不一样的, 没有那种藕断丝连的感觉</span>
	<span class="nb">copy</span><span class="p">(</span><span class="n">slice_3</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
	<span class="n">l</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="o">=</span> <span class="s">"C"</span>
	<span class="c">// append 将新的元素写入到切片里面</span>
	<span class="c">// 这里会发现 "G" 把 "." 给覆盖了, 该不会可以利用类似的手法来进行溢出?</span>
	<span class="n">l</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="s">"G"</span><span class="p">)</span>

	<span class="c">// 切片的切的逻辑和 python 是差不多的感觉, 也是不包含最后一个</span>
	<span class="c">// 但是感觉像更是 C 里面的数组, 数据还是连着的, 不是 python 的复制</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">slice_1</span><span class="p">[</span><span class="m">0</span><span class="o">:</span><span class="p">])</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"l"</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"slice 2"</span><span class="p">,</span> <span class="n">slice_2</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"slice 3"</span><span class="p">,</span> <span class="n">slice_3</span><span class="p">)</span>

	<span class="c">/*
		数组的逻辑稍微和之间接触的编程语言有点不一样,
		有点像是将数组看作是一种类型, 不同长度的类型竟然还不一样
		感觉还是切片更像是数组一点...

		并且多维数组和多维切片的不同之处在于切片的数组可以像这样:
		(我的写法和 ruby 有点像)
		[[1, 2, 3], [4, 5], [2], [6, 6, 6, 6]]
		而数组只能是方方正正的东西.
	*/</span>

	<span class="c">// map (有点像是 ruby 里面的 hash)</span>
	<span class="c">// make(map[key-type]val-type)</span>
	<span class="n">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">)</span>

	<span class="n">m</span><span class="p">[</span><span class="s">"Me"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Lucky"</span>
	<span class="n">m</span><span class="p">[</span><span class="s">"Her"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Happy"</span>
	<span class="n">m</span><span class="p">[</span><span class="s">"He"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Good"</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"I'm"</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="s">"Me"</span><span class="p">])</span>

	<span class="nb">delete</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"Her"</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"He"</span><span class="p">)</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"the map is"</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

	<span class="c">// 循环结构, 只有 for 循环</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="m">1</span>
	<span class="c">// 单条件, 实际上感觉就是个 while</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">3</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="m">1</span>
	<span class="p">}</span>
	<span class="c">// 经典版本</span>
	<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">7</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="m">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c">// loop</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"comment the following line and you will loop forever. "</span><span class="p">)</span>
		<span class="c">// break 跳出</span>
		<span class="k">break</span>
		<span class="c">// continue 进入下一个循环</span>
	<span class="p">}</span>

	<span class="c">// Range 遍历</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">arr_2</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"The"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"th is"</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c">// 对于变量的赋值, 实际上还可以利用类似于 ruby 的一个操作:</span>
	<span class="c">// for _, v := range map {}</span>
	<span class="c">// for k := range map {}</span>
	<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">m</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"the"</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s">"key has"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="s">"value"</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">"Lucky Me"</span> <span class="p">{</span>
		<span class="c">// 输出是 unicode point</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"the"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s">"th is"</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// 条件判断语句, 没有三目运算符</span>
	<span class="k">if</span> <span class="m">7</span><span class="o">%</span><span class="m">2</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"7 is even"</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">num</span> <span class="o">:=</span> <span class="m">9</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="s">"is less than zero"</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"the if and else"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// 读取时间 time.Now().Weekday()</span>

	<span class="c">// switch 选择语句</span>
	<span class="k">switch</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Weekday</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">time</span><span class="o">.</span><span class="n">Saturday</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">Sunday</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Weekends"</span><span class="p">)</span>
	<span class="k">default</span><span class="o">:</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Workdays"</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// 调用函数</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">max_f</span><span class="p">(</span><span class="m">6</span><span class="p">,</span> <span class="m">9</span><span class="p">))</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">reverse</span><span class="p">(</span><span class="m">8</span><span class="p">,</span> <span class="m">6</span><span class="p">))</span>

	<span class="n">sum</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>
	<span class="c">// 将切片作为多个参数传入函数,</span>
	<span class="c">// 不是将切片当作一个参数</span>
	<span class="n">slice_4</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">9</span><span class="p">}</span>
	<span class="n">sum</span><span class="p">(</span><span class="n">slice_4</span><span class="o">...</span><span class="p">)</span>

	<span class="c">// 总感觉这种闭包很玄妙</span>
	<span class="n">nextInt</span> <span class="o">:=</span> <span class="n">intSeq</span><span class="p">()</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">nextInt</span><span class="p">())</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">nextInt</span><span class="p">())</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">nextInt</span><span class="p">())</span>
	<span class="c">// 输出会是 1, 2, 3 地递增, 因为每次都更新了函数的本体吗</span>

	<span class="c">// 闭包的递归</span>
	<span class="c">// 需要提前显式声明, 否则无法调用</span>
	<span class="k">var</span> <span class="n">fib</span> <span class="k">func</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
	<span class="n">fib</span> <span class="o">=</span> <span class="k">func</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="m">2</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">n</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">2</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">fib</span><span class="p">(</span><span class="m">7</span><span class="p">))</span>

	<span class="n">i</span> <span class="o">=</span> <span class="m">2</span>
	<span class="n">point_func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 定义函数的方法</span>
<span class="c">// 和 C 一样, 如果不写 return 的话不会自动返回最后一个表达式的值</span>
<span class="c">// 也可以写类似于 void 类型的没有返回值的函数</span>
<span class="k">func</span> <span class="n">max_f</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">a</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">b</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 多返回值, 然后对于多返回值, 可以利用多赋值来解决问题</span>
<span class="k">func</span> <span class="n">reverse</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
<span class="p">}</span>

<span class="c">// 多参数</span>
<span class="k">func</span> <span class="n">sum</span><span class="p">(</span><span class="n">num</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="s">"&amp;"</span><span class="p">)</span>
	<span class="n">total</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">num</span> <span class="p">{</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">n</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 函数的闭包</span>
<span class="k">func</span> <span class="n">intSeq</span><span class="p">()</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">i</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="c">// 这里定义了一个没有名字的函数</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="k">return</span> <span class="n">i</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">// 递归</span>
<span class="k">func</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="m">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// 指针</span>
<span class="k">func</span> <span class="n">point_func</span><span class="p">(</span><span class="n">input</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 用 &amp; 取地址, 指针的语法和 C 类似</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"the address is:"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">)</span>
	<span class="c">// 会修改指针指向的内容</span>
	<span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="m">0</span>
<span class="p">}</span></code></pre></figure>


</details>

<p>(说实话, 上面的东西基本就是照抄, 加上一点点的自己的注释, 
烂得很, 所以还是要写一点自己的东西的, 以免沦为大自然的搬运工. )</p>

<p>参考 <a href="https://zh.wikipedia.org/wiki/指令式編程">wiki</a>, 
大部分的编程语言有这样的特性:</p>
<ul>
  <li>运算语句, 然后还有储存(赋值)语句, 将运算结果储存起来</li>
  <li>循环语句, 反复执行.</li>
  <li>条件判断语句</li>
  <li>无条件判断跳转语句</li>
</ul>

<p>基本上掌握了这些就可以进行一个程序的编写了, 然后个人理解, 
计算机就是在进行一个运算的过程. 然后不同的数据在不同的声明下可能有不同的意义, 
比如字符<code class="language-plaintext highlighter-rouge">"Lucky Me"</code>, 可能在另一种观点下就是一串排列得比较好的数而已: 
<code class="language-plaintext highlighter-rouge">76, 117, 99, 107, 121, 32, 77, 101</code>, 仅此而已.</p>

<p>然后在计算机中, 这样的数据被放在不同的地方, 叫做寄存器里面. 
寄存器里面数据根据不同的读法和使用方式从而拥有了不同的意义. 
字符串, 小数(浮点数)等等数据类型更像是根据不同的数据进行一个解读. 
比如可以将字符和数进行一个一一映射, 可以将浮点数分成整数部分和小数部分
等等操作, 这样的操作根据不同的规则有了不同的实现. 这些数据储存在寄存器里, 
每个寄存器都有特定的编号, 然后计算机根据这些编号(地址)去访问数据, 
修改数据等等. 然后对于数组, 切片之类的东西更像是一种将原来的单个的数据组合起来, 
这样的组合方法有点像是讲对应的寄存器的编号列在一起, 然后在要用的时候, 
根据编号去访问数据所对应的寄存器, 然后取得数据.</p>

<p>然后, 我认为就对最基本的编程了解了大概了. 接下去再来一些之前不是很了解的, 
(就是以前学的时候从来没有用过的)</p>

<h2 id="结构">结构</h2>
<p>感觉结构有点类似于 ruby 里面的对象, 之前在做逆向的题目的时候遇到的结构, 
给我的感觉都很像是一堆数据, 函数什么的打包在一个东西里面. 
所以姑且先这样理解.</p>

<details><summary> 继续工作, 我是大自然的搬运工(bushi </summary>


<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="c">/*
  接口, 虽然我觉得有点像是通用函数的一个东西,
  是有点像是 python 的 len() 函数之类的定义的手法?
  或者像是 ruby 的 duck type 思想?
  有点像是为了将结构的类型的特点消除.
*/</span>
<span class="k">type</span> <span class="n">interface_func</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">func_1</span><span class="p">()</span> <span class="kt">int</span>
	<span class="n">func_2</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">object</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">name</span>  <span class="kt">string</span>
	<span class="n">index</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">another_obj</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">name</span> <span class="kt">string</span>
	<span class="n">size</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="c">// 给 object 类定义了一个方法</span>
<span class="k">func</span> <span class="p">(</span><span class="n">obj</span> <span class="n">object</span><span class="p">)</span> <span class="n">func_1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="m">2</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">obj</span> <span class="n">object</span><span class="p">)</span> <span class="n">func_2</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">"Hello"</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
<span class="p">}</span>

<span class="c">/*
	个人感觉上面两种方法超级像, 就是类型有点不一样.
	又, 在调用方法的时候, 会出现值和指针的转换,
	假如想要避免在调用方法的时候产生拷贝, 可以利用指针来调用方法.
*/</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a_obj</span> <span class="n">another_obj</span><span class="p">)</span> <span class="n">func_1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">a_obj</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="m">6</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">a_obj</span> <span class="n">another_obj</span><span class="p">)</span> <span class="n">func_2</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">"Oh? I don't know you, "</span> <span class="o">+</span> <span class="n">a_obj</span><span class="o">.</span><span class="n">name</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">abstract_func</span><span class="p">(</span><span class="n">obj</span> <span class="n">interface_func</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">func_1</span><span class="p">())</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">func_2</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Stuct"</span><span class="p">)</span>

	<span class="c">// 利用类似的手法进行一个初始化,</span>
	<span class="c">// 然后没有直接声明的东西就是默认为0</span>
	<span class="n">obj</span> <span class="o">:=</span> <span class="n">object</span><span class="p">{</span><span class="n">name</span><span class="o">:</span> <span class="s">"Name"</span><span class="p">}</span>
	<span class="n">obj</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="m">0</span>
	<span class="n">an_obj</span> <span class="o">:=</span> <span class="n">another_obj</span><span class="p">{</span><span class="n">name</span><span class="o">:</span> <span class="s">"Name_2"</span><span class="p">,</span> <span class="n">size</span><span class="o">:</span> <span class="m">99</span><span class="p">}</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"index of obj"</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">func_1</span><span class="p">())</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"index of obj"</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">func_2</span><span class="p">())</span>

	<span class="n">abstract_func</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
	<span class="n">abstract_func</span><span class="p">(</span><span class="n">an_obj</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">/*
  然后对于结构体, 还可以进行嵌套地使用:
  struct net_struct struct {
    object
    str string
  }
  然后可以像这样调用:
  net_struct.object.index
  等等. 并且嵌套在里面的结构的方法也能够在外面的结构体使用:
  net_struct.func_1()
  那么问题来了, 为什么要叫这个概念为 composition ?
  看不出来为什么要加上一个新的概念的理由.
	*/</span></code></pre></figure>

</details>

<p>虽然不知道这样的理解是否正确, 但是我觉得结构简直就是 ruby 里面的对象, 
对象的 instance varible, 比如<code class="language-plaintext highlighter-rouge">@name</code>, <code class="language-plaintext highlighter-rouge">@life</code>等等. 所以目前还是, 
就这样简单地理解一下. (虽然感觉自己是在用一个复杂的东西来理解简单的东西, 
或者是, 用更高层的结构去理解基础的结构… 毕竟这两个东西还是有点不一样. )</p>

<h2 id="error">Error!</h2>
<p>怎么说呢, 有点感觉 go 的错误处理有点, 感觉像是一开始写代码一堆报错中断, 
然后苦不堪言, 希望有一种能不管所有的报错, 先给我运行了之后, 然后我想看结果, 
中间有点报错我可以接受… 于是我就会在 ruby 里面这样乱写:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">edit_file</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
  <span class="n">files</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span>
    <span class="no">File</span><span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span> <span class="o">+</span> <span class="s2">".yes"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">begin</span>
  <span class="n">edit_file</span><span class="p">(</span><span class="s2">"test.txt"</span><span class="p">)</span>
<span class="k">rescue</span>
  <span class="nb">puts</span> <span class="s2">"Although there might be a error, but i don't care. "</span>
<span class="k">end</span>
</code></pre></div></div>

<p>虽然最后我发现了一个坑爹的情况, 那就是很有可能因为我这样的智障操作, 
导致了我接下来的代码爆炸了, 结果… 我还以为程序可以运行, 就只能, 
在我之前的狗屎代码里面疯狂 debug.</p>

<p>嗯, 接下来回到 go 的部分, 嗯, go 没有类似于 ruby 和 C 之类的 interrupt
类似的东西. 它, 就是, 嗯, 很朴素的, 不报错, 然后将自己的报错信息, 
用多返回值的形式返回:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">f</span><span class="p">(</span><span class="n">arg</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="m">1</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"the arg is 0"</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="m">1</span> <span class="o">/</span> <span class="n">arg</span>
<span class="p">}</span>
</code></pre></div></div>

<p>后来发现还有一个叫做 panic 的东西, 和正经的中断很像:</p>

<p>先看一个 ruby 的报错: <code class="language-plaintext highlighter-rouge">raise "I was a bad guy. "</code>, 
然后是 go 的 panic: <code class="language-plaintext highlighter-rouge">panic("I was a good guy. ")</code>. 
嗯, 就是这样.</p>

<p>然后有类似 C 里面的处理(Unix)系统信号的函数:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">(</span>
  <span class="s">"os/signal"</span>
  <span class="s">"syscall"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">// 信号通过 channel 出来</span>
  <span class="n">sigs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
  <span class="c">// 用一个函数捕捉信号, 然后送到 channel 里面</span>
  <span class="n">signal</span><span class="o">.</span><span class="n">Notify</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">)</span>

  <span class="c">// 然后就编辑函数进程来处理浙西乱七八糟的信号...</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="goroutine">GoRoutine</h2>
<p>先看代码:</p>

<details><summary> 点点点点点点 </summary>


<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">f</span><span class="p">(</span><span class="n">from</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 这里我选了一个比较离谱的 i 值,</span>
	<span class="c">// 原因是这样才能够更好地看到多线程的交替输出的效果</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="s">":"</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"GoRoutine"</span><span class="p">)</span>

	<span class="n">f</span><span class="p">(</span><span class="s">"no routine"</span><span class="p">)</span>

	<span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="s">"in a routine"</span><span class="p">)</span>
	<span class="k">go</span> <span class="n">f</span><span class="p">(</span><span class="s">"another routine"</span><span class="p">)</span>

	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"done"</span><span class="p">)</span>

	<span class="c">/*
		  然而, 上面的两个函数实际上并没有什么交流,
		  比如说, 假如我想要干一些鸟事, 比如写爬虫,
		  就需要在不同的爬虫线程里面交换信息, 防止重复爬取
			然后我们就可以利用 channels 来联系两个进程.
	*/</span>
	<span class="c">// make(chan val-type)</span>
	<span class="c">// make(chan val-type, buff_size)</span>
	<span class="c">// 传入 buff_size 来设置缓冲大小, 虽然目前看不出来怎么用</span>
	<span class="n">message</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="c">// 用 channel &lt;- value 来发送数据到通道里面去</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">message</span> <span class="o">&lt;-</span> <span class="s">"value"</span>
		<span class="n">message</span> <span class="o">&lt;-</span> <span class="s">"yes"</span>
	<span class="p">}()</span>

	<span class="c">// 用 &lt;-channel 的方式从通道里面得到数据</span>
	<span class="n">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">message</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
	<span class="n">msg</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="n">message</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

	<span class="c">/*
		  并且 &lt;-channel 会让程序为进程在子进程没有运行完前会停下来等等
		  好像这个叫做阻塞通道
		  可以利用这个特性来保证所有的通道运行完了之后才让程序结束
			方法是这样的:
			func main() {
				done := make(chan bool)
				// 其他的所有的代码
				&lt;-done
				// 用上面的 &lt;-done 的方式来保证所有的东西才结束
			}
	*/</span>
	<span class="n">c1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="n">c2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">)</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
		<span class="n">c1</span> <span class="o">&lt;-</span> <span class="s">"start one"</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
		<span class="n">c1</span> <span class="o">&lt;-</span> <span class="s">"done one"</span>
	<span class="p">}()</span>

	<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
		<span class="n">c2</span> <span class="o">&lt;-</span> <span class="s">"start two"</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">2</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
		<span class="n">c2</span> <span class="o">&lt;-</span> <span class="s">"done two"</span>
	<span class="p">}()</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">msg1</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c1</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">msg1</span><span class="p">)</span>
		<span class="k">case</span> <span class="n">msg2</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">c2</span><span class="o">:</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">msg2</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c">/*
		可以创作一些只读只写的进程:
		func write_only(ping chan&lt;- string, msg string) {
			pings &lt;- msg
		}
		func read_only(ping chan&lt;- string) {
			msg := &lt;-pings
			return msg
		}
	*/</span>

	<span class="c">/*
		非阻塞通道的写法: 前面说的阻塞通道, 就是假如没有得到输入的话, 就要一直等下去,
		但是可以换一种思路, 除非我收到了输入, 否则我就不管了, 我就直接运行下去.
		(欸, 为什么我觉得有一种中断的感觉...)
		select {
		case msg := &lt;-channel:
			// ...
		default:
			// 这里就是假如程序运行到这里没有得到 channel 的信号的话,
			// 就直接运行这里的代码
		}
	*/</span>

	<span class="c">/*
		通道遍历: 假如通道里面有一堆的数据, (哪怕通道关闭了), 也可以用这样的方式来历遍:
		for elem := range channel {
			// ...
		}
	*/</span>

  <span class="c">/*
    超时处理: 
      先了解一些关于时间的操作: 
      * 就是超级简单的等待: time.Sleep(sec * time.Second)
      * 定时器: 
        timer := time.NewTime(sec * time.Second)
        // 等待直到定时器结束
        &lt;-timer.C
        // 感觉这样的操作, 其实也不是不能自己实现... 定义一个结构, 
        // 然后在这个结构里面开一个通道, 然后利用通道的阻塞效果...
        // 管它呢
      * 打点器: (笑死, 这个翻译, 太形象了, 打点计时器... )
        ticker := time.NewTicker(sec * time.Second)
        for {
          select {
          case t := &lt;-ticker.C:
            // 这个时候的 t 就是时间, Time.now
          default: 
            // ...
          }
        }
    然后就是关于超时的处理: 
    select {
    case res := &lt;-channel:
      // ...
    case &lt;-time.After(sec * time.Second):
      // 超过时间没有收到的话, 就会触发这个分支
    }
  */</span>

	<span class="c">// 关闭通道</span>
	<span class="c">// 关了之后就不能往里面写数据了</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>


</details>

<p>我觉得这个看起来真香, 虽然我之前 ruby 里面的 Thread 一直没能理解, 
然后最后就只好在一堆的 bug 之中, 灰溜溜的跑路, 最后不得不去写单线程. 
(据说现在引入了 Fiber, 但是我没有试过, 以后有时间了之后试试. )</p>

<p>但是上面的感觉更像是每一个线程对应一个通道, 但是假如我想搞点<del>薯条</del>, 
哦, 不是, <del>我想搞很多的薯条, 非常非常多的那种</del>, 就是我要处理超级多的线程, 
然后来一个大统领来管理这些线程. 不错.</p>

<details><summary> 最简单的版本 </summary>


<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">worker</span><span class="p">(</span><span class="n">id</span> <span class="kt">int</span><span class="p">,</span> <span class="n">jobs</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="n">results</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">jobs</span> <span class="p">{</span>
		<span class="c">// ...</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// 新建通道</span>

	<span class="c">// 新建分支</span>
	<span class="k">for</span> <span class="n">w</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="m">3</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">go</span> <span class="n">worker</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">job_channel</span><span class="p">,</span> <span class="n">results_channel</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c">// 发放任务</span>
	<span class="k">for</span> <span class="n">job_id</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">job_id</span> <span class="o">&lt;=</span> <span class="n">job_number</span><span class="p">;</span> <span class="n">job_id</span><span class="o">++</span> <span class="p">{</span>
		<span class="c">// job_channel &lt;- mission</span>
	<span class="p">}</span>

	<span class="nb">close</span><span class="p">(</span><span class="n">job_channel</span><span class="p">)</span>

	<span class="c">// 收集结果</span>
	<span class="k">for</span> <span class="n">job_id</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">job_id</span> <span class="o">&lt;=</span> <span class="n">job_number</span><span class="p">;</span> <span class="n">job_id</span><span class="o">++</span> <span class="p">{</span>
		<span class="c">// result := &lt;- result_channel</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

</details>

<p>上面的感觉有点没能体现高级的地方, 所以折叠了. 
下面的是利用了一个叫做 WaitGroup 的东西来搞的, 感觉有点意思</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">waitgroup</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="m">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c">// 告诉 waitgroup 增加了一个要等待的线程</span>
		<span class="n">waitgroup</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="c">// 利用了闭包的东西</span>
			<span class="k">defer</span> <span class="n">waitgroup</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
			<span class="c">// do something</span>
		<span class="p">}()</span>
	<span class="p">}</span>

	<span class="c">// 等待 waitgroup 里面所有的东西都执行完毕</span>
	<span class="n">waitgroup</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>嗯, 相比前面折叠的东西, 这个更加简单一点. 虽然感觉… 差不多?</p>

<p>但是假如是同时进行一个读写变量的操作? 
嗯… 怎么觉得单看上去的话和 ruby 里面的 Mutex 一样…</p>

<details><summary> 锁住变量的水分, 让它保持鲜嫩 </summary>


<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"sync"</span>
	<span class="s">"sync/atomic"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">mutex_var</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="c">// 重点是下面的 sync.Mutex 的变量</span>
	<span class="c">// 可以有锁状态和解锁的状态</span>
	<span class="n">mu</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="c">// 其实其他的变量是什么都挺无所谓的</span>
	<span class="n">variable</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// 因为互斥锁不能复制, 所以要用指针来传递函数, </span>
<span class="c">// 反之出现尴尬</span>
<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">mutex_var</span><span class="p">)</span> <span class="n">edit_string</span><span class="p">(</span><span class="n">new_str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// 对于 v, 因为要使用, 所以要锁定</span>
	<span class="n">v</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
	<span class="c">// defer 关键词告诉程序, 在函数运行结束后将变量解锁</span>
	<span class="k">defer</span> <span class="n">v</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
	<span class="c">// 其实个人觉得, 这个互斥锁防君子不防小人, </span>
	<span class="c">// 就是所有程序在想要修改 v 的时候, 先看看锁是否打开, </span>
	<span class="c">// 然后再决定是否修改, 嗯...</span>
	<span class="n">v</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">new_str</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// 利用的是一个原子计数器 </span>
	<span class="c">// 原子计数器的作用就是为了防止同时写的情况的出现</span>
	<span class="k">var</span> <span class="n">adder</span> <span class="kt">uint64</span>
	
	<span class="n">mutex_v</span> <span class="o">:=</span> <span class="n">mutex_var</span><span class="p">{</span>
		<span class="n">variable</span><span class="o">:</span> <span class="s">"string"</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">50</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>

		<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">for</span> <span class="n">c</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="m">1000</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span> <span class="p">{</span>
				<span class="c">// 将计数器进行一个加</span>
				<span class="n">atomic</span><span class="o">.</span><span class="n">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adder</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
				<span class="c">// 其实应该是填写一些新的东西的</span>
				<span class="n">mutex_v</span><span class="o">.</span><span class="n">edit_string</span><span class="p">(</span><span class="s">"string"</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
		<span class="p">}()</span>

		<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"adder: "</span><span class="p">,</span> <span class="n">adder</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>


</details>

<p>差不多够用了, 虽然我知道, 多线程对我目前是没什么用的, 
还是文件处理之类的朴素的东西好…</p>

<h2 id="排序">排序</h2>
<p>算法总是要会的吧? 好像不用, 对于水平低下, 从未学过算法的我, 
只知道 ruby 里面有一个排序算法叫 <code class="language-plaintext highlighter-rouge">[3, 1, 2].sort</code>, 再高级一点就只有, 
<code class="language-plaintext highlighter-rouge">[3, 1, 2].sort { |a, b| a &gt; b }</code>之类的. 或者就是<code class="language-plaintext highlighter-rouge">sort_by</code>. 就, 没了…</p>

<p>所以, 就… 折叠了吧…</p>

<details><summary> 排序... 在搞算法的那些人眼里... 就是个调包而已 </summary>


<figure class="highlight"><pre><code class="language-go" data-lang="go"><span class="k">import</span> <span class="s">"sort"</span>

<span class="c">// 简简单单的排序</span>
<span class="n">iarr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">3</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">}</span>
<span class="n">sort</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="n">iarr</span><span class="p">)</span>
<span class="n">sarr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">}</span>
<span class="n">sort</span><span class="o">.</span><span class="n">Strings</span><span class="p">{</span><span class="n">sarr</span><span class="p">}</span>

<span class="c">// 自定义排序, 感觉就是利用了前面的通用函数的感觉</span>
<span class="c">// 主要要对排序的东西定义 Len, Swap, Less 三个函数</span>
<span class="c">// 然后 sort 包就会利用这三个函数来排序</span>
<span class="k">type</span> <span class="n">the_type</span> <span class="p">[]</span><span class="kt">string</span>
<span class="k">func</span> <span class="p">(</span><span class="n">arr</span> <span class="n">the_type</span><span class="p">)</span> <span class="n">Less</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">,</span> <span class="n">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="c">// 其实感觉很像是 ruby 的 sort 的带 block 的模式</span>
  <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="p">}</span></code></pre></figure>

</details>

<h2 id="文件读写">文件读写</h2>
<p>需要调用一个 <code class="language-plaintext highlighter-rouge">os</code> 包. 然后在代码里面就:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 这里我就想到了一个问题, 假如有想我一样的菜鸟, </span>
<span class="c">// 忘了写代码的时候加上 err 检查, 然后错误地读了文件</span>
<span class="c">// 那不是会很糟糕? </span>
<span class="n">r_data</span><span class="p">,</span> <span class="n">r_err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">ReadFile</span><span class="p">(</span><span class="s">"file/path"</span><span class="p">)</span>
<span class="n">check</span><span class="p">(</span><span class="n">r_err</span><span class="p">)</span>
<span class="c">// 用 string 函数将这些读取的东西转换为字符串</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">r_data</span><span class="p">))</span>

<span class="c">// 麻了, 写文件的模式还是这种... 看来还要记住? </span>
<span class="c">// 应该是有的查的... 没错, 就是unix的 32 位模式数...</span>
<span class="c">// 就是这样: -rwxrwxrwx, </span>
<span class="c">// 分别表示是否是目录, 所有者权限, 用户组权限, 其他人权限</span>
<span class="k">const</span> <span class="n">WRITE_MODE</span> <span class="o">=</span> <span class="m">0644</span>
<span class="n">w_data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"a string, which would be translated into byte and write to file"</span><span class="p">)</span>
<span class="n">w_err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">WriteFile</span><span class="p">(</span><span class="s">"file/path"</span><span class="p">,</span> <span class="n">w_data</span><span class="p">,</span> <span class="m">0644</span><span class="p">)</span>
</code></pre></div></div>

<p>不得不说, 上面的操作实在是比较简单, 想要高级一点的, 更底层一点的, 
还是用 <code class="language-plaintext highlighter-rouge">os.Open(file_path)</code> 和 <code class="language-plaintext highlighter-rouge">os.Create(file_path)</code>. 因为没用过, 
所以就这样云过去吧…</p>

<h2 id="假装我已经把该学的学了">假装我已经把该学的学了</h2>
<p>嗯, 所以到时候学习的时候遇到什么东西再临时抱佛脚算了, 摆烂…</p>

  </div><a class="u-url" href="/notes/golang/pick-up-golang/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
