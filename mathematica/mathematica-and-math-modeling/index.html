<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Mathematica and Math Modeling | My Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Mathematica and Math Modeling" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="非常功利的数学建模准备 注: 本篇为 Mathematica and MultiParadigm Data Science 中和数学建模的一个整理. 主要是为了方便查找和使用对应的算法和程序. 思路是这样的: 因为准备时间有限, 所以尽可能地只使用尽可能少的工具. 所以会尽可能地在 Mathematica 中去找到所有的建模所需的程序和函数. Optimize Maximize &amp; Minmize Wolfram Optimization: LinearOptimization 适用于线性约束问题下的线性函数的最小值的查找. LinearOptimization[x + y, {x + 2 * y == 3, x &gt;= 0, y &gt;= 0}, {x, y}] 剩下的两个函数和其语法类似, 代码略. FindMinimum 适用于寻找邻域内的局部最小值, 寻找的方式有点像是贪心算法. Minimize 适用于寻找全局的最小值 (注: 该函数对于 非常多 的变量的效果并不是很好. 虽然我觉得我也没有可能遇到这种情况就是了&#8230;) 一个比较炫酷的例子 可以使用 StepMonitor 配合 Sow 和 Reap 来捕捉每一步具体的过程, 可以用于计算和绘制查找最小值的过程: With[{exp = (1 - x)^2 + 100*(-x^2 - y)^2 , xrange = {x, -1.5, 1.5}, yrange = {y, -1.5, 1.5}}, With[{res = Reap[NMinimize[exp, {x, y}, StepMonitor :&gt; Sow[{x, y}]]]}, With[{path = res[[2, 1]], minValue = res[[1, 1]]}, ContourPlot[exp, xrange, yrange, Epilog -&gt; {Arrow[path], Point[path]}, Contours -&gt; Table[10^-i, {i, -2, 10}], ColorFunction -&gt; (Hue[(Log[10, #] + 10)/12] &amp;), ColorFunctionScaling -&gt; False, ImageSize -&gt; Medium] ]]] 参考的是官方文档的 StepMonitor 的例子. 可能需要重新修改一下关于着色的函数. Graph Graphs &amp; Networks: Graph 构建图结构, 适用于存在 &#8220;节点-边&#8221; 的结构的问题. FindShortestPath 寻找两点之间最短路径. FindSpanningTree 寻找连接所有节点的最小生成树. Ant Conony Optimization 通过模拟蚁群和信息素的行为来尝试解决问题. Ant Colony Optimization (ACO) | WOLFRAM Demonstrations Project AntColonyOptimization | WOLFRAM FUNCTION REPOSITORY FindMaximumFlow 找到最大流. Other Optimise Dynamic Programming 不熟 Dynamic Programming | www.yaroslavvb.com Greedy Algorithm 不熟 Simulated Annealing 模拟退火, 在贪心算法基础上逐渐减少随机转移的概率. 或者直接调用函数 莽就完事了: NMinimize[f, vars, Method -&gt; &quot;SimulatedAnnealing&quot;] Predict Interpolation Interpolation | Wikipedia Interpolation 适用于根据数据来拟合一个函数, 可以用来拟合缺失的值. 不一定适合需要计算连续变化的问题, 适合函数值的一个结果. InterpolatingPolynomial 牛顿多项式插值法. FindFormula 用于根据数据来找一个函数形式, 可以通过 TargetFunctions 来指定用来猜的函数. Probability FindDistribution 根据数据来找出一个分布的概率函数. 可以用来判断函数的分布可能以及判断是否会有不同的数据分布. RandomVariate 根据概率分布来随机生成数据. AnomalyDetection 得到一个能够用来判断异常数据的一个判断函数, 其核心是根据概率分布的一个解决方式. Finite Markov Processes | Wolfram Doc 有限 Markov 链, 适用于仅和当前状态有关的变化问题. DiscreteMarkovProcess 可以根据转移矩阵来生成一个 Markov 转移分布. 可以通过 RandomFunction 来对这个结果进行模拟. Gray Model 可参考文档: The Grey Forecasting Model for the Medium-and Long-Term Load Forecasting | iop.org AutoRegression ARProcess 模拟 AR 过程 Autoregressive Model | Wikipedia 自动回归模型 Vector Autogression | Wikipedia 向量 AR 过程 ARMAProcess 自回归滑动平均模型 ARIMAProcess 模拟 ARIMA 过程 Autoregressive Inegrated Moving Average | Wikipedia Measure Ranking AHP 可参考的文档: Preference Weights from Pairwise Comparisons | WOLFRAM Demonstrations Project TOPSIS TOPSIS | Wikipedia 计算正负理想解以距离其距离正负理想解的距离来作为判断因素 Max, Min 用于计算正负理想解 EuclideanDistance 用于计算距离 (其他的距离函数可以考虑 ?*Distance) 一个可行的代码 设数据的类型类似如下形式: data = Table[Table[RandomInteger[5], {i, 2}], {j, 3}] 44 40 41 计算正规化 (normalization) 数据的函数: normalData[data0_] := With[{ data = Transpose[data0] }, Transpose[(# / Sqrt[Total[#^2&amp; /@ #]]) &amp; /@ data]]; 如果需要安排权值 $w_i$, 那么考虑: weightAssignData[data_, weight_] := MapThread[#1 * #2&amp;, {#, weight}]&amp; /@ data; 计算正负理想解的函数: worstAlternative[data0_] := With[{ data = Transpose[data0] }, Min /@ data]; bestAlternative[data0_] := With[{ data = Transpose[data0] }, Max /@ data]; 最后使用距离函数, 并通过距离函数来评价: rankData[data_] := With[{ worst = worstAlternative[data], best = bestAlternative[data] }, SortBy[data, {EuclideanDistance[best, #]&amp;, EuclideanDistance[worst, #]&amp;}]]; EWM Entropy Weight Method | Hindawi 使用数据本身的统计分布来作为权值的判断因素. Entropy 用于计算数据的熵 一些代码及解释 参考 上面 的论文, 直接摘取部分摘要: Entropy weight method (EWM) is a commonly used weighting method that measures value dispersion in decision-making. The greater the degree of dispersion, the greater the degree of differentiation, and more information can be derived. 假设数据样本有如下的形式: data = Table[Table[RandomReal[5], {j, 2}], {i, 5}] 首先正规化采样值 standardData[data0_] := With[{ data = Transpose[data0] }, Transpose[# / Total[#]&amp; /@ data]]; 然后计算每组指标对应的熵值并根据熵值来计算权值: weightData[data_] := With[{ entropydata = Entropy /@ Transpose[data] }, With[{ sum = Total[(1 - #)&amp; /@ entropydata] }, ((1 - #) / sum)&amp; /@ entropydata]]; Note: 或者可以考虑 $E = - \frac{&sum;_j p_{ij} \mathrm{ln} p_{ij}}{\mathrm{ln} n}$. 于是打分函数就变成了一个 MapThread[#1 * #2&amp;, {standarddata, weightData[standarddata]}]. FCE FCE: Fuzzy Comprehensive Evaluation, 建立在模糊数学上. 可以参考的几个应用: Application of fuzzy comprehensive evaluation to evaluate the effect of water flooding development Comprehensive evaluation model for health grade of multi-component compound release materials based on fuzzy comprehensive evaluation with grey relational analysis The fuzzy comprehensive evaluation (FCE) and the principal component analysis (PCA) model simulation and its applications in water quality assessment of Nansi Fuzzy Comprehensive Evaluation Method of Masonry Structure Safety Based on Grey Clustering Theory PageRank PageRank | Wikipedia 用于衡量网络 (Graph) 中的节点的排序顺序. PageRankCentrality 佩奇算法 LinkRankCentrality 可以参考的论文: LinkRank: Finding communities in directed networks | arxiv Classify PCA PCA (Principal Component Analysis) | Wikipedia 主成分分析. PrincipalComponents 将一组数据集中汇聚到中心 一个例子 如果有一个数据的分布并不在中心, 而是分散在四周, 想要将其变换并集中在中心: data = With[{ dst1 = NormalDistribution[2, .75], dst2 = NormalDistribution[-1, 2] }, Table[{2 * a + b, a - 4 * b} /. { a -&gt; RandomVariate[dst1], b -&gt; RandomVariate[dst2] }, 10]]; 使用 ListPlot[PrincipalComponents[data]] 来输出集中的图片: Correlation Analysis Correlation | Wikipedia 可以用相关性来对数据进行分类. Correlation, CorrelationTest 用于检测数据的相关程度 Arrange Queuing Theory Queueing Theory | Wikipedia 用于安排服务和排队的问题. QueueingProcess QueueingNetworkProcess Others MonteCario How to | Perform a Monte Carlo Simulation RandomVariate 根据概率分布来随机生成 randomWalk[n_] := Accumulate[Prepend[RandomVariate[NormalDistribution[0, 1], n], 0]] 随机游走的代码. Automa Cellular Automation | Wikipedia 元胞自动机, 可以用于生物, 化学, 物理之类的模拟. CellularAutomataCartogram | WOLFRAM FUNCTION REPOSITORY AI Wolfram Machine Learning General Functions Machine Learning Methods Mathematica 中的一些内置的 AI 方法 Classify 根据样本来生成分类函数 FeatureExtract 尝试提取输入的样本的特征 Predict 根据样板来生成预测函数 FindClusters 根据样本寻找聚类 DimensionReduction 将样本的维度缩小 Regression with Uncertainty 回归. LearnDistribution 根据样本猜测分布 AnomalyDetection 用于查找不同的数据 SynthesizeMissingValues 用于填补 Missing[] 的数值 Decision Tree &amp; Random Forest DecisionTree Wolfram Machine Learning Method. Wolfram 内置的方法, 可以用于 Predict, Classify, LearnDistribution 函数. 类似于如下的一个决策树 比如说有这样的一个决策树: RandomForest Wolfram Machine Learning Method. Wolfram 内置的方法, 可以用于 Classify 和 Predict. Neural Networks Wolfram Neural Net Repository 官方的一个神经网络库, 可以在已经实现的神经网络的基础上进行修改来用于新的问题." />
<meta property="og:description" content="非常功利的数学建模准备 注: 本篇为 Mathematica and MultiParadigm Data Science 中和数学建模的一个整理. 主要是为了方便查找和使用对应的算法和程序. 思路是这样的: 因为准备时间有限, 所以尽可能地只使用尽可能少的工具. 所以会尽可能地在 Mathematica 中去找到所有的建模所需的程序和函数. Optimize Maximize &amp; Minmize Wolfram Optimization: LinearOptimization 适用于线性约束问题下的线性函数的最小值的查找. LinearOptimization[x + y, {x + 2 * y == 3, x &gt;= 0, y &gt;= 0}, {x, y}] 剩下的两个函数和其语法类似, 代码略. FindMinimum 适用于寻找邻域内的局部最小值, 寻找的方式有点像是贪心算法. Minimize 适用于寻找全局的最小值 (注: 该函数对于 非常多 的变量的效果并不是很好. 虽然我觉得我也没有可能遇到这种情况就是了&#8230;) 一个比较炫酷的例子 可以使用 StepMonitor 配合 Sow 和 Reap 来捕捉每一步具体的过程, 可以用于计算和绘制查找最小值的过程: With[{exp = (1 - x)^2 + 100*(-x^2 - y)^2 , xrange = {x, -1.5, 1.5}, yrange = {y, -1.5, 1.5}}, With[{res = Reap[NMinimize[exp, {x, y}, StepMonitor :&gt; Sow[{x, y}]]]}, With[{path = res[[2, 1]], minValue = res[[1, 1]]}, ContourPlot[exp, xrange, yrange, Epilog -&gt; {Arrow[path], Point[path]}, Contours -&gt; Table[10^-i, {i, -2, 10}], ColorFunction -&gt; (Hue[(Log[10, #] + 10)/12] &amp;), ColorFunctionScaling -&gt; False, ImageSize -&gt; Medium] ]]] 参考的是官方文档的 StepMonitor 的例子. 可能需要重新修改一下关于着色的函数. Graph Graphs &amp; Networks: Graph 构建图结构, 适用于存在 &#8220;节点-边&#8221; 的结构的问题. FindShortestPath 寻找两点之间最短路径. FindSpanningTree 寻找连接所有节点的最小生成树. Ant Conony Optimization 通过模拟蚁群和信息素的行为来尝试解决问题. Ant Colony Optimization (ACO) | WOLFRAM Demonstrations Project AntColonyOptimization | WOLFRAM FUNCTION REPOSITORY FindMaximumFlow 找到最大流. Other Optimise Dynamic Programming 不熟 Dynamic Programming | www.yaroslavvb.com Greedy Algorithm 不熟 Simulated Annealing 模拟退火, 在贪心算法基础上逐渐减少随机转移的概率. 或者直接调用函数 莽就完事了: NMinimize[f, vars, Method -&gt; &quot;SimulatedAnnealing&quot;] Predict Interpolation Interpolation | Wikipedia Interpolation 适用于根据数据来拟合一个函数, 可以用来拟合缺失的值. 不一定适合需要计算连续变化的问题, 适合函数值的一个结果. InterpolatingPolynomial 牛顿多项式插值法. FindFormula 用于根据数据来找一个函数形式, 可以通过 TargetFunctions 来指定用来猜的函数. Probability FindDistribution 根据数据来找出一个分布的概率函数. 可以用来判断函数的分布可能以及判断是否会有不同的数据分布. RandomVariate 根据概率分布来随机生成数据. AnomalyDetection 得到一个能够用来判断异常数据的一个判断函数, 其核心是根据概率分布的一个解决方式. Finite Markov Processes | Wolfram Doc 有限 Markov 链, 适用于仅和当前状态有关的变化问题. DiscreteMarkovProcess 可以根据转移矩阵来生成一个 Markov 转移分布. 可以通过 RandomFunction 来对这个结果进行模拟. Gray Model 可参考文档: The Grey Forecasting Model for the Medium-and Long-Term Load Forecasting | iop.org AutoRegression ARProcess 模拟 AR 过程 Autoregressive Model | Wikipedia 自动回归模型 Vector Autogression | Wikipedia 向量 AR 过程 ARMAProcess 自回归滑动平均模型 ARIMAProcess 模拟 ARIMA 过程 Autoregressive Inegrated Moving Average | Wikipedia Measure Ranking AHP 可参考的文档: Preference Weights from Pairwise Comparisons | WOLFRAM Demonstrations Project TOPSIS TOPSIS | Wikipedia 计算正负理想解以距离其距离正负理想解的距离来作为判断因素 Max, Min 用于计算正负理想解 EuclideanDistance 用于计算距离 (其他的距离函数可以考虑 ?*Distance) 一个可行的代码 设数据的类型类似如下形式: data = Table[Table[RandomInteger[5], {i, 2}], {j, 3}] 44 40 41 计算正规化 (normalization) 数据的函数: normalData[data0_] := With[{ data = Transpose[data0] }, Transpose[(# / Sqrt[Total[#^2&amp; /@ #]]) &amp; /@ data]]; 如果需要安排权值 $w_i$, 那么考虑: weightAssignData[data_, weight_] := MapThread[#1 * #2&amp;, {#, weight}]&amp; /@ data; 计算正负理想解的函数: worstAlternative[data0_] := With[{ data = Transpose[data0] }, Min /@ data]; bestAlternative[data0_] := With[{ data = Transpose[data0] }, Max /@ data]; 最后使用距离函数, 并通过距离函数来评价: rankData[data_] := With[{ worst = worstAlternative[data], best = bestAlternative[data] }, SortBy[data, {EuclideanDistance[best, #]&amp;, EuclideanDistance[worst, #]&amp;}]]; EWM Entropy Weight Method | Hindawi 使用数据本身的统计分布来作为权值的判断因素. Entropy 用于计算数据的熵 一些代码及解释 参考 上面 的论文, 直接摘取部分摘要: Entropy weight method (EWM) is a commonly used weighting method that measures value dispersion in decision-making. The greater the degree of dispersion, the greater the degree of differentiation, and more information can be derived. 假设数据样本有如下的形式: data = Table[Table[RandomReal[5], {j, 2}], {i, 5}] 首先正规化采样值 standardData[data0_] := With[{ data = Transpose[data0] }, Transpose[# / Total[#]&amp; /@ data]]; 然后计算每组指标对应的熵值并根据熵值来计算权值: weightData[data_] := With[{ entropydata = Entropy /@ Transpose[data] }, With[{ sum = Total[(1 - #)&amp; /@ entropydata] }, ((1 - #) / sum)&amp; /@ entropydata]]; Note: 或者可以考虑 $E = - \frac{&sum;_j p_{ij} \mathrm{ln} p_{ij}}{\mathrm{ln} n}$. 于是打分函数就变成了一个 MapThread[#1 * #2&amp;, {standarddata, weightData[standarddata]}]. FCE FCE: Fuzzy Comprehensive Evaluation, 建立在模糊数学上. 可以参考的几个应用: Application of fuzzy comprehensive evaluation to evaluate the effect of water flooding development Comprehensive evaluation model for health grade of multi-component compound release materials based on fuzzy comprehensive evaluation with grey relational analysis The fuzzy comprehensive evaluation (FCE) and the principal component analysis (PCA) model simulation and its applications in water quality assessment of Nansi Fuzzy Comprehensive Evaluation Method of Masonry Structure Safety Based on Grey Clustering Theory PageRank PageRank | Wikipedia 用于衡量网络 (Graph) 中的节点的排序顺序. PageRankCentrality 佩奇算法 LinkRankCentrality 可以参考的论文: LinkRank: Finding communities in directed networks | arxiv Classify PCA PCA (Principal Component Analysis) | Wikipedia 主成分分析. PrincipalComponents 将一组数据集中汇聚到中心 一个例子 如果有一个数据的分布并不在中心, 而是分散在四周, 想要将其变换并集中在中心: data = With[{ dst1 = NormalDistribution[2, .75], dst2 = NormalDistribution[-1, 2] }, Table[{2 * a + b, a - 4 * b} /. { a -&gt; RandomVariate[dst1], b -&gt; RandomVariate[dst2] }, 10]]; 使用 ListPlot[PrincipalComponents[data]] 来输出集中的图片: Correlation Analysis Correlation | Wikipedia 可以用相关性来对数据进行分类. Correlation, CorrelationTest 用于检测数据的相关程度 Arrange Queuing Theory Queueing Theory | Wikipedia 用于安排服务和排队的问题. QueueingProcess QueueingNetworkProcess Others MonteCario How to | Perform a Monte Carlo Simulation RandomVariate 根据概率分布来随机生成 randomWalk[n_] := Accumulate[Prepend[RandomVariate[NormalDistribution[0, 1], n], 0]] 随机游走的代码. Automa Cellular Automation | Wikipedia 元胞自动机, 可以用于生物, 化学, 物理之类的模拟. CellularAutomataCartogram | WOLFRAM FUNCTION REPOSITORY AI Wolfram Machine Learning General Functions Machine Learning Methods Mathematica 中的一些内置的 AI 方法 Classify 根据样本来生成分类函数 FeatureExtract 尝试提取输入的样本的特征 Predict 根据样板来生成预测函数 FindClusters 根据样本寻找聚类 DimensionReduction 将样本的维度缩小 Regression with Uncertainty 回归. LearnDistribution 根据样本猜测分布 AnomalyDetection 用于查找不同的数据 SynthesizeMissingValues 用于填补 Missing[] 的数值 Decision Tree &amp; Random Forest DecisionTree Wolfram Machine Learning Method. Wolfram 内置的方法, 可以用于 Predict, Classify, LearnDistribution 函数. 类似于如下的一个决策树 比如说有这样的一个决策树: RandomForest Wolfram Machine Learning Method. Wolfram 内置的方法, 可以用于 Classify 和 Predict. Neural Networks Wolfram Neural Net Repository 官方的一个神经网络库, 可以在已经实现的神经网络的基础上进行修改来用于新的问题." />
<link rel="canonical" href="/mathematica/mathematica-and-math-modeling/" />
<meta property="og:url" content="/mathematica/mathematica-and-math-modeling/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-02-16T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Mathematica and Math Modeling" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-16T00:00:00+00:00","datePublished":"2023-02-16T00:00:00+00:00","description":"非常功利的数学建模准备 注: 本篇为 Mathematica and MultiParadigm Data Science 中和数学建模的一个整理. 主要是为了方便查找和使用对应的算法和程序. 思路是这样的: 因为准备时间有限, 所以尽可能地只使用尽可能少的工具. 所以会尽可能地在 Mathematica 中去找到所有的建模所需的程序和函数. Optimize Maximize &amp; Minmize Wolfram Optimization: LinearOptimization 适用于线性约束问题下的线性函数的最小值的查找. LinearOptimization[x + y, {x + 2 * y == 3, x &gt;= 0, y &gt;= 0}, {x, y}] 剩下的两个函数和其语法类似, 代码略. FindMinimum 适用于寻找邻域内的局部最小值, 寻找的方式有点像是贪心算法. Minimize 适用于寻找全局的最小值 (注: 该函数对于 非常多 的变量的效果并不是很好. 虽然我觉得我也没有可能遇到这种情况就是了&#8230;) 一个比较炫酷的例子 可以使用 StepMonitor 配合 Sow 和 Reap 来捕捉每一步具体的过程, 可以用于计算和绘制查找最小值的过程: With[{exp = (1 - x)^2 + 100*(-x^2 - y)^2 , xrange = {x, -1.5, 1.5}, yrange = {y, -1.5, 1.5}}, With[{res = Reap[NMinimize[exp, {x, y}, StepMonitor :&gt; Sow[{x, y}]]]}, With[{path = res[[2, 1]], minValue = res[[1, 1]]}, ContourPlot[exp, xrange, yrange, Epilog -&gt; {Arrow[path], Point[path]}, Contours -&gt; Table[10^-i, {i, -2, 10}], ColorFunction -&gt; (Hue[(Log[10, #] + 10)/12] &amp;), ColorFunctionScaling -&gt; False, ImageSize -&gt; Medium] ]]] 参考的是官方文档的 StepMonitor 的例子. 可能需要重新修改一下关于着色的函数. Graph Graphs &amp; Networks: Graph 构建图结构, 适用于存在 &#8220;节点-边&#8221; 的结构的问题. FindShortestPath 寻找两点之间最短路径. FindSpanningTree 寻找连接所有节点的最小生成树. Ant Conony Optimization 通过模拟蚁群和信息素的行为来尝试解决问题. Ant Colony Optimization (ACO) | WOLFRAM Demonstrations Project AntColonyOptimization | WOLFRAM FUNCTION REPOSITORY FindMaximumFlow 找到最大流. Other Optimise Dynamic Programming 不熟 Dynamic Programming | www.yaroslavvb.com Greedy Algorithm 不熟 Simulated Annealing 模拟退火, 在贪心算法基础上逐渐减少随机转移的概率. 或者直接调用函数 莽就完事了: NMinimize[f, vars, Method -&gt; &quot;SimulatedAnnealing&quot;] Predict Interpolation Interpolation | Wikipedia Interpolation 适用于根据数据来拟合一个函数, 可以用来拟合缺失的值. 不一定适合需要计算连续变化的问题, 适合函数值的一个结果. InterpolatingPolynomial 牛顿多项式插值法. FindFormula 用于根据数据来找一个函数形式, 可以通过 TargetFunctions 来指定用来猜的函数. Probability FindDistribution 根据数据来找出一个分布的概率函数. 可以用来判断函数的分布可能以及判断是否会有不同的数据分布. RandomVariate 根据概率分布来随机生成数据. AnomalyDetection 得到一个能够用来判断异常数据的一个判断函数, 其核心是根据概率分布的一个解决方式. Finite Markov Processes | Wolfram Doc 有限 Markov 链, 适用于仅和当前状态有关的变化问题. DiscreteMarkovProcess 可以根据转移矩阵来生成一个 Markov 转移分布. 可以通过 RandomFunction 来对这个结果进行模拟. Gray Model 可参考文档: The Grey Forecasting Model for the Medium-and Long-Term Load Forecasting | iop.org AutoRegression ARProcess 模拟 AR 过程 Autoregressive Model | Wikipedia 自动回归模型 Vector Autogression | Wikipedia 向量 AR 过程 ARMAProcess 自回归滑动平均模型 ARIMAProcess 模拟 ARIMA 过程 Autoregressive Inegrated Moving Average | Wikipedia Measure Ranking AHP 可参考的文档: Preference Weights from Pairwise Comparisons | WOLFRAM Demonstrations Project TOPSIS TOPSIS | Wikipedia 计算正负理想解以距离其距离正负理想解的距离来作为判断因素 Max, Min 用于计算正负理想解 EuclideanDistance 用于计算距离 (其他的距离函数可以考虑 ?*Distance) 一个可行的代码 设数据的类型类似如下形式: data = Table[Table[RandomInteger[5], {i, 2}], {j, 3}] 44 40 41 计算正规化 (normalization) 数据的函数: normalData[data0_] := With[{ data = Transpose[data0] }, Transpose[(# / Sqrt[Total[#^2&amp; /@ #]]) &amp; /@ data]]; 如果需要安排权值 $w_i$, 那么考虑: weightAssignData[data_, weight_] := MapThread[#1 * #2&amp;, {#, weight}]&amp; /@ data; 计算正负理想解的函数: worstAlternative[data0_] := With[{ data = Transpose[data0] }, Min /@ data]; bestAlternative[data0_] := With[{ data = Transpose[data0] }, Max /@ data]; 最后使用距离函数, 并通过距离函数来评价: rankData[data_] := With[{ worst = worstAlternative[data], best = bestAlternative[data] }, SortBy[data, {EuclideanDistance[best, #]&amp;, EuclideanDistance[worst, #]&amp;}]]; EWM Entropy Weight Method | Hindawi 使用数据本身的统计分布来作为权值的判断因素. Entropy 用于计算数据的熵 一些代码及解释 参考 上面 的论文, 直接摘取部分摘要: Entropy weight method (EWM) is a commonly used weighting method that measures value dispersion in decision-making. The greater the degree of dispersion, the greater the degree of differentiation, and more information can be derived. 假设数据样本有如下的形式: data = Table[Table[RandomReal[5], {j, 2}], {i, 5}] 首先正规化采样值 standardData[data0_] := With[{ data = Transpose[data0] }, Transpose[# / Total[#]&amp; /@ data]]; 然后计算每组指标对应的熵值并根据熵值来计算权值: weightData[data_] := With[{ entropydata = Entropy /@ Transpose[data] }, With[{ sum = Total[(1 - #)&amp; /@ entropydata] }, ((1 - #) / sum)&amp; /@ entropydata]]; Note: 或者可以考虑 $E = - \\frac{&sum;_j p_{ij} \\mathrm{ln} p_{ij}}{\\mathrm{ln} n}$. 于是打分函数就变成了一个 MapThread[#1 * #2&amp;, {standarddata, weightData[standarddata]}]. FCE FCE: Fuzzy Comprehensive Evaluation, 建立在模糊数学上. 可以参考的几个应用: Application of fuzzy comprehensive evaluation to evaluate the effect of water flooding development Comprehensive evaluation model for health grade of multi-component compound release materials based on fuzzy comprehensive evaluation with grey relational analysis The fuzzy comprehensive evaluation (FCE) and the principal component analysis (PCA) model simulation and its applications in water quality assessment of Nansi Fuzzy Comprehensive Evaluation Method of Masonry Structure Safety Based on Grey Clustering Theory PageRank PageRank | Wikipedia 用于衡量网络 (Graph) 中的节点的排序顺序. PageRankCentrality 佩奇算法 LinkRankCentrality 可以参考的论文: LinkRank: Finding communities in directed networks | arxiv Classify PCA PCA (Principal Component Analysis) | Wikipedia 主成分分析. PrincipalComponents 将一组数据集中汇聚到中心 一个例子 如果有一个数据的分布并不在中心, 而是分散在四周, 想要将其变换并集中在中心: data = With[{ dst1 = NormalDistribution[2, .75], dst2 = NormalDistribution[-1, 2] }, Table[{2 * a + b, a - 4 * b} /. { a -&gt; RandomVariate[dst1], b -&gt; RandomVariate[dst2] }, 10]]; 使用 ListPlot[PrincipalComponents[data]] 来输出集中的图片: Correlation Analysis Correlation | Wikipedia 可以用相关性来对数据进行分类. Correlation, CorrelationTest 用于检测数据的相关程度 Arrange Queuing Theory Queueing Theory | Wikipedia 用于安排服务和排队的问题. QueueingProcess QueueingNetworkProcess Others MonteCario How to | Perform a Monte Carlo Simulation RandomVariate 根据概率分布来随机生成 randomWalk[n_] := Accumulate[Prepend[RandomVariate[NormalDistribution[0, 1], n], 0]] 随机游走的代码. Automa Cellular Automation | Wikipedia 元胞自动机, 可以用于生物, 化学, 物理之类的模拟. CellularAutomataCartogram | WOLFRAM FUNCTION REPOSITORY AI Wolfram Machine Learning General Functions Machine Learning Methods Mathematica 中的一些内置的 AI 方法 Classify 根据样本来生成分类函数 FeatureExtract 尝试提取输入的样本的特征 Predict 根据样板来生成预测函数 FindClusters 根据样本寻找聚类 DimensionReduction 将样本的维度缩小 Regression with Uncertainty 回归. LearnDistribution 根据样本猜测分布 AnomalyDetection 用于查找不同的数据 SynthesizeMissingValues 用于填补 Missing[] 的数值 Decision Tree &amp; Random Forest DecisionTree Wolfram Machine Learning Method. Wolfram 内置的方法, 可以用于 Predict, Classify, LearnDistribution 函数. 类似于如下的一个决策树 比如说有这样的一个决策树: RandomForest Wolfram Machine Learning Method. Wolfram 内置的方法, 可以用于 Classify 和 Predict. Neural Networks Wolfram Neural Net Repository 官方的一个神经网络库, 可以在已经实现的神经网络的基础上进行修改来用于新的问题.","headline":"Mathematica and Math Modeling","mainEntityOfPage":{"@type":"WebPage","@id":"/mathematica/mathematica-and-math-modeling/"},"url":"/mathematica/mathematica-and-math-modeling/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">

  <style type="text/css">
    img {
      margin-left: auto; 
      margin-right:auto; 
      display:block;
    }
  </style><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="My Blog" /><script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        // • rendering keys, e.g.:
        throwOnError : false
      });
  });
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.css" integrity="sha384-z91AFMXXGZasvxZz5DtKJse3pKoTPU0QcNFj/B4gDFRmq6Q2bi1StsT7SOcIzLEN" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.js" integrity="sha384-Af7YmksQNWRLMvro3U9F84xa0paoIu7Pu2niAIUmZoI09Q4aCsbha5dvaj1tHy6K" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Mathematica and Math Modeling</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-02-16T00:00:00+00:00" itemprop="datePublished">Feb 16, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1>非常功利的数学建模准备</h1>
<object data="/_img/MMA/modeling-method-graphics.svg" width="100%"></object>
<p>注: 本篇为 <a href="/mathematica/mathematica-and-multiparadigm-data-science/">Mathematica and MultiParadigm Data Science</a> 中和数学建模的一个整理.
  主要是为了方便查找和使用对应的算法和程序.</p>
<p>思路是这样的: 因为准备时间有限, 所以尽可能地只使用尽可能少的工具.
  所以会尽可能地在 Mathematica 中去找到所有的建模所需的程序和函数.</p>
<h1>Optimize</h1>
<h2>Maximize &amp; Minmize</h2>
<p><a href="https://www.wolfram.com/language/core-areas/optimization/">Wolfram Optimization</a>:</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/LinearOptimization.html">LinearOptimization</a> 适用于线性约束问题下的线性函数的最小值的查找.
<div class="highlight"><pre><span></span><span class="n">LinearOptimization</span><span class="p">[</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}]</span>
</pre></div>
    <p>剩下的两个函数和其语法类似, 代码略.</p>
  </li>
  <li><a href="https://reference.wolfram.com/language/ref/FindMinimum.html">FindMinimum</a> 适用于寻找邻域内的局部最小值, 寻找的方式有点像是贪心算法.</li>
  <li><a href="https://reference.wolfram.com/language/ref/Minimize.html">Minimize</a> 适用于寻找全局的最小值
    <p>(注: 该函数对于 <b>非常多</b> 的变量的效果并不是很好.
      <del>虽然我觉得我也没有可能遇到这种情况就是了&#8230;</del>)</p>
  </li>
</ul>
<details><summary>一个比较炫酷的例子</summary>
<p>可以使用 <a href="https://reference.wolfram.com/language/ref/StepMonitor.html">StepMonitor</a> 配合 <a href="https://reference.wolfram.com/language/ref/Sow.html">Sow</a> 和 <a href="https://reference.wolfram.com/language/ref/Reap.html">Reap</a> 来捕捉每一步具体的过程,
  可以用于计算和绘制查找最小值的过程:</p>
<div class="highlight"><pre><span></span><span class="n">With</span><span class="p">[{</span><span class="n">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="p">,</span>
<span class="w">  </span><span class="n">xrange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">},</span><span class="w"> </span><span class="n">yrange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">}},</span>
<span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Reap</span><span class="p">[</span><span class="n">NMinimize</span><span class="p">[</span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">},</span><span class="w"> </span><span class="n">StepMonitor</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">Sow</span><span class="p">[{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">}]]]},</span>
<span class="w">  </span><span class="n">With</span><span class="p">[{</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]],</span><span class="w"> </span><span class="n">minValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]]},</span>
<span class="w">   </span><span class="n">ContourPlot</span><span class="p">[</span><span class="n">exp</span><span class="p">,</span><span class="w"> </span><span class="n">xrange</span><span class="p">,</span><span class="w"> </span><span class="n">yrange</span><span class="p">,</span>
<span class="w">    </span><span class="n">Epilog</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">Arrow</span><span class="p">[</span><span class="n">path</span><span class="p">],</span><span class="w"> </span><span class="n">Point</span><span class="p">[</span><span class="n">path</span><span class="p">]},</span>
<span class="w">    </span><span class="n">Contours</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Table</span><span class="p">[</span><span class="mi">10</span><span class="o">^-</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">-2</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">}],</span>
<span class="w">    </span><span class="n">ColorFunction</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">Hue</span><span class="p">[(</span><span class="n">Log</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="nv">#</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="p">),</span>
<span class="w">    </span><span class="n">ColorFunctionScaling</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">False</span><span class="p">,</span>
<span class="w">    </span><span class="n">ImageSize</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Medium</span><span class="p">]</span>
<span class="w">   </span><span class="p">]]]</span>
</pre></div>
<p>参考的是官方文档的 <a href="https://reference.wolfram.com/language/ref/NMinimize?view=all#151017442">StepMonitor</a> 的例子.
  可能需要重新修改一下关于着色的函数.</p>
</details>
<h2>Graph</h2>
<p><a href="https://reference.wolfram.com/language/guide/GraphsAndNetworks.html">Graphs &amp; Networks</a>:</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/Graph.html">Graph</a> 构建图结构, 适用于存在 &#8220;节点-边&#8221; 的结构的问题.</li>
  <li><a href="https://reference.wolfram.com/language/ref/FindShortestPath.html">FindShortestPath</a> 寻找两点之间最短路径.</li>
  <li><a href="https://reference.wolfram.com/language/ref/FindSpanningTree.html">FindSpanningTree</a> 寻找连接所有节点的最小生成树.</li>
  <li>Ant Conony Optimization 通过模拟蚁群和信息素的行为来尝试解决问题.
    <ul>
      <li><a href="https://demonstrations.wolfram.com/AntColonyOptimizationACO/">Ant Colony Optimization (ACO) | WOLFRAM Demonstrations Project</a></li>
      <li><a href="https://resources.wolframcloud.com/FunctionRepository/resources/AntColonyOptimization">AntColonyOptimization | WOLFRAM FUNCTION REPOSITORY</a></li>
    </ul>
  </li>
  <li><a href="https://reference.wolfram.com/language/ref/FindMaximumFlow.html">FindMaximumFlow</a> 找到最大流.</li>
</ul>
<h2>Other Optimise</h2>
<ul>
  <li>Dynamic Programming <del>不熟</del>
    <ul>
      <li><a href="http://www.yaroslavvb.com/papers/wagner-dynamic.pdf">Dynamic Programming | www.yaroslavvb.com</a></li>
    </ul>
  </li>
  <li>Greedy Algorithm <del>不熟</del></li>
  <li><a href="https://mathworld.wolfram.com/SimulatedAnnealing.html">Simulated Annealing</a> 模拟退火, 在贪心算法基础上逐渐减少随机转移的概率.
    <p>或者直接调用函数 <del>莽就完事了</del>:</p>
<div class="highlight"><pre><span></span><span class="n">NMinimize</span><span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="n">Method</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;SimulatedAnnealing&quot;</span><span class="p">]</span>
</pre></div>
  </li>
</ul>
<h1>Predict</h1>
<h2>Interpolation</h2>
<p><a href="https://en.wikipedia.org/wiki/Interpolation">Interpolation | Wikipedia</a></p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/Interpolation.html">Interpolation</a> 适用于根据数据来拟合一个函数, 可以用来拟合缺失的值.
    不一定适合需要计算连续变化的问题, 适合函数值的一个结果.</li>
  <li><a href="https://reference.wolfram.com/language/ref/InterpolatingPolynomial.html">InterpolatingPolynomial</a> 牛顿多项式插值法.</li>
  <li><a href="https://reference.wolfram.com/language/ref/FindFormula.html">FindFormula</a> 用于根据数据来找一个函数形式,
    可以通过 <code>TargetFunctions</code> 来指定用来猜的函数.</li>
</ul>
<h2>Probability</h2>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/FindDistribution.html">FindDistribution</a> 根据数据来找出一个分布的概率函数.
    可以用来判断函数的分布可能以及判断是否会有不同的数据分布.
    <ul>
      <li><a href="https://reference.wolfram.com/language/ref/RandomVariate.html">RandomVariate</a> 根据概率分布来随机生成数据.</li>
      <li><a href="https://reference.wolfram.com/language/ref/AnomalyDetection.html">AnomalyDetection</a> 得到一个能够用来判断异常数据的一个判断函数,
        其核心是根据概率分布的一个解决方式.</li>
    </ul>
  </li>
  <li><a href="https://reference.wolfram.com/language/guide/MarkovProcesses.html">Finite Markov Processes | Wolfram Doc</a> 有限 Markov 链,
    适用于仅和当前状态有关的变化问题.
    <ul>
      <li><a href="https://reference.wolfram.com/language/ref/DiscreteMarkovProcess.html">DiscreteMarkovProcess</a> 可以根据转移矩阵来生成一个 Markov 转移分布.
        可以通过 <a href="https://reference.wolfram.com/language/ref/RandomFunction.html">RandomFunction</a> 来对这个结果进行模拟.</li>
    </ul>
  </li>
</ul>
<h2>Gray Model</h2>
<p>可参考文档:</p>
<ul>
  <li><a href="https://iopscience.iop.org/article/10.1088/1742-6596/1654/1/012104/pdf">The Grey Forecasting Model for the Medium-and Long-Term Load Forecasting | iop.org</a></li>
</ul>
<h2>AutoRegression</h2>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/ARProcess.html">ARProcess</a> 模拟 AR 过程 <a href="https://en.wikipedia.org/wiki/Autoregressive_model">Autoregressive Model | Wikipedia</a> 自动回归模型</li>
  <li><a href="https://en.wikipedia.org/wiki/Vector_autoregression">Vector Autogression | Wikipedia</a> 向量 AR 过程</li>
  <li><a href="https://reference.wolfram.com/language/ref/ARMAProcess.html">ARMAProcess</a> 自回归滑动平均模型</li>
  <li><a href="https://reference.wolfram.com/language/ref/ARIMAProcess.html">ARIMAProcess</a> 模拟 ARIMA 过程 <a href="https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average">Autoregressive Inegrated Moving Average | Wikipedia</a></li>
</ul>
<h1>Measure</h1>
<h2>Ranking</h2>
<h3>AHP</h3>
<p>可参考的文档:</p>
<ul>
  <li><a href="https://demonstrations.wolfram.com/PreferenceWeightsFromPairwiseComparisons/">Preference Weights from Pairwise Comparisons | WOLFRAM Demonstrations Project</a></li>
</ul>
<h3>TOPSIS</h3>
<p><a href="https://en.wikipedia.org/wiki/TOPSIS">TOPSIS | Wikipedia</a> 计算正负理想解以距离其距离正负理想解的距离来作为判断因素</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/Max.html">Max</a>, <a href="https://reference.wolfram.com/language/ref/Min.html">Min</a> 用于计算正负理想解</li>
  <li><a href="https://reference.wolfram.com/language/ref/EuclideanDistance.html">EuclideanDistance</a> 用于计算距离 (其他的距离函数可以考虑 <code>?*Distance</code>)</li>
</ul>
<details><summary>一个可行的代码</summary>
<p>设数据的类型类似如下形式:</p>
<div class="highlight"><pre><span></span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Table</span><span class="p">[</span><span class="n">Table</span><span class="p">[</span><span class="n">RandomInteger</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}],</span><span class="w"> </span><span class="p">{</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}]</span>
</pre></div>
<table>
  <tr><td>4</td><td>4</td></tr>
  <tr><td>4</td><td>0</td></tr>
  <tr><td>4</td><td>1</td></tr>
</table>
<ul>
  <li>计算正规化 (normalization) 数据的函数:
<div class="highlight"><pre><span></span><span class="n">normalData</span><span class="p">[</span><span class="nv">data0_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Transpose</span><span class="p">[</span><span class="n">data0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="n">Transpose</span><span class="p">[(</span><span class="nv">#</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Sqrt</span><span class="p">[</span><span class="n">Total</span><span class="p">[</span><span class="nv">#</span><span class="o">^</span><span class="mi">2</span><span class="o">&amp;</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="nv">#</span><span class="p">]])</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">data</span><span class="p">]];</span>
</pre></div>
  </li>
  <li>如果需要安排权值 $w_i$, 那么考虑:
<div class="highlight"><pre><span></span><span class="n">weightAssignData</span><span class="p">[</span><span class="nv">data_</span><span class="p">,</span><span class="w"> </span><span class="nv">weight_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">MapThread</span><span class="p">[</span><span class="nv">#1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">#2</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">#</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="p">}]</span><span class="o">&amp;</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
</pre></div>
  </li>
  <li>计算正负理想解的函数:
<div class="highlight"><pre><span></span><span class="n">worstAlternative</span><span class="p">[</span><span class="nv">data0_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Transpose</span><span class="p">[</span><span class="n">data0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">Min</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">data</span><span class="p">];</span>
<span class="n">bestAlternative</span><span class="p">[</span><span class="nv">data0_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Transpose</span><span class="p">[</span><span class="n">data0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">Max</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">data</span><span class="p">];</span>
</pre></div>
  </li>
  <li>最后使用距离函数, 并通过距离函数来评价:
<div class="highlight"><pre><span></span><span class="n">rankData</span><span class="p">[</span><span class="nv">data_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">worst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worstAlternative</span><span class="p">[</span><span class="n">data</span><span class="p">],</span><span class="w"> </span><span class="n">best</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bestAlternative</span><span class="p">[</span><span class="n">data</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="n">SortBy</span><span class="p">[</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">EuclideanDistance</span><span class="p">[</span><span class="n">best</span><span class="p">,</span><span class="w"> </span><span class="nv">#</span><span class="p">]</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">EuclideanDistance</span><span class="p">[</span><span class="n">worst</span><span class="p">,</span><span class="w"> </span><span class="nv">#</span><span class="p">]</span><span class="o">&amp;</span><span class="p">}]];</span>
</pre></div>
  </li>
</ul>
</details>
<h3>EWM</h3>
<p><a href="https://www.hindawi.com/journals/mpe/2020/3564835/">Entropy Weight Method | Hindawi</a> 使用数据本身的统计分布来作为权值的判断因素.</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/Entropy.html">Entropy</a> 用于计算数据的熵</li>
</ul>
<details><summary>一些代码及解释</summary>
<p>参考 <a href="https://www.hindawi.com/journals/mpe/2020/3564835/">上面</a> 的论文, 直接摘取部分摘要:</p>
<blockquote>
  <p>Entropy weight method (EWM) is a commonly used weighting method
    that measures value dispersion in decision-making. The greater
    the degree of dispersion, the greater the degree of differentiation,
    and more information can be derived.</p>
</blockquote>
<p>假设数据样本有如下的形式:</p>
<div class="highlight"><pre><span></span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Table</span><span class="p">[</span><span class="n">Table</span><span class="p">[</span><span class="n">RandomReal</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="p">{</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">}],</span><span class="w"> </span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}]</span>
</pre></div>
<ul>
  <li>首先正规化采样值
<div class="highlight"><pre><span></span><span class="n">standardData</span><span class="p">[</span><span class="nv">data0_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Transpose</span><span class="p">[</span><span class="n">data0</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="n">Transpose</span><span class="p">[</span><span class="nv">#</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Total</span><span class="p">[</span><span class="nv">#</span><span class="p">]</span><span class="o">&amp;</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">data</span><span class="p">]];</span>
</pre></div>
  </li>
  <li>然后计算每组指标对应的熵值并根据熵值来计算权值:
<div class="highlight"><pre><span></span><span class="n">weightData</span><span class="p">[</span><span class="nv">data_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">entropydata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Entropy</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">Transpose</span><span class="p">[</span><span class="n">data</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Total</span><span class="p">[(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">#</span><span class="p">)</span><span class="o">&amp;</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">entropydata</span><span class="p">]</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="p">((</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">#</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sum</span><span class="p">)</span><span class="o">&amp;</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">entropydata</span><span class="p">]];</span>
</pre></div>
    <p>Note: 或者可以考虑 $E = - \frac{&sum;_j p_{ij} \mathrm{ln} p_{ij}}{\mathrm{ln} n}$.</p>
  </li>
  <li>于是打分函数就变成了一个 <code>MapThread[#1 * #2&amp;, {standarddata, weightData[standarddata]}]</code>.</li>
</ul>
</details>
<h3>FCE</h3>
<p>FCE: Fuzzy Comprehensive Evaluation, 建立在模糊数学上.</p>
<p>可以参考的几个应用:</p>
<ul>
  <li><a href="https://link.springer.com/article/10.1007/s13202-018-0430-y#:~:text=Fuzzy%20comprehensive%20evaluation%20(FCE)%20is,water%20flooding%20effect%20of%20oilfield.">Application of fuzzy comprehensive evaluation to evaluate the effect of water flooding development</a></li>
  <li><a href="https://www.nature.com/articles/s41598-022-23887-2">Comprehensive evaluation model for health grade of multi-component compound release materials based on fuzzy comprehensive evaluation with grey relational analysis</a></li>
  <li><a href="https://www.eeer.org/journal/view.php?number=1165">The fuzzy comprehensive evaluation (FCE) and the principal component analysis (PCA) model simulation and its applications in water quality assessment of Nansi</a></li>
  <li><a href="https://www.hindawi.com/journals/mpe/2018/8710192/">Fuzzy Comprehensive Evaluation Method of Masonry Structure Safety Based on Grey Clustering Theory</a></li>
</ul>
<h3>PageRank</h3>
<p><a href="https://en.wikipedia.org/wiki/PageRank">PageRank | Wikipedia</a> 用于衡量网络 (Graph) 中的节点的排序顺序.</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/PageRankCentrality.html">PageRankCentrality</a> <del>佩奇算法</del></li>
  <li><a href="https://reference.wolfram.com/language/ref/LinkRankCentrality.html">LinkRankCentrality</a>
    <p>可以参考的论文: <a href="https://arxiv.org/abs/0902.3728">LinkRank: Finding communities in directed networks | arxiv</a></p>
  </li>
</ul>
<h2>Classify</h2>
<h3>PCA</h3>
<p><a href="https://en.wikipedia.org/wiki/Principal_component_analysis">PCA (Principal Component Analysis) | Wikipedia</a> 主成分分析.</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/PrincipalComponents.html">PrincipalComponents</a> 将一组数据集中汇聚到中心
  <details><summary>一个例子</summary>
    <p>如果有一个数据的分布并不在中心, 而是分散在四周,
      想要将其变换并集中在中心:</p>
<div class="highlight"><pre><span></span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="w"> </span><span class="n">dst1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NormalDistribution</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">.75</span><span class="p">],</span><span class="w"> </span><span class="n">dst2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NormalDistribution</span><span class="p">[</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="n">Table</span><span class="p">[{</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">}</span><span class="w"> </span><span class="o">/.</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">RandomVariate</span><span class="p">[</span><span class="n">dst1</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">RandomVariate</span><span class="p">[</span><span class="n">dst2</span><span class="p">]</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">10</span><span class="p">]];</span>
</pre></div>
    <p>使用 <code>ListPlot[PrincipalComponents[data]]</code> 来输出集中的图片:</p>
    <p><img src="/_img/MMA/pca-example.svg" alt="/_img/MMA/pca-example.svg" /></p>
  </details>
  </li>
</ul>
<h3>Correlation Analysis</h3>
<p><a href="https://en.wikipedia.org/wiki/Correlation">Correlation | Wikipedia</a> 可以用相关性来对数据进行分类.</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/Correlation.html">Correlation</a>, <a href="https://reference.wolfram.com/language/ref/CorrelationTest.html">CorrelationTest</a> 用于检测数据的相关程度</li>
</ul>
<h1>Arrange</h1>
<h2>Queuing Theory</h2>
<p><a href="https://en.wikipedia.org/wiki/Queueing_theory">Queueing Theory | Wikipedia</a> 用于安排服务和排队的问题.</p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/QueueingProcess.html">QueueingProcess</a></li>
  <li><a href="https://reference.wolfram.com/language/ref/QueueingNetworkProcess.html">QueueingNetworkProcess</a></li>
</ul>
<h1>Others</h1>
<h2>MonteCario</h2>
<p><a href="https://reference.wolfram.com/language/howto/PerformAMonteCarloSimulation.html">How to | Perform a Monte Carlo Simulation</a></p>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/RandomVariate.html">RandomVariate</a> 根据概率分布来随机生成</li>
  <li><code>randomWalk[n_] := Accumulate[Prepend[RandomVariate[NormalDistribution[0, 1], n], 0]]</code>
    随机游走的代码.</li>
</ul>
<h2>Automa</h2>
<p><a href="https://en.wikipedia.org/wiki/Cellular_automaton">Cellular Automation | Wikipedia</a> 元胞自动机, 可以用于生物, 化学, 物理之类的模拟.</p>
<ul>
  <li><a href="https://resources.wolframcloud.com/FunctionRepository/resources/CellularAutomataCartogram">CellularAutomataCartogram | WOLFRAM FUNCTION REPOSITORY</a></li>
</ul>
<h2>AI</h2>
<p><a href="https://www.wolfram.com/language/core-areas/machine-learning/">Wolfram Machine Learning</a></p>
<h3>General Functions</h3>
<ul>
  <li><a href="https://reference.wolfram.com/language/guide/MachineLearningMethods.html">Machine Learning Methods</a> Mathematica 中的一些内置的 AI 方法</li>
  <li><a href="https://reference.wolfram.com/language/ref/Classify.html">Classify</a> 根据样本来生成分类函数</li>
  <li><a href="https://reference.wolfram.com/language/ref/FeatureExtract.html">FeatureExtract</a> 尝试提取输入的样本的特征</li>
  <li><a href="https://reference.wolfram.com/language/ref/Predict.html">Predict</a> 根据样板来生成预测函数</li>
  <li><a href="https://reference.wolfram.com/language/ref/FindClusters.html">FindClusters</a> 根据样本寻找聚类</li>
  <li><a href="https://reference.wolfram.com/language/ref/DimensionReduction.html">DimensionReduction</a> 将样本的维度缩小</li>
  <li><a href="https://reference.wolfram.com/language/tutorial/NeuralNetworksRegressionWithUncertainty.html">Regression with Uncertainty</a> 回归.</li>
  <li><a href="https://reference.wolfram.com/language/ref/LearnDistribution.html">LearnDistribution</a> 根据样本猜测分布</li>
  <li><a href="https://reference.wolfram.com/language/ref/AnomalyDetection.html">AnomalyDetection</a> 用于查找不同的数据</li>
  <li><a href="https://reference.wolfram.com/language/ref/SynthesizeMissingValues.html">SynthesizeMissingValues</a> 用于填补 <code>Missing[]</code> 的数值</li>
</ul>
<h3>Decision Tree &amp; Random Forest</h3>
<ul>
  <li><a href="https://reference.wolfram.com/language/ref/method/DecisionTree.html">DecisionTree</a> Wolfram Machine Learning Method. Wolfram 内置的方法,
    可以用于 <code>Predict</code>, <code>Classify</code>, <code>LearnDistribution</code> 函数.
  <details><summary>类似于如下的一个决策树</summary>
    <p>比如说有这样的一个决策树:</p>
  <object data="/_img/MMA/decision-tree-example.svg" width="100%"></object>
  </details>
  </li>
  <li><a href="https://reference.wolfram.com/language/ref/method/RandomForest.html">RandomForest</a> Wolfram Machine Learning Method. Wolfram 内置的方法,
    可以用于 <code>Classify</code> 和 <code>Predict</code>.</li>
</ul>
<h3>Neural Networks</h3>
<p><a href="https://resources.wolframcloud.com/NeuralNetRepository/all/">Wolfram Neural Net Repository</a> 官方的一个神经网络库,
  可以在已经实现的神经网络的基础上进行修改来用于新的问题.</p>

  </div><a class="u-url" href="/mathematica/mathematica-and-math-modeling/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
