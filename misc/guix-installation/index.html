<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Guix Installation | My Blog</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Guix Installation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="About 尽管我是挺反感那种安装电脑系统的教程的, 现在的电脑系统不都做成了傻瓜机了么? 还有啥好看安装教程的&#8230; 但是现在要接触 Linux 的电脑, 想要多学一些稍微底层一些的知识, 所以留一个小笔记. 目前先在自己的电脑上用虚拟机试试, 至少跑通先吧. 参考的教程见 Mannual Installation (Guix). (先叠个甲: 我没学过啥操作系统, 这些词或者概念完全不了解, 这安装完全就是图一乐) Load the Installation Image 插入安装镜像启动后选择从 shell 开始安装: Ctrl-Alt-F3 可以为你打开 TTY3. 顺带一提, Ctrl-Alt-F4, Ctrl-Alt-F5 对应 TTY4, TTY5. 但是 Ctrl-Alt-F2 对应帮助文档. TTY 的历史 很多时候感觉学习的一些东西就只是知识, 或者说知道即可的水平. 但是知道这些东西为啥来, 虽然看起来没啥鸟用, 但是至少会让我有一种安心的感觉. 虽然我也不能保证这玩意能是啥正确的历史就是了. 我觉得有一个写得还算比较通俗易懂的博客: 扫盲 Linux &amp; UNIX 命令行 &#8211; 从 “电传打字机” 聊到 “shell 脚本编程”. (叠甲: 俺只管里面的技术历史部分, 其他的不做评价). 对于懒得看, 也不想看的同学, 可以看看下面我的一些简单介绍: TTY, 全称为 Teletype Printer, 也就是电传打印机, 实际上是和物理的硬件对应的一个概念: 这玩意大概类似于一个带了根数据线 (UART) 的打字机. 终端缓冲模式: 字符模式, 行模式, 屏模式 在我写过单片机后, 我对几个的概念倒是可以比较好理解了, 比如说字符模式可以对应于一个数据被按下后立刻发送给单片机, 行模式类似于编辑一行后再发送. emmm&#8230; 感觉用 readline 来类比可能会更加好. 回显: 例子就是在输入密码的时候的不显示 (回显关闭), 来自于暂停发送和恢复发送. 控制台: 从早期的物理控制台, 到现在的虚拟控制台 (vitrual console). 因为虚拟控制台是为了模拟物理控制台, 所以是一种 terminal emulator (终端模拟器). 伪终端: PTY (pseudotty), 通过图形界面的软件来模拟文本终端 shell 和 terminal: terminal 类似于一个和机器进行输入输出的信息交流通道, 而 shell 类似于一个机器根据得到的信息进行命令解释和执行的东西. 进程 进程树: 父进程为根, 子进程为叶子 进程的死法: 自然死亡, 自杀 (信号, 中断, Ctrl-C 中断信号是终端发的), 他杀 (信号) 孤儿进程: 父进程死亡, 子进程被初始进程领养 (直接调整到进程树根节点下级) 进程的杀死: kill, killall 比如: kill -9 pid 信号名称编号能否屏蔽默认动作 SIGINT2YES进程自己退出 SIGTERM15YES进程自己退出 SIGQUIT3YES执行 core dump, 自己退出 SIGKILL9NO进程被内核干掉 进程的 遗言 退出码: 0 或者非 0 进程的暂停: TSTP 温柔暂停, STOP 强制暂停, CONT 恢复进程. 比如 kill -STOP pid. job 的前台, 后台, 前后台切换: fg 命令后台到前台 (栈顺序), jobs 列出作业. cmd &amp; 挂起到后台. 环境变量: 一种简单的进程通讯机制 标准流: stdin, stdout, stderr 重定向: &lt; stdin, &gt; stdout 但是覆写, &gt;&gt; stdout, 但是增添 anonymous pipe: |, 通过管道符链接的是同属于一个 job 批处理: ; then, &amp;&amp; and, || or Keyboard Layout, Networking, and Partitioning 和外设相关的东西&#8230; 键盘布局 默认是 qwerty 布局, 结束. loadkeys --default 网络 (我一直觉得网络这部分非常神奇和难懂) 这里有两个命令 ifconfig 和 ip, 后者类似于是前者的更加新的一个替代, 本着死要一起作的精神, 我决定两个都了解一点点: (Cheat Sheet) 列出本台电脑上有的一些网络设备: ipconfig -a (ip a) 列出的东西大概如下: enpOs1 Link encap:Ethernet Hwaddr XX:XX:XX:XX:XX:XX inet addr: XX.XX.XX.XX Bcast: XX.XX.XX.XX Mask:XX.XX.XX.XX UP BROADCAST RUNNING MULTICAST DYNAMIC MTU: 1500 Metric:1 ... 解释一下: 名字 enp0s1 里面的 en 表示 Ethernet (以太网), p0 表示 bus number, s1 表示 slot number. (参考) 更加详细的说明 &lt;interface&gt; ::= &lt;type&gt; &lt;name&gt; &lt;type&gt; ::= en ;; Ethernet | sl ;; serial line IP (slip) | wl ;; wlan | ww ;; wwan &lt;name&gt; ::= b&lt;number&gt; ;; BCMA bus core bumber | c&lt;bus_id&gt; ;; CCW bus group name, without leading zeros | o&lt;index&gt;[d&lt;dev_port&gt;] ;; on-board device index number | s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;] ;; hotplug slot index number | x&lt;MAC&gt; ;; MAC address | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;] ;; PCI geographical location | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;] ;; USB port number chain macOS 上的小小区别在 mac 上运行 ipconfig -a 会得到一堆的东西, 可以参考 这里 (日语). 下面是一个简单的翻译 (部分): Internet Interface说明 lo0loopback interface, localhost en0以前是以太网 (Ethernet), 现在是 Wifi en1, en2Thunderbolt fw0FireWire &#8230;&#8230; 设置网络连接 有线网络连接: ifconfig enp0s1 up (ip link set enp0s1 up) 实际上做的事情是使某一个设备可工作 (up), 换成 down 就关闭工作. 无线网络连接: wpa_supplicant -c &lt;config.conf&gt; -i &lt;interface&gt; -B 其中 config.conf 文件中包含网络信息 network={ ssid=&quot;my-ssid&quot; key_mgmt=WPA-PSK psk=&quot;the network&#39;s secret passphrase&quot; } 获取 IP 地址: dhclient -v &lt;interface&gt; 确认连接到了互联网: ping -c 3 gnu.org Proxy (呵) herd set-http-proxy guix-daemon URL SSH herd start ssh-daemon 先设置一个 passwd 方便连接进去, 再使用 IP 连接到电脑上 磁盘分区 Linux 的分区和 Windows 还有 mac 的感觉稍微有点不太一样, 分区的作用更多是用于映射. (可以参考: Linux磁盘分区、挂载度 (github 笔记), 推荐的分区方案 (redhat), Linux 硬盘分区指南 (zhihu)) 首先是 Linux 的文件结构, 类似于一个树状的结构: / ;; root /home ;; user files /boot ;; boot loader files ;; ... 对于每个目录, 可以选择映射到一个磁盘分区上. 或者说, 把磁盘分区挂载到对应的目录上面. 使用 cdfdisk 可以比较轻松地分区, 总之磁盘 label type 选 GPT, 然后就分区就好了吧. 每一步操作完使用 Write 写入自己的操作. 一般应该是推荐给 boot 分一个区 (300MB 左右, 分区的时候改成 UEFI 类型), 然后给 root 分一个区吧. 对分完区的磁盘使用 lsblk 可以查看分区和挂载情况, 使用 mkfs.ext4 -L root /dev/sda2 可以进行文件系统初始化. (这里用的是 ext4 类型的文件系统) 分好了区之后就可以把它们挂载到对应目录下去了: mount LABEL=root /mnt. 那么为什么不直接挂载到对应的分区上面呢? 我认为是现在是安装镜像挂载在对应的目录上. Guix Configuration 那么让我来介绍一下最让我对 Guix 系统感到非常满意的一个地方吧: 那就是 Guix 是一个支持系统级的配置文件的一个东西. 就比如说 Emacs, Vim 这些软件的配置, 都只是一个软件上的配置; 像 homebrew 这样的包管理器, 也不是很方便导出. 移植到其他的配置文件里面去. 懒得配置的可以直接使用 /etc/configuration/ 下面的配置文件. herd start cow-store /mnt: 保证接下来的操作是写入 /mnt 而不是写在内存中 (这一步不是很理解具体对应的操作, 总之现在不是很懂, 做了再说) 编辑配置文件到 /mnt/etc/config.scm 里面 只要一句话, 让 Guix 为我在挂载在 /mnt 上的磁盘里面初始化一个系统: guix system init /mnt/etc/config.scm /mnt 让 Guix 用 /mnt/etc/config.scm 的配置文件在 /mnt 下初始化一个系统. (注: 受限于网络问题, 可能得重试几次, 我再找找看国内镜像解决方案.) 然后 reboot 重启或者 shutdown 跑路, 大概应该就可以了. After Installation System Update guix pull sudo guix system reconfigure /etc/config.scm 先这么多" />
<meta property="og:description" content="About 尽管我是挺反感那种安装电脑系统的教程的, 现在的电脑系统不都做成了傻瓜机了么? 还有啥好看安装教程的&#8230; 但是现在要接触 Linux 的电脑, 想要多学一些稍微底层一些的知识, 所以留一个小笔记. 目前先在自己的电脑上用虚拟机试试, 至少跑通先吧. 参考的教程见 Mannual Installation (Guix). (先叠个甲: 我没学过啥操作系统, 这些词或者概念完全不了解, 这安装完全就是图一乐) Load the Installation Image 插入安装镜像启动后选择从 shell 开始安装: Ctrl-Alt-F3 可以为你打开 TTY3. 顺带一提, Ctrl-Alt-F4, Ctrl-Alt-F5 对应 TTY4, TTY5. 但是 Ctrl-Alt-F2 对应帮助文档. TTY 的历史 很多时候感觉学习的一些东西就只是知识, 或者说知道即可的水平. 但是知道这些东西为啥来, 虽然看起来没啥鸟用, 但是至少会让我有一种安心的感觉. 虽然我也不能保证这玩意能是啥正确的历史就是了. 我觉得有一个写得还算比较通俗易懂的博客: 扫盲 Linux &amp; UNIX 命令行 &#8211; 从 “电传打字机” 聊到 “shell 脚本编程”. (叠甲: 俺只管里面的技术历史部分, 其他的不做评价). 对于懒得看, 也不想看的同学, 可以看看下面我的一些简单介绍: TTY, 全称为 Teletype Printer, 也就是电传打印机, 实际上是和物理的硬件对应的一个概念: 这玩意大概类似于一个带了根数据线 (UART) 的打字机. 终端缓冲模式: 字符模式, 行模式, 屏模式 在我写过单片机后, 我对几个的概念倒是可以比较好理解了, 比如说字符模式可以对应于一个数据被按下后立刻发送给单片机, 行模式类似于编辑一行后再发送. emmm&#8230; 感觉用 readline 来类比可能会更加好. 回显: 例子就是在输入密码的时候的不显示 (回显关闭), 来自于暂停发送和恢复发送. 控制台: 从早期的物理控制台, 到现在的虚拟控制台 (vitrual console). 因为虚拟控制台是为了模拟物理控制台, 所以是一种 terminal emulator (终端模拟器). 伪终端: PTY (pseudotty), 通过图形界面的软件来模拟文本终端 shell 和 terminal: terminal 类似于一个和机器进行输入输出的信息交流通道, 而 shell 类似于一个机器根据得到的信息进行命令解释和执行的东西. 进程 进程树: 父进程为根, 子进程为叶子 进程的死法: 自然死亡, 自杀 (信号, 中断, Ctrl-C 中断信号是终端发的), 他杀 (信号) 孤儿进程: 父进程死亡, 子进程被初始进程领养 (直接调整到进程树根节点下级) 进程的杀死: kill, killall 比如: kill -9 pid 信号名称编号能否屏蔽默认动作 SIGINT2YES进程自己退出 SIGTERM15YES进程自己退出 SIGQUIT3YES执行 core dump, 自己退出 SIGKILL9NO进程被内核干掉 进程的 遗言 退出码: 0 或者非 0 进程的暂停: TSTP 温柔暂停, STOP 强制暂停, CONT 恢复进程. 比如 kill -STOP pid. job 的前台, 后台, 前后台切换: fg 命令后台到前台 (栈顺序), jobs 列出作业. cmd &amp; 挂起到后台. 环境变量: 一种简单的进程通讯机制 标准流: stdin, stdout, stderr 重定向: &lt; stdin, &gt; stdout 但是覆写, &gt;&gt; stdout, 但是增添 anonymous pipe: |, 通过管道符链接的是同属于一个 job 批处理: ; then, &amp;&amp; and, || or Keyboard Layout, Networking, and Partitioning 和外设相关的东西&#8230; 键盘布局 默认是 qwerty 布局, 结束. loadkeys --default 网络 (我一直觉得网络这部分非常神奇和难懂) 这里有两个命令 ifconfig 和 ip, 后者类似于是前者的更加新的一个替代, 本着死要一起作的精神, 我决定两个都了解一点点: (Cheat Sheet) 列出本台电脑上有的一些网络设备: ipconfig -a (ip a) 列出的东西大概如下: enpOs1 Link encap:Ethernet Hwaddr XX:XX:XX:XX:XX:XX inet addr: XX.XX.XX.XX Bcast: XX.XX.XX.XX Mask:XX.XX.XX.XX UP BROADCAST RUNNING MULTICAST DYNAMIC MTU: 1500 Metric:1 ... 解释一下: 名字 enp0s1 里面的 en 表示 Ethernet (以太网), p0 表示 bus number, s1 表示 slot number. (参考) 更加详细的说明 &lt;interface&gt; ::= &lt;type&gt; &lt;name&gt; &lt;type&gt; ::= en ;; Ethernet | sl ;; serial line IP (slip) | wl ;; wlan | ww ;; wwan &lt;name&gt; ::= b&lt;number&gt; ;; BCMA bus core bumber | c&lt;bus_id&gt; ;; CCW bus group name, without leading zeros | o&lt;index&gt;[d&lt;dev_port&gt;] ;; on-board device index number | s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;] ;; hotplug slot index number | x&lt;MAC&gt; ;; MAC address | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;] ;; PCI geographical location | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;] ;; USB port number chain macOS 上的小小区别在 mac 上运行 ipconfig -a 会得到一堆的东西, 可以参考 这里 (日语). 下面是一个简单的翻译 (部分): Internet Interface说明 lo0loopback interface, localhost en0以前是以太网 (Ethernet), 现在是 Wifi en1, en2Thunderbolt fw0FireWire &#8230;&#8230; 设置网络连接 有线网络连接: ifconfig enp0s1 up (ip link set enp0s1 up) 实际上做的事情是使某一个设备可工作 (up), 换成 down 就关闭工作. 无线网络连接: wpa_supplicant -c &lt;config.conf&gt; -i &lt;interface&gt; -B 其中 config.conf 文件中包含网络信息 network={ ssid=&quot;my-ssid&quot; key_mgmt=WPA-PSK psk=&quot;the network&#39;s secret passphrase&quot; } 获取 IP 地址: dhclient -v &lt;interface&gt; 确认连接到了互联网: ping -c 3 gnu.org Proxy (呵) herd set-http-proxy guix-daemon URL SSH herd start ssh-daemon 先设置一个 passwd 方便连接进去, 再使用 IP 连接到电脑上 磁盘分区 Linux 的分区和 Windows 还有 mac 的感觉稍微有点不太一样, 分区的作用更多是用于映射. (可以参考: Linux磁盘分区、挂载度 (github 笔记), 推荐的分区方案 (redhat), Linux 硬盘分区指南 (zhihu)) 首先是 Linux 的文件结构, 类似于一个树状的结构: / ;; root /home ;; user files /boot ;; boot loader files ;; ... 对于每个目录, 可以选择映射到一个磁盘分区上. 或者说, 把磁盘分区挂载到对应的目录上面. 使用 cdfdisk 可以比较轻松地分区, 总之磁盘 label type 选 GPT, 然后就分区就好了吧. 每一步操作完使用 Write 写入自己的操作. 一般应该是推荐给 boot 分一个区 (300MB 左右, 分区的时候改成 UEFI 类型), 然后给 root 分一个区吧. 对分完区的磁盘使用 lsblk 可以查看分区和挂载情况, 使用 mkfs.ext4 -L root /dev/sda2 可以进行文件系统初始化. (这里用的是 ext4 类型的文件系统) 分好了区之后就可以把它们挂载到对应目录下去了: mount LABEL=root /mnt. 那么为什么不直接挂载到对应的分区上面呢? 我认为是现在是安装镜像挂载在对应的目录上. Guix Configuration 那么让我来介绍一下最让我对 Guix 系统感到非常满意的一个地方吧: 那就是 Guix 是一个支持系统级的配置文件的一个东西. 就比如说 Emacs, Vim 这些软件的配置, 都只是一个软件上的配置; 像 homebrew 这样的包管理器, 也不是很方便导出. 移植到其他的配置文件里面去. 懒得配置的可以直接使用 /etc/configuration/ 下面的配置文件. herd start cow-store /mnt: 保证接下来的操作是写入 /mnt 而不是写在内存中 (这一步不是很理解具体对应的操作, 总之现在不是很懂, 做了再说) 编辑配置文件到 /mnt/etc/config.scm 里面 只要一句话, 让 Guix 为我在挂载在 /mnt 上的磁盘里面初始化一个系统: guix system init /mnt/etc/config.scm /mnt 让 Guix 用 /mnt/etc/config.scm 的配置文件在 /mnt 下初始化一个系统. (注: 受限于网络问题, 可能得重试几次, 我再找找看国内镜像解决方案.) 然后 reboot 重启或者 shutdown 跑路, 大概应该就可以了. After Installation System Update guix pull sudo guix system reconfigure /etc/config.scm 先这么多" />
<link rel="canonical" href="/misc/guix-installation/" />
<meta property="og:url" content="/misc/guix-installation/" />
<meta property="og:site_name" content="My Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-10-19T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Guix Installation" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-10-19T00:00:00+00:00","datePublished":"2023-10-19T00:00:00+00:00","description":"About 尽管我是挺反感那种安装电脑系统的教程的, 现在的电脑系统不都做成了傻瓜机了么? 还有啥好看安装教程的&#8230; 但是现在要接触 Linux 的电脑, 想要多学一些稍微底层一些的知识, 所以留一个小笔记. 目前先在自己的电脑上用虚拟机试试, 至少跑通先吧. 参考的教程见 Mannual Installation (Guix). (先叠个甲: 我没学过啥操作系统, 这些词或者概念完全不了解, 这安装完全就是图一乐) Load the Installation Image 插入安装镜像启动后选择从 shell 开始安装: Ctrl-Alt-F3 可以为你打开 TTY3. 顺带一提, Ctrl-Alt-F4, Ctrl-Alt-F5 对应 TTY4, TTY5. 但是 Ctrl-Alt-F2 对应帮助文档. TTY 的历史 很多时候感觉学习的一些东西就只是知识, 或者说知道即可的水平. 但是知道这些东西为啥来, 虽然看起来没啥鸟用, 但是至少会让我有一种安心的感觉. 虽然我也不能保证这玩意能是啥正确的历史就是了. 我觉得有一个写得还算比较通俗易懂的博客: 扫盲 Linux &amp; UNIX 命令行 &#8211; 从 “电传打字机” 聊到 “shell 脚本编程”. (叠甲: 俺只管里面的技术历史部分, 其他的不做评价). 对于懒得看, 也不想看的同学, 可以看看下面我的一些简单介绍: TTY, 全称为 Teletype Printer, 也就是电传打印机, 实际上是和物理的硬件对应的一个概念: 这玩意大概类似于一个带了根数据线 (UART) 的打字机. 终端缓冲模式: 字符模式, 行模式, 屏模式 在我写过单片机后, 我对几个的概念倒是可以比较好理解了, 比如说字符模式可以对应于一个数据被按下后立刻发送给单片机, 行模式类似于编辑一行后再发送. emmm&#8230; 感觉用 readline 来类比可能会更加好. 回显: 例子就是在输入密码的时候的不显示 (回显关闭), 来自于暂停发送和恢复发送. 控制台: 从早期的物理控制台, 到现在的虚拟控制台 (vitrual console). 因为虚拟控制台是为了模拟物理控制台, 所以是一种 terminal emulator (终端模拟器). 伪终端: PTY (pseudotty), 通过图形界面的软件来模拟文本终端 shell 和 terminal: terminal 类似于一个和机器进行输入输出的信息交流通道, 而 shell 类似于一个机器根据得到的信息进行命令解释和执行的东西. 进程 进程树: 父进程为根, 子进程为叶子 进程的死法: 自然死亡, 自杀 (信号, 中断, Ctrl-C 中断信号是终端发的), 他杀 (信号) 孤儿进程: 父进程死亡, 子进程被初始进程领养 (直接调整到进程树根节点下级) 进程的杀死: kill, killall 比如: kill -9 pid 信号名称编号能否屏蔽默认动作 SIGINT2YES进程自己退出 SIGTERM15YES进程自己退出 SIGQUIT3YES执行 core dump, 自己退出 SIGKILL9NO进程被内核干掉 进程的 遗言 退出码: 0 或者非 0 进程的暂停: TSTP 温柔暂停, STOP 强制暂停, CONT 恢复进程. 比如 kill -STOP pid. job 的前台, 后台, 前后台切换: fg 命令后台到前台 (栈顺序), jobs 列出作业. cmd &amp; 挂起到后台. 环境变量: 一种简单的进程通讯机制 标准流: stdin, stdout, stderr 重定向: &lt; stdin, &gt; stdout 但是覆写, &gt;&gt; stdout, 但是增添 anonymous pipe: |, 通过管道符链接的是同属于一个 job 批处理: ; then, &amp;&amp; and, || or Keyboard Layout, Networking, and Partitioning 和外设相关的东西&#8230; 键盘布局 默认是 qwerty 布局, 结束. loadkeys --default 网络 (我一直觉得网络这部分非常神奇和难懂) 这里有两个命令 ifconfig 和 ip, 后者类似于是前者的更加新的一个替代, 本着死要一起作的精神, 我决定两个都了解一点点: (Cheat Sheet) 列出本台电脑上有的一些网络设备: ipconfig -a (ip a) 列出的东西大概如下: enpOs1 Link encap:Ethernet Hwaddr XX:XX:XX:XX:XX:XX inet addr: XX.XX.XX.XX Bcast: XX.XX.XX.XX Mask:XX.XX.XX.XX UP BROADCAST RUNNING MULTICAST DYNAMIC MTU: 1500 Metric:1 ... 解释一下: 名字 enp0s1 里面的 en 表示 Ethernet (以太网), p0 表示 bus number, s1 表示 slot number. (参考) 更加详细的说明 &lt;interface&gt; ::= &lt;type&gt; &lt;name&gt; &lt;type&gt; ::= en ;; Ethernet | sl ;; serial line IP (slip) | wl ;; wlan | ww ;; wwan &lt;name&gt; ::= b&lt;number&gt; ;; BCMA bus core bumber | c&lt;bus_id&gt; ;; CCW bus group name, without leading zeros | o&lt;index&gt;[d&lt;dev_port&gt;] ;; on-board device index number | s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;] ;; hotplug slot index number | x&lt;MAC&gt; ;; MAC address | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;] ;; PCI geographical location | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;] ;; USB port number chain macOS 上的小小区别在 mac 上运行 ipconfig -a 会得到一堆的东西, 可以参考 这里 (日语). 下面是一个简单的翻译 (部分): Internet Interface说明 lo0loopback interface, localhost en0以前是以太网 (Ethernet), 现在是 Wifi en1, en2Thunderbolt fw0FireWire &#8230;&#8230; 设置网络连接 有线网络连接: ifconfig enp0s1 up (ip link set enp0s1 up) 实际上做的事情是使某一个设备可工作 (up), 换成 down 就关闭工作. 无线网络连接: wpa_supplicant -c &lt;config.conf&gt; -i &lt;interface&gt; -B 其中 config.conf 文件中包含网络信息 network={ ssid=&quot;my-ssid&quot; key_mgmt=WPA-PSK psk=&quot;the network&#39;s secret passphrase&quot; } 获取 IP 地址: dhclient -v &lt;interface&gt; 确认连接到了互联网: ping -c 3 gnu.org Proxy (呵) herd set-http-proxy guix-daemon URL SSH herd start ssh-daemon 先设置一个 passwd 方便连接进去, 再使用 IP 连接到电脑上 磁盘分区 Linux 的分区和 Windows 还有 mac 的感觉稍微有点不太一样, 分区的作用更多是用于映射. (可以参考: Linux磁盘分区、挂载度 (github 笔记), 推荐的分区方案 (redhat), Linux 硬盘分区指南 (zhihu)) 首先是 Linux 的文件结构, 类似于一个树状的结构: / ;; root /home ;; user files /boot ;; boot loader files ;; ... 对于每个目录, 可以选择映射到一个磁盘分区上. 或者说, 把磁盘分区挂载到对应的目录上面. 使用 cdfdisk 可以比较轻松地分区, 总之磁盘 label type 选 GPT, 然后就分区就好了吧. 每一步操作完使用 Write 写入自己的操作. 一般应该是推荐给 boot 分一个区 (300MB 左右, 分区的时候改成 UEFI 类型), 然后给 root 分一个区吧. 对分完区的磁盘使用 lsblk 可以查看分区和挂载情况, 使用 mkfs.ext4 -L root /dev/sda2 可以进行文件系统初始化. (这里用的是 ext4 类型的文件系统) 分好了区之后就可以把它们挂载到对应目录下去了: mount LABEL=root /mnt. 那么为什么不直接挂载到对应的分区上面呢? 我认为是现在是安装镜像挂载在对应的目录上. Guix Configuration 那么让我来介绍一下最让我对 Guix 系统感到非常满意的一个地方吧: 那就是 Guix 是一个支持系统级的配置文件的一个东西. 就比如说 Emacs, Vim 这些软件的配置, 都只是一个软件上的配置; 像 homebrew 这样的包管理器, 也不是很方便导出. 移植到其他的配置文件里面去. 懒得配置的可以直接使用 /etc/configuration/ 下面的配置文件. herd start cow-store /mnt: 保证接下来的操作是写入 /mnt 而不是写在内存中 (这一步不是很理解具体对应的操作, 总之现在不是很懂, 做了再说) 编辑配置文件到 /mnt/etc/config.scm 里面 只要一句话, 让 Guix 为我在挂载在 /mnt 上的磁盘里面初始化一个系统: guix system init /mnt/etc/config.scm /mnt 让 Guix 用 /mnt/etc/config.scm 的配置文件在 /mnt 下初始化一个系统. (注: 受限于网络问题, 可能得重试几次, 我再找找看国内镜像解决方案.) 然后 reboot 重启或者 shutdown 跑路, 大概应该就可以了. After Installation System Update guix pull sudo guix system reconfigure /etc/config.scm 先这么多","headline":"Guix Installation","mainEntityOfPage":{"@type":"WebPage","@id":"/misc/guix-installation/"},"url":"/misc/guix-installation/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">

  <style type="text/css">
    img {
      margin-left: auto; 
      margin-right:auto; 
      display:block;
    }
  </style><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="My Blog" /><script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
        ],
        // • rendering keys, e.g.:
        throwOnError : false
      });
  });
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.css" integrity="sha384-z91AFMXXGZasvxZz5DtKJse3pKoTPU0QcNFj/B4gDFRmq6Q2bi1StsT7SOcIzLEN" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/katex.min.js" integrity="sha384-Af7YmksQNWRLMvro3U9F84xa0paoIu7Pu2niAIUmZoI09Q4aCsbha5dvaj1tHy6K" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.23/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">My Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/categories/">Categories</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Guix Installation</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-10-19T00:00:00+00:00" itemprop="datePublished">Oct 19, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1>About</h1>
<p>尽管我是挺反感那种安装电脑系统的教程的, 现在的电脑系统不都做成了傻瓜机了么?
  还有啥好看安装教程的&#8230; 但是现在要接触 Linux 的电脑, 想要多学一些稍微底层一些的知识,
  所以留一个小笔记.</p>
<p>目前先在自己的电脑上用虚拟机试试, 至少跑通先吧.
  参考的教程见 <a href="https://guix.gnu.org/manual/en/html_node/Manual-Installation.html">Mannual Installation (Guix)</a>.</p>
<p>(先叠个甲: 我没学过啥操作系统, 这些词或者概念完全不了解,
  这安装完全就是图一乐)</p>
<h1>Load the Installation Image</h1>
<p>插入安装镜像启动后选择从 shell 开始安装: <code>Ctrl-Alt-F3</code> 可以为你打开 TTY3.
  顺带一提, <code>Ctrl-Alt-F4</code>, <code>Ctrl-Alt-F5</code> 对应 TTY4, TTY5.
  但是 <code>Ctrl-Alt-F2</code> 对应帮助文档.</p>
<details><summary>TTY 的历史</summary>
<p>很多时候感觉学习的一些东西就只是知识, 或者说知道即可的水平.
  但是知道这些东西为啥来, 虽然看起来没啥鸟用, 但是至少会让我有一种安心的感觉.
  虽然我也不能保证这玩意能是啥正确的历史就是了.</p>
<p>我觉得有一个写得还算比较通俗易懂的博客:
  <a href="https://program-think.blogspot.com/2019/11/POSIX-TUI-from-TTY-to-Shell-Programming.html">扫盲 Linux &amp; UNIX 命令行 &#8211; 从 “电传打字机” 聊到 “shell 脚本编程”</a>.
  (叠甲: 俺只管里面的技术历史部分, 其他的不做评价).
  对于懒得看, 也不想看的同学, 可以看看下面我的一些简单介绍:</p>
<ul>
  <li>TTY, 全称为 Teletype Printer, 也就是电传打印机,
    实际上是和物理的硬件对应的一个概念:
    这玩意大概类似于一个带了根数据线 (UART) 的打字机.</li>
  <li>终端缓冲模式: 字符模式, 行模式, 屏模式
    <p>在我写过单片机后, 我对几个的概念倒是可以比较好理解了,
      比如说字符模式可以对应于一个数据被按下后立刻发送给单片机,
      行模式类似于编辑一行后再发送. emmm&#8230; 感觉用 readline 来类比可能会更加好.</p>
  </li>
  <li>回显: 例子就是在输入密码的时候的不显示 (回显关闭), 来自于暂停发送和恢复发送.</li>
  <li>控制台: 从早期的物理控制台, 到现在的虚拟控制台 (vitrual console).
    因为虚拟控制台是为了模拟物理控制台, 所以是一种 terminal emulator (终端模拟器).</li>
  <li>伪终端: PTY (pseudotty), 通过图形界面的软件来模拟文本终端</li>
  <li>shell 和 terminal: terminal 类似于一个和机器进行输入输出的信息交流通道,
    而 shell 类似于一个机器根据得到的信息进行命令解释和执行的东西.</li>
  <li>进程
    <ul>
      <li>进程树: 父进程为根, 子进程为叶子</li>
      <li>进程的死法: 自然死亡, 自杀 (信号, 中断, <code>Ctrl-C</code> 中断信号是终端发的), 他杀 (信号)</li>
      <li>孤儿进程: 父进程死亡, 子进程被初始进程领养 (直接调整到进程树根节点下级)</li>
      <li>进程的杀死: <code>kill</code>, <code>killall</code>
        <p>比如: <code>kill -9 pid</code></p>
        <table>
          <tr><th>信号名称</th><th>编号</th><th>能否屏蔽</th><th>默认动作</th></tr>
          <tr><td>SIGINT</td><td>2</td><td>YES</td><td>进程自己退出</td></tr>
          <tr><td>SIGTERM</td><td>15</td><td>YES</td><td>进程自己退出</td></tr>
          <tr><td>SIGQUIT</td><td>3</td><td>YES</td><td>执行 core dump, 自己退出</td></tr>
          <tr><td>SIGKILL</td><td>9</td><td>NO</td><td>进程被内核干掉</td></tr>
        </table>
      </li>
      <li>进程的 <del>遗言</del> 退出码: 0 或者非 0</li>
      <li>进程的暂停: <code>TSTP</code> 温柔暂停, <code>STOP</code> 强制暂停, <code>CONT</code> 恢复进程.
        <p>比如 <code>kill -STOP pid</code>.</p>
      </li>
      <li>job 的前台, 后台, 前后台切换: <code>fg</code> 命令后台到前台 (栈顺序), <code>jobs</code> 列出作业.
        <code>cmd &amp;</code> 挂起到后台.</li>
    </ul>
  </li>
  <li>环境变量: 一种简单的进程通讯机制</li>
  <li>标准流: <code>stdin</code>, <code>stdout</code>, <code>stderr</code>
    <ul>
      <li>重定向: <code>&lt;</code> stdin, <code>&gt;</code> stdout 但是覆写, <code>&gt;&gt;</code> stdout, 但是增添</li>
      <li>anonymous pipe: <code>|</code>, 通过管道符链接的是同属于一个 job</li>
    </ul>
  </li>
  <li>批处理: <code>;</code> then, <code>&amp;&amp;</code> and, <code>||</code> or</li>
</ul>
</details>
<h1>Keyboard Layout, Networking, and Partitioning</h1>
<p>和外设相关的东西&#8230;</p>
<h2>键盘布局</h2>
<p>默认是 qwerty 布局, 结束.</p>
<div class="highlight"><pre><span></span>loadkeys<span class="w"> </span>--default
</pre></div>
<h2>网络</h2>
<p>(我一直觉得网络这部分非常神奇和难懂)</p>
<p>这里有两个命令 <code>ifconfig</code> 和 <code>ip</code>, 后者类似于是前者的更加新的一个替代,
  本着死要一起作的精神, 我决定两个都了解一点点: (<a href="https://access.redhat.com/sites/default/files/attachments/rh_ip_command_cheatsheet_1214_jcs_print.pdf">Cheat Sheet</a>)</p>
<ul>
  <li>列出本台电脑上有的一些网络设备: <code>ipconfig -a</code> (<code>ip a</code>)
    <p>列出的东西大概如下:</p>
    <pre class="example">
enpOs1 Link encap:Ethernet    Hwaddr XX:XX:XX:XX:XX:XX
       inet addr: XX.XX.XX.XX Bcast: XX.XX.XX.XX Mask:XX.XX.XX.XX
       UP BROADCAST RUNNING MULTICAST DYNAMIC MTU: 1500 Metric:1
       ...
    </pre>
    <p>解释一下: 名字 <code>enp0s1</code> 里面的 <code>en</code> 表示 Ethernet (以太网),
      <code>p0</code> 表示 bus number, <code>s1</code> 表示 slot number. (<a href="https://unix.stackexchange.com/questions/134483/why-is-my-ethernet-interface-called-enp0s10-instead-of-eth0">参考</a>)</p>
  <details><summary>更加详细的说明</summary>
    <pre class="example">
&lt;interface&gt; ::= &lt;type&gt; &lt;name&gt;
&lt;type&gt;      ::= en          ;; Ethernet
              | sl          ;; serial line IP (slip)
              | wl          ;; wlan
              | ww          ;; wwan
&lt;name&gt;      ::= b&lt;number&gt;   ;; BCMA bus core bumber
              | c&lt;bus_id&gt;   ;; CCW bus group name, without leading zeros
              | o&lt;index&gt;[d&lt;dev_port&gt;]
                            ;; on-board device index number
              | s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;]
                            ;; hotplug slot index number
              | x&lt;MAC&gt;      ;; MAC address
              | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;]
                            ;; PCI geographical location
              | [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;]
                            ;; USB port number chain
    </pre>
  </details>
  <details><summary>macOS 上的小小区别</summary>在 mac 上运行 <code>ipconfig -a</code> 会得到一堆的东西, 可以参考 <a href="https://qiita.com/fastso/items/db46e03fbacac9b38793">这里 (日语)</a>.
    下面是一个简单的翻译 (部分):
    <table>
      <tr><th>Internet Interface</th><th>说明</th></tr>
      <tr><td>lo0</td><td>loopback interface, localhost</td></tr>
      <tr><td>en0</td><td>以前是以太网 (Ethernet), 现在是 Wifi</td></tr>
      <tr><td>en1, en2</td><td>Thunderbolt</td></tr>
      <tr><td>fw0</td><td>FireWire</td></tr>
      <tr><td>&#8230;</td><td>&#8230;</td></tr>
    </table>
  </details>
  </li>
  <li>设置网络连接
    <ul>
      <li>有线网络连接: <code>ifconfig enp0s1 up</code> (<code>ip link set enp0s1 up</code>)
        <p>实际上做的事情是使某一个设备可工作 (<code>up</code>), 换成 <code>down</code> 就关闭工作.</p>
      </li>
      <li>无线网络连接: <code>wpa_supplicant -c &lt;config.conf&gt; -i &lt;interface&gt; -B</code>
    <details><summary>其中 config.conf 文件中包含网络信息</summary>
        <pre class="example">
network={
  ssid=&quot;my-ssid&quot;
  key_mgmt=WPA-PSK
  psk=&quot;the network&#39;s secret passphrase&quot;
}
        </pre>
    </details>
      </li>
    </ul>
  </li>
  <li>获取 IP 地址: <code>dhclient -v &lt;interface&gt;</code></li>
  <li>确认连接到了互联网: <code>ping -c 3 gnu.org</code></li>
  <li>Proxy (呵) <code>herd set-http-proxy guix-daemon URL</code></li>
  <li>SSH <code>herd start ssh-daemon</code>
    <p>先设置一个 <code>passwd</code> 方便连接进去, 再使用 IP 连接到电脑上</p>
  </li>
</ul>
<h2>磁盘分区</h2>
<ul>
  <li>Linux 的分区和 Windows 还有 mac 的感觉稍微有点不太一样,
    分区的作用更多是用于映射. (可以参考: <a href="https://github.com/Sunxz007/Linux-note-follow-Hanshunping/blob/master/课程笔记/3.8Linux磁盘分区、挂载度.md">Linux磁盘分区、挂载度 (github 笔记)</a>,
    <a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-x86">推荐的分区方案 (redhat)</a>, <a href="https://zhuanlan.zhihu.com/p/408467806">Linux 硬盘分区指南 (zhihu)</a>)
    <p>首先是 Linux 的文件结构, 类似于一个树状的结构:</p>
    <pre class="example">
/                      ;; root
/home                  ;; user files
/boot                  ;; boot loader files
;; ...
    </pre>
    <p>对于每个目录, 可以选择映射到一个磁盘分区上. 或者说,
      把磁盘分区挂载到对应的目录上面.</p>
  </li>
  <li>使用 <code>cdfdisk</code> 可以比较轻松地分区, 总之磁盘 <code>label type</code> 选 GPT,
    然后就分区就好了吧. 每一步操作完使用 <code>Write</code> 写入自己的操作.</li>
  <li>一般应该是推荐给 <code>boot</code> 分一个区 (300MB 左右, 分区的时候改成 UEFI 类型),
    然后给 <code>root</code> 分一个区吧.</li>
  <li>对分完区的磁盘使用 <code>lsblk</code> 可以查看分区和挂载情况,
    使用 <code>mkfs.ext4 -L root /dev/sda2</code> 可以进行文件系统初始化.
    (这里用的是 <code>ext4</code> 类型的文件系统)</li>
  <li>分好了区之后就可以把它们挂载到对应目录下去了:
    <code>mount LABEL=root /mnt</code>.
    <p>那么为什么不直接挂载到对应的分区上面呢?
      我认为是现在是安装镜像挂载在对应的目录上.</p>
  </li>
</ul>
<h1>Guix Configuration</h1>
<p>那么让我来介绍一下最让我对 Guix 系统感到非常满意的一个地方吧:
  那就是 Guix 是一个支持系统级的配置文件的一个东西.
  就比如说 Emacs, Vim 这些软件的配置, 都只是一个软件上的配置;
  像 homebrew 这样的包管理器, 也不是很方便导出. 移植到其他的配置文件里面去.</p>
<p>懒得配置的可以直接使用 <code>/etc/configuration/</code> 下面的配置文件.</p>
<ol>
  <li><code>herd start cow-store /mnt</code>: 保证接下来的操作是写入 <code>/mnt</code> 而不是写在内存中
    <p>(这一步不是很理解具体对应的操作, 总之现在不是很懂, 做了再说)</p>
  </li>
  <li>编辑配置文件到 <code>/mnt/etc/config.scm</code> 里面</li>
  <li>只要一句话, 让 Guix 为我在挂载在 <code>/mnt</code> 上的磁盘里面初始化一个系统:
<div class="highlight"><pre><span></span>guix<span class="w"> </span>system<span class="w"> </span>init<span class="w"> </span>/mnt/etc/config.scm<span class="w"> </span>/mnt
</pre></div>
    <p>让 Guix 用 <code>/mnt/etc/config.scm</code> 的配置文件在 <code>/mnt</code> 下初始化一个系统.</p>
    <p>(注: 受限于网络问题, 可能得重试几次, 我再找找看国内镜像解决方案.)</p>
  </li>
  <li>然后 <code>reboot</code> 重启或者 <code>shutdown</code> 跑路, 大概应该就可以了.</li>
</ol>
<h1>After Installation</h1>
<h2>System Update</h2>
<div class="highlight"><pre><span></span>guix<span class="w"> </span>pull
sudo<span class="w"> </span>guix<span class="w"> </span>system<span class="w"> </span>reconfigure<span class="w"> </span>/etc/config.scm
</pre></div>
<h2>先这么多</h2>

  </div><a class="u-url" href="/misc/guix-installation/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">My Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">My Blog</li><li><a class="u-email" href="mailto:thebigbigwordl@qq.com">thebigbigwordl@qq.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/li-yiyang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">li-yiyang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>某不知名的很硬的双非学校的物理系学生的无聊博客</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
